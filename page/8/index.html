<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="xiaowu&#39;s blog">
<meta property="og:url" content="https://zhouxiaowu.coding.me/page/8/index.html">
<meta property="og:site_name" content="xiaowu&#39;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xiaowu&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhouxiaowu.coding.me/page/8/"/>





  <title>xiaowu's blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3da41265a1a0042eebe5413c0d6c76f5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiaowu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-dubbo">
          <a href="/categories/Dubbo" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            Dubbo
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouxiaowu.coding.me/2018/06/19/sublime-user-setting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/19/sublime-user-setting/" itemprop="url">sublime user setting</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T15:02:46+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/运维/" itemprop="url" rel="index">
                    <span itemprop="name">运维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/19/sublime-user-setting/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/19/sublime-user-setting/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  294
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Sublime3</p>
<ul>
<li>Preferences -&gt; settings  User配置</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"atomic_save"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"color_scheme"</span>: <span class="string">"Packages/Color Scheme - Default/Mariana.sublime-color-scheme"</span>,</span><br><span class="line">	<span class="attr">"draw_white_space"</span>: <span class="string">"all"</span>,</span><br><span class="line">	<span class="attr">"font_face"</span>: <span class="string">"YaHei Consolas Hybrid"</span>,</span><br><span class="line">	<span class="attr">"font_size"</span>: <span class="number">14</span>,</span><br><span class="line">	<span class="attr">"ignored_packages"</span>:</span><br><span class="line">	[</span><br><span class="line">		<span class="string">"Vintage"</span></span><br><span class="line">	],</span><br><span class="line">	<span class="attr">"open_files_in_new_window"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"save_on_focus_lost"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"soda_classic_tabs"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"soda_folder_icons"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"tab_size"</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="attr">"theme"</span>: <span class="string">"Soda Light 3.sublime-theme"</span>,</span><br><span class="line">	<span class="attr">"translate_tabs_to_spaces"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"trim_trailing_white_space_on_save"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"update_check"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"fold_buttons"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"fade_fold_buttons"</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>手动安装soda</li>
</ul>
<p>Preferences -&gt; browse packages 将<code>Theme - Soda</code>解压放到目录，同一级的还有<code>Pretty JSON</code> <code>User</code></p>
<ul>
<li>中文网 <a href="http://www.sublimetextcn.com/" target="_blank" rel="external">http://www.sublimetextcn.com/</a></li>
</ul>
<h3 id="删除空行"><a href="#删除空行" class="headerlink" title="删除空行"></a>删除空行</h3><p>CTRL+H打开replace功能，勾选上左侧的regular expression，并填写</p>
<p>find what栏 : \s+$  （正则表达式）<br>replace with栏 : （这行留空）</p>
<h3 id="操作多行"><a href="#操作多行" class="headerlink" title="操作多行"></a>操作多行</h3><p>5种方法</p>
<p>1，鼠标选中多行，按下 Ctrl Shift L (Command Shift L) 即可同时编辑这些行；<br>2，鼠标选中文本，反复按 CTRL D (Command D) 即可继续向下同时选中下一个相同的文本进行同时编辑；<br>3，鼠标选中文本，按下 Alt F3 (Win) 或 Ctrl Command G(Mac) 即可一次性选择全部的相同文本进行同时编辑；<br>4，Shift 鼠标右键 (Win) 或 Option 鼠标左键 (Mac) 或使用鼠标中键可以用鼠标进行竖向多行选择；<br>5，Ctrl 鼠标左键(Win) 或 Command 鼠标左键(Mac) 可以手动选择同时要编辑。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouxiaowu.coding.me/2018/06/12/telnet命令详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/telnet命令详解/" itemprop="url">telnet命令详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T14:30:50+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/运维/" itemprop="url" rel="index">
                    <span itemprop="name">运维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/12/telnet命令详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/12/telnet命令详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>telnet命令</strong>用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的<a href="http://man.linuxde.net/ssh" target="_blank" rel="external">ssh</a>方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">telnet</span><span class="params">(选项)</span><span class="params">(参数)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="number">8</span>：允许使用<span class="number">8</span>位字符资料，包括输入与输出；</span></span><br><span class="line"><span class="ruby">-a：尝试自动登入远端系统；</span></span><br><span class="line"><span class="ruby">-b&lt;主机别名&gt;：使用别名指定远端主机名称；</span></span><br><span class="line"><span class="ruby">-c：不读取用户专属目录里的.telnetrc文件；</span></span><br><span class="line"><span class="ruby">-d：启动排错模式；</span></span><br><span class="line"><span class="ruby">-e&lt;脱离字符&gt;：设置脱离字符；</span></span><br><span class="line"><span class="ruby">-E：滤除脱离字符；</span></span><br><span class="line"><span class="ruby">-f：此参数的效果和指定<span class="string">"-F"</span>参数相同；</span></span><br><span class="line"><span class="ruby">-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机；</span></span><br><span class="line"><span class="ruby">-k&lt;域名&gt;：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名；</span></span><br><span class="line"><span class="ruby">-K：不自动登入远端主机；</span></span><br><span class="line"><span class="ruby">-l&lt;用户名称&gt;：指定要登入远端主机的用户名称；</span></span><br><span class="line"><span class="ruby">-L：允许输出<span class="number">8</span>位字符资料；</span></span><br><span class="line"><span class="ruby">-n&lt;记录文件&gt;：指定文件记录相关信息；</span></span><br><span class="line"><span class="ruby">-r：使用类似rlogin指令的用户界面；</span></span><br><span class="line"><span class="ruby">-S&lt;服务类型&gt;：设置telnet连线所需的ip TOS信息；</span></span><br><span class="line"><span class="ruby">-x：假设主机有支持数据加密的功能，就使用它；</span></span><br><span class="line"><span class="ruby">-X&lt;认证形态&gt;：关闭指定的认证形态。</span></span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>远程主机：指定要登录进行管理的远程主机；</li>
<li>端口：指定TELNET协议使用的端口号。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">192.168</span><span class="meta">.2</span><span class="meta">.10</span></span><br><span class="line">Trying <span class="number">192.168</span><span class="meta">.2</span><span class="meta">.10</span>...</span><br><span class="line">Connected to <span class="number">192.168</span><span class="meta">.2</span><span class="meta">.10</span> (<span class="number">192.168</span><span class="meta">.2</span><span class="meta">.10</span>).</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line"></span><br><span class="line">    localhost (Linux release <span class="number">2.6</span><span class="meta">.18</span>-<span class="number">274.18</span><span class="meta">.1</span>.el5 #<span class="number">1</span> SMP Thu Feb <span class="number">9</span> <span class="number">12</span>:<span class="number">45</span>:<span class="number">44</span> EST <span class="number">2012</span>) (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="symbol">login:</span> root</span><br><span class="line"><span class="symbol">Password:</span></span><br><span class="line">Login incorrect</span><br></pre></td></tr></table></figure>
<p><strong>示例1：远程服务器无法访问</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# telnet 192.168.120.209</span><br><span class="line">Trying 192.168.120.209<span class="built_in">..</span>.</span><br><span class="line">telnet: connect <span class="keyword">to</span><span class="built_in"> address </span>192.168.120.209: <span class="literal">No</span><span class="built_in"> route </span><span class="keyword">to</span> host</span><br><span class="line">telnet: Unable <span class="keyword">to</span> connect <span class="keyword">to</span> remote host: <span class="literal">No</span><span class="built_in"> route </span><span class="keyword">to</span> host</span><br></pre></td></tr></table></figure>
<p>处理这种情况方法：<br>（1）确认IP地址是否正确<br>（2）确认IP地址对应的装机是否已经开机<br>（3）如果主机已经启动，确认路由设置是否设置正确（使用route命令查看）<br>（4）如果主机已经启动，确认主机上是否开启了telnet服务（使用netstat命令查看，TCP的23端口是否有LISTEN状态行）<br>（5）如果主机已经启动telnet服务，确认防火墙是否开放了23端口的访问（使用iptables-save查看）</p>
<p><strong>示例2：域名无法解析</strong></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="comment"># telnet www.baidu.com</span></span><br><span class="line">www.baidu.com/telnet: Temporary failure <span class="keyword">in</span> <span class="built_in">name</span> resolution</span><br></pre></td></tr></table></figure>
<p>处理这种情况方法：<br>（1）确认域名是否正确<br>（2）确认本机的域名解析有关的设置是否正确(/etc/resolv.conf中nameserver的配置是否正确，如果没有，可以使用nameserver 8.8.8.8)<br>（3）确认防火墙是否放开了UDP53端口的访问(DNS使用UDP协议，端口53，使用iptables-save查看)</p>
<p><strong>示例3：拒绝访问</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# telnet 192.168.120.206</span><br><span class="line">Trying 192.168.120.206<span class="built_in">..</span>.</span><br><span class="line">telnet: connect <span class="keyword">to</span><span class="built_in"> address </span>192.168.120.206:<span class="built_in"> Connection </span>refused</span><br><span class="line">telnet: Unable <span class="keyword">to</span> connect <span class="keyword">to</span> remote host:<span class="built_in"> Connection </span>refused</span><br></pre></td></tr></table></figure>
<p>处理这种情况方法：<br>（1）确认IP地址或者主机名是否正确<br>（2）确认端口是否正确，是否默认23端口</p>
<p>若要检查192.168.120.206的某端口是否能否能访问，如443端口，可使用如下命令</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# telnet 192.168.120.206 443</span><br><span class="line">Trying 192.168.120.206<span class="built_in">..</span>.</span><br><span class="line">telnet: connect <span class="keyword">to</span><span class="built_in"> address </span>192.168.120.206:<span class="built_in"> Connection </span>refused</span><br></pre></td></tr></table></figure>
<p>说明：这表示192.168.120.206的443端口不能访问</p>
<p><strong>示例4：telnet root用户的登入</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# telnet <span class="number">192.168</span><span class="meta">.120</span><span class="meta">.204</span></span><br><span class="line">Trying <span class="number">192.168</span><span class="meta">.120</span><span class="meta">.204</span>...</span><br><span class="line">Connected to <span class="number">192.168</span><span class="meta">.120</span><span class="meta">.204</span> (<span class="number">192.168</span><span class="meta">.120</span><span class="meta">.204</span>).</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line"></span><br><span class="line">    localhost (Linux release <span class="number">2.6</span><span class="meta">.18</span>-<span class="number">274.18</span><span class="meta">.1</span>.el5 #<span class="number">1</span> SMP Thu Feb <span class="number">9</span> <span class="number">12</span>:<span class="number">45</span>:<span class="number">44</span> EST <span class="number">2012</span>) (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="symbol">login:</span> root</span><br><span class="line"><span class="symbol">Password:</span></span><br><span class="line">Login incorrect</span><br></pre></td></tr></table></figure>
<p>说明：一般情况下不允许root从远程登录，可以先用普通账号登录，然后再su -切到root用户。若要允许root用户登入，可用下列方法：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="comment"># vi /etc/pam.d/login</span></span><br><span class="line"><span class="comment">#auth required pam_securetty.so #将这一行加上注释！</span></span><br><span class="line">或</span><br><span class="line">[root@linuxprobe ~]<span class="comment"># mv /etc/securetty /etc/securetty.bak</span></span><br></pre></td></tr></table></figure>
<p><strong>示例5：启用telnet服务</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]<span class="comment"># cd /etc/xinetd.d/</span></span><br><span class="line">[root@linuxprobe xinetd.d]<span class="comment"># ll</span></span><br><span class="line">总计 124</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1157 </span>2011-05-31 chargen-dgram</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1159 </span>2011-05-31 chargen-stream</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 523 </span>2009-09-04 cvs</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1157 </span>2011-05-31 daytime-dgram</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1159 </span>2011-05-31 daytime-stream</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1157 </span>2011-05-31 discard-dgram</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1159 </span>2011-05-31 discard-stream</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1148 </span>2011-05-31 echo-dgram</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1150 </span>2011-05-31 echo-stream</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 323 </span>2004-09-09 eklogin</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 347 </span>2005-09-06 ekrb5-telnet</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 326 </span>2004-09-09 gssftp</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 310 </span>2004-09-09 klogin</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 323 </span>2004-09-09 krb5-telnet</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 308 </span>2004-09-09 kshell</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 317 </span>2004-09-09 rsync</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1212 </span>2011-05-31 tcpmux-server</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1149 </span>2011-05-31 time-dgram</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 1150 </span>2011-05-31 time-stream</span><br><span class="line">[root@linuxprobe xinetd.d]<span class="comment"># cat krb5-telnet</span></span><br><span class="line"><span class="comment"># default: off</span></span><br><span class="line"><span class="comment"># description: The kerberized telnet server accepts normal telnet sessions, \</span></span><br><span class="line"><span class="comment">#              but can also use Kerberos 5 authentication.</span></span><br><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">        flags           = REUSE</span><br><span class="line">        socket_type     = stream</span><br><span class="line">        wait            = no</span><br><span class="line">        user            = root</span><br><span class="line">        server          = /usr/kerberos/sbin/telnetd</span><br><span class="line">        log_on_failure  += USERID</span><br><span class="line">        disable         = yes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置参数通常如下：</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">service telnet</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">disable</span> = <span class="literal">no</span> #启用</span><br><span class="line"></span><br><span class="line">flags = REUSE #socket可重用</span><br><span class="line"></span><br><span class="line">socket_type = stream #连接方式为TCP</span><br><span class="line"></span><br><span class="line">wait = <span class="literal">no</span> #为每个请求启动一个进程</span><br><span class="line"></span><br><span class="line">user = root #启动服务的用户为root</span><br><span class="line"></span><br><span class="line">server = /usr/sbin/<span class="keyword">in</span>.telnetd #要激活的进程</span><br><span class="line"></span><br><span class="line">log_on_failure += USERID #登录失败时记录登录用户名</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要配置允许登录的客户端列表，加入<br>only_from = 192.168.0.2 #只允许192.168.0.2登录<br>如果要配置禁止登录的客户端列表，加入<br>no_access = 192.168.0.{2,3,4} #禁止192.168.0.2、192.168.0.3、192.168.0.4登录<br>如果要设置开放时段，加入<br>access_times = 9:00-12:00 13:00-17:00 # 每天只有这两个时段开放服务（我们的上班时间：P）<br>如果你有两个IP地址，一个是私网的IP地址如192.168.0.2，一个是公网的IP地址如218.75.74.83，如果你希望用户只能从私网来登录telnet服务，那么加入<br>bind = 192.168.0.2<br>各配置项具体的含义和语法可参考xined配置文件属性说明（man xinetd.conf）<br>配置端口，修改services文件：<br># vi /etc/services<br>找到以下两句<br>telnet 23/tcp<br>telnet 23/udp<br>如 果前面有#字符，就去掉它。telnet的默认端口是23，这个端口也是黑客端口扫描的主要对象，因此最好将这个端口修改掉，修改的方法很简单，就是将 23这个数字修改掉，改成大一点的数字，比如61123。注意，1024以下的端口号是internet保留的端口号，因此最好不要用，还应该注意不要与 其它服务的端口冲突。<br>启动服务：<code>service xinetd restart</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouxiaowu.coding.me/2018/06/10/zookeeper-watcher机制源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/zookeeper-watcher机制源码分析/" itemprop="url">zookeeper watcher机制源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-10T17:26:40+08:00">
                2018-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/10/zookeeper-watcher机制源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/10/zookeeper-watcher机制源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  38
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Watcher的基本流程"><a href="#Watcher的基本流程" class="headerlink" title="Watcher的基本流程"></a>Watcher的基本流程</h1><p>ZooKeeper 的 Watcher 机制，总的来说可以分为三个过程：客户端注册 Watcher、服务器处理 Watcher 和客户端回调 Watcher</p>
<p>客户端注册watcher有3种方式，getData、exists、getChildren；以如下代码为例来分析整个触发机制的原理</p>
 <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper zookeeper=<span class="keyword">new</span> ZooKeeper(“<span class="number">192.168</span><span class="number">.11</span><span class="number">.152</span>:<span class="number">2181</span>”,<span class="number">4000</span>,<span class="keyword">new</span> Watcher()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processor</span>(<span class="params">WatchedEvent <span class="keyword">event</span></span>)</span>&#123;</span><br><span class="line">		 System.<span class="keyword">out</span>.println(“<span class="keyword">event</span>.type”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">zookeeper.create(“/mic”,”<span class="number">0</span>”.getByte(),ZooDefs.Ids. OPEN_ACL_UNSAFE,CreateModel. PERSISTENT); <span class="comment">//创建节点</span></span><br><span class="line"></span><br><span class="line">zookeeper.exists(“/mic”,<span class="literal">true</span>); <span class="comment">//注册监听</span></span><br><span class="line">zookeeper.setData(“/mic”, “<span class="number">1</span>”.getByte(),<span class="number">-1</span>) ; <span class="comment">//修改节点的值触发监听</span></span><br></pre></td></tr></table></figure>
<h2 id="ZooKeeper-API的初始化过程"><a href="#ZooKeeper-API的初始化过程" class="headerlink" title="ZooKeeper API的初始化过程"></a>ZooKeeper API的初始化过程</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper zookeeper=<span class="keyword">new</span> ZooKeeper(“<span class="number">192.168</span><span class="number">.11</span><span class="number">.152</span>:<span class="number">2181</span>”,<span class="number">4000</span>,<span class="keyword">new</span> Watcher()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processor</span>(<span class="params">WatchedEvent <span class="keyword">event</span></span>)</span>&#123;</span><br><span class="line">		 System.<span class="keyword">out</span>.println(“<span class="keyword">event</span>.type”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure>
<p>在创建一个 ZooKeeper 客户端对象实例时，我们通过new Watcher()向构造方法中传入一个默认的 Watcher, 这个 Watcher 将作为整个 ZooKeeper会话期间的默认 Watcher，会一直被保存在客户端 ZKWatchManager 的 defaultWatcher 中;代码如下</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher,</span><br><span class="line">         <span class="keyword">boolean</span> canBeReadOnly, HostProvider aHostProvider,</span><br><span class="line">         ZKClientConfig clientConfig) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     LOG.info(<span class="string">"Initiating client connection, connectString="</span> + connectString</span><br><span class="line">             + <span class="string">" sessionTimeout="</span> + sessionTimeout + <span class="string">" watcher="</span> + watcher);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (clientConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">         clientConfig = <span class="keyword">new</span> ZKClientConfig();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>.clientConfig = clientConfig;</span><br><span class="line">     watchManager = defaultWatchManager();</span><br><span class="line">     watchManager.defaultWatcher = watcher;  --在这里将watcher设置到ZKWatchManager</span><br><span class="line">     ConnectStringParser connectStringParser = <span class="keyword">new</span> ConnectStringParser(</span><br><span class="line">             connectString);</span><br><span class="line">     hostProvider = aHostProvider;</span><br><span class="line">     --初始化了ClientCnxn，并且调用cnxn.start()方法</span><br><span class="line">     cnxn = <span class="keyword">new</span> ClientCnxn(connectStringParser.getChrootPath(),</span><br><span class="line">             hostProvider, sessionTimeout, <span class="keyword">this</span>, watchManager,</span><br><span class="line">             getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line">     cnxn.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>ClientCnxn:是Zookeeper客户端和Zookeeper服务器端进行通信和事件通知处理的主要类，它内部包含两个类，</p>
<ol>
<li>SendThread  ：负责客户端和服务器端的数据通信, 也包括事件信息的传输</li>
<li>EventThread :  主要在客户端回调注册的Watchers进行通知处理</li>
</ol>
<h3 id="ClientCnxn初始化"><a href="#ClientCnxn初始化" class="headerlink" title="ClientCnxn初始化"></a>ClientCnxn初始化</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ClientCnxn(<span class="keyword">String</span> chrootPath, HostProvider hostProvider, <span class="keyword">int</span> sessionTimeout, ZooKeeper zooKeeper,</span><br><span class="line">           ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span><br><span class="line">           <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd, <span class="keyword">boolean</span> canBeReadOnly) &#123;</span><br><span class="line">       <span class="keyword">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">       <span class="keyword">this</span>.watcher = watcher;</span><br><span class="line">       <span class="keyword">this</span>.sessionId = sessionId;</span><br><span class="line">       <span class="keyword">this</span>.sessionPasswd = sessionPasswd;</span><br><span class="line">       <span class="keyword">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">       <span class="keyword">this</span>.hostProvider = hostProvider;</span><br><span class="line">       <span class="keyword">this</span>.chrootPath = chrootPath;</span><br><span class="line"></span><br><span class="line">       connectTimeout = sessionTimeout / hostProvider.<span class="built_in">size</span>();</span><br><span class="line">       readTimeout = sessionTimeout * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">       readOnly = canBeReadOnly;</span><br><span class="line"></span><br><span class="line">       sendThread = <span class="keyword">new</span> SendThread(clientCnxnSocket);  --初始化sendThread</span><br><span class="line">       eventThread = <span class="keyword">new</span> EventThread();                --初始化eventThread</span><br><span class="line">       <span class="keyword">this</span>.clientConfig=zooKeeper.getClientConfig();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> start() &#123; --启动两个线程</span><br><span class="line">       sendThread.start();</span><br><span class="line">       eventThread.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端通过exists注册监听"><a href="#客户端通过exists注册监听" class="headerlink" title="客户端通过exists注册监听"></a>客户端通过exists注册监听</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.exists(“/mic”,<span class="literal">true</span>); <span class="comment">//注册监听</span></span><br></pre></td></tr></table></figure>
<p>通过exists方法来注册监听，代码如下</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Stat exists(final <span class="keyword">String</span> path, Watcher watcher)</span><br><span class="line">        throws KeeperException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        final <span class="keyword">String</span> clientPath = path;</span><br><span class="line">        PathUtils.validatePath(clientPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the watch contains the un-chroot path</span></span><br><span class="line">        WatchRegistration wcb = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (watcher != <span class="literal">null</span>) &#123;</span><br><span class="line">            wcb = <span class="keyword">new</span> <span class="type">ExistsWatchRegistration</span>(watcher, clientPath); <span class="comment">//构建ExistWatchRegistration</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final <span class="keyword">String</span> serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 构造RequestHeader</span></span><br><span class="line">        RequestHeader h = <span class="keyword">new</span> <span class="type">RequestHeader</span>();</span><br><span class="line">        h.setType(ZooDefs.OpCode.exists);  <span class="comment">//设置操作类型为exists</span></span><br><span class="line">        ExistsRequest request = <span class="keyword">new</span> <span class="type">ExistsRequest</span>();  <span class="comment">// 构造ExistsRequest</span></span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setWatch(watcher != <span class="literal">null</span>);  <span class="comment">//是否注册监听</span></span><br><span class="line">        SetDataResponse response = <span class="keyword">new</span> <span class="type">SetDataResponse</span>();  <span class="comment">//设置服务端响应的接收类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将封装的RequestHeader、ExistsRequest、SetDataResponse、WatchRegistration添加到发送队列</span></span><br><span class="line">        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">        <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.getErr() == KeeperException.Code.NONODE.intValue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.<span class="keyword">get</span>(r.getErr()),</span><br><span class="line">                    clientPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回exists得到的结果（Stat信息）</span></span><br><span class="line">        <span class="keyword">return</span> response.getStat().getCzxid() == <span class="number">-1</span> ? <span class="literal">null</span> : <span class="type">response</span>.getStat();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="cnxn-submitRequest"><a href="#cnxn-submitRequest" class="headerlink" title="cnxn.submitRequest"></a>cnxn.submitRequest</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReplyHeader submitRequest(RequestHeader h, Record request,</span><br><span class="line">            Record response, WatchRegistration watchRegistration,</span><br><span class="line">            WatchDeregistration watchDeregistration)</span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ReplyHeader r = <span class="keyword">new</span> ReplyHeader();</span><br><span class="line">        <span class="comment">//将消息添加到队列,并构造一个Packet传输对象</span></span><br><span class="line">        Packet packet = queuePacket(h, r, request, response, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, watchRegistration, watchDeregistration);</span><br><span class="line">        <span class="keyword">synchronized</span> (packet) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!packet.finished) &#123; <span class="comment">//在数据包没有处理完成之前，一直阻塞</span></span><br><span class="line">                packet.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>将RequestHeader h, ReplyHeader r, Record request, Record response，封装成package， 添加到outgoingQueue队列中，再唤醒sendThread,通知有数据包过来。outgoingQueue是一个阻塞队列，outgoingQueue是待发送的队列。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingDeque&lt;Packet&gt; outgoingQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;Packet&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,</span><br><span class="line">        Record response, AsyncCallback cb, <span class="keyword">String</span> clientPath,</span><br><span class="line">        <span class="keyword">String</span> serverPath, <span class="keyword">Object</span> ctx, WatchRegistration watchRegistration,</span><br><span class="line">        WatchDeregistration watchDeregistration) &#123;</span><br><span class="line">    <span class="comment">//将相关传输对象转化成Packet</span></span><br><span class="line">    Packet packet = <span class="keyword">null</span>;</span><br><span class="line">    packet = <span class="keyword">new</span> Packet(h, r, request, response, watchRegistration);</span><br><span class="line">    packet.cb = cb;</span><br><span class="line">    packet.ctx = ctx;</span><br><span class="line">    packet.clientPath = clientPath;</span><br><span class="line">    packet.serverPath = serverPath;</span><br><span class="line">    packet.watchDeregistration = watchDeregistration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!state.isAlive() || closing) &#123;</span><br><span class="line">            conLossPacket(packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (h.getType() == OpCode.closeSession) &#123;</span><br><span class="line">                closing = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            outgoingQueue.<span class="built_in">add</span>(packet); <span class="comment">//添加到outgoingQueue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendThread.getClientCnxnSocket().packetAdded();<span class="comment">//此处是多路复用机制，唤醒Selector，告诉他有数据包添加过来了</span></span><br><span class="line">    <span class="keyword">return</span> packet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ZooKeeper 中，Packet 是一个最小的通信协议单元，即数据包。Pakcet 用于进行客户端与服务端之间的网络传输，任何需要传输的对象都需要包装成一个 Packet 对象。在 ClientCnxn 中 <strong>WatchRegistration</strong> 也会被封装到 Pakcet 中，然后由 SendThread 线程调用queuePacket方法把 Packet 放入发送队列中等待客户端发送，这又是一个异步过程，分布式系统采用异步通信是一个非常常见的手段。</p>
<h3 id="SendThread的发送过程"><a href="#SendThread的发送过程" class="headerlink" title="SendThread的发送过程"></a>SendThread的发送过程</h3><p>在初始化连接的时候，zookeeper初始化了两个线程并且启动了。接下来我们来分析SendThread的发送过程，因为是一个线程，所以启动的时候会调用SendThread.run方法。</p>
<p>run方法中，通过clientCnxnSocket，去拿队列的数据处理。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">clientCnxnSocket</span><span class="selector-class">.doTransport</span>(<span class="selector-tag">to</span>, <span class="selector-tag">pendingQueue</span>, <span class="selector-tag">ClientCnxn</span><span class="selector-class">.this</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">            clientCnxnSocket.introduce(<span class="keyword">this</span>, sessionId, outgoingQueue);</span><br><span class="line">            clientCnxnSocket.updateNow();</span><br><span class="line">            clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            <span class="built_in">int</span> to;</span><br><span class="line">            <span class="keyword">long</span> lastPingRwServer = Time.currentElapsedTime();</span><br><span class="line">            <span class="keyword">final</span> <span class="built_in">int</span> MAX_SEND_PING_INTERVAL = <span class="number">10000</span>; <span class="comment">//10 seconds</span></span><br><span class="line">            <span class="keyword">while</span> (state.isAlive()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!clientCnxnSocket.isConnected()) &#123;<span class="comment">// 如果没有连接：发起连接</span></span><br><span class="line">                        <span class="comment">// don't re-establish connection if we are closing</span></span><br><span class="line">                        <span class="keyword">if</span> (closing) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startConnect(); <span class="comment">//发起连接</span></span><br><span class="line">                        clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (state.isConnected()) &#123; <span class="comment">//如果是连接状态，则处理sasl的认证授权</span></span><br><span class="line">                        <span class="comment">// determine whether we need to send an AuthFailed event.</span></span><br><span class="line">                        <span class="keyword">if</span> (zooKeeperSaslClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="built_in">boolean</span> sendAuthEvent = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    zooKeeperSaslClient.initialize(ClientCnxn.<span class="keyword">this</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (SaslException e) &#123;</span><br><span class="line">                                   LOG.error(<span class="string">"SASL authentication with Zookeeper Quorum member failed: "</span> + e);</span><br><span class="line">                                    state = States.AUTH_FAILED;</span><br><span class="line">                                    sendAuthEvent = <span class="keyword">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            KeeperState authState = zooKeeperSaslClient.getKeeperState();</span><br><span class="line">                            <span class="keyword">if</span> (authState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (authState == KeeperState.AuthFailed) &#123;</span><br><span class="line">                                    <span class="comment">// An authentication error occurred during authentication with the Zookeeper Server.</span></span><br><span class="line">                                    state = States.AUTH_FAILED;</span><br><span class="line">                                    sendAuthEvent = <span class="keyword">true</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (authState == KeeperState.SaslAuthenticated) &#123;</span><br><span class="line">                                        sendAuthEvent = <span class="keyword">true</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (sendAuthEvent == <span class="keyword">true</span>) &#123;</span><br><span class="line">                                eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(</span><br><span class="line">                                      Watcher.Event.EventType.None,</span><br><span class="line">                                      authState,<span class="keyword">null</span>));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        to = readTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        to = connectTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//to,表示客户端距离timeout还剩多少时间，准备发起ping连接</span></span><br><span class="line">                    <span class="keyword">if</span> (to &lt;= <span class="number">0</span>) &#123;<span class="comment">//表示已经超时了。</span></span><br><span class="line">                        <span class="keyword">String</span> warnInfo;</span><br><span class="line">                        warnInfo = <span class="string">"Client session timed out, have not heard from server in "</span></span><br><span class="line">                            + clientCnxnSocket.getIdleRecv()</span><br><span class="line">                            + <span class="string">"ms"</span></span><br><span class="line">                            + <span class="string">" for sessionid 0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId);</span><br><span class="line">                        LOG.warn(warnInfo);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SessionTimeoutException(warnInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state.isConnected()) &#123;</span><br><span class="line">                        <span class="comment">//计算下一次ping请求的时间</span></span><br><span class="line">                        <span class="built_in">int</span> timeToNextPing = readTimeout / <span class="number">2</span> - clientCnxnSocket.getIdleSend() -</span><br><span class="line">                        		((clientCnxnSocket.getIdleSend() &gt; <span class="number">1000</span>) ? <span class="number">1000</span> : <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">//send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL</span></span><br><span class="line">                        <span class="keyword">if</span> (timeToNextPing &lt;= <span class="number">0</span> || clientCnxnSocket.getIdleSend() &gt; MAX_SEND_PING_INTERVAL) &#123;</span><br><span class="line">                            sendPing(); <span class="comment">//发送ping请求</span></span><br><span class="line">                            clientCnxnSocket.updateLastSend();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (timeToNextPing &lt; to) &#123;</span><br><span class="line">                                to = timeToNextPing;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If we are in read-only mode, seek for read/write server</span></span><br><span class="line">                    <span class="keyword">if</span> (state == States.CONNECTEDREADONLY) &#123;</span><br><span class="line">                        <span class="keyword">long</span> now = Time.currentElapsedTime();</span><br><span class="line">                        <span class="built_in">int</span> idlePingRwServer = (<span class="built_in">int</span>) (now - lastPingRwServer);</span><br><span class="line">                        <span class="keyword">if</span> (idlePingRwServer &gt;= pingRwTimeout) &#123;</span><br><span class="line">                            lastPingRwServer = now;</span><br><span class="line">                            idlePingRwServer = <span class="number">0</span>;</span><br><span class="line">                            pingRwTimeout =</span><br><span class="line">                                Math.<span class="built_in">min</span>(<span class="number">2</span>*pingRwTimeout, maxPingRwTimeout);</span><br><span class="line">                            pingRwServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                        to = Math.<span class="built_in">min</span>(to, pingRwTimeout - idlePingRwServer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    调用clientCnxnSocket，发起传输</span><br><span class="line">                    其中 pendingQueue是一个用来存放已经发送、等待回应的Packet队列，</span><br><span class="line">clientCnxnSocket默认使用ClientCnxnSocketNIO（ps：还记得在哪里初始化吗？在实例化zookeeper的时候）</span><br><span class="line">                    clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (closing) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                            <span class="comment">// closing so this is expected</span></span><br><span class="line">                            LOG.debug(<span class="string">"An exception was thrown while closing send thread for session 0x"</span></span><br><span class="line">                                    + Long.toHexString(getSessionId())</span><br><span class="line">                                    + <span class="string">" : "</span> + e.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// this is ugly, you have a better way speak up</span></span><br><span class="line">                        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SessionExpiredException) &#123;</span><br><span class="line">                            LOG.info(e.getMessage() + <span class="string">", closing socket connection"</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SessionTimeoutException) &#123;</span><br><span class="line">                            LOG.info(e.getMessage() + RETRY_CONN_MSG);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> EndOfStreamException) &#123;</span><br><span class="line">                            LOG.info(e.getMessage() + RETRY_CONN_MSG);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RWServerFoundException) &#123;</span><br><span class="line">                            LOG.info(e.getMessage());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            LOG.warn(</span><br><span class="line">                                    <span class="string">"Session 0x"</span></span><br><span class="line">                                            + Long.toHexString(getSessionId())</span><br><span class="line">                                            + <span class="string">" for server "</span></span><br><span class="line">                                            + clientCnxnSocket.getRemoteSocketAddress()</span><br><span class="line">                                            + <span class="string">", unexpected error"</span></span><br><span class="line">                                            + RETRY_CONN_MSG, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// At this point, there might still be new packets appended to outgoingQueue.</span></span><br><span class="line">                        <span class="comment">// they will be handled in next connection or cleared up if closed.</span></span><br><span class="line">                        cleanup();</span><br><span class="line">                        <span class="keyword">if</span> (state.isAlive()) &#123;</span><br><span class="line">                            eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(</span><br><span class="line">                                    Event.EventType.None,</span><br><span class="line">                                    Event.KeeperState.Disconnected,</span><br><span class="line">                                    <span class="keyword">null</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        clientCnxnSocket.updateNow();</span><br><span class="line">                        clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">                <span class="comment">// When it comes to this point, it guarantees that later queued</span></span><br><span class="line">                <span class="comment">// packet to outgoingQueue will be notified of death.</span></span><br><span class="line">                cleanup();</span><br><span class="line">            &#125;</span><br><span class="line">            clientCnxnSocket.close();</span><br><span class="line">            <span class="keyword">if</span> (state.isAlive()) &#123;</span><br><span class="line">                eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(Event.EventType.None,</span><br><span class="line">                        Event.KeeperState.Disconnected, <span class="keyword">null</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),</span><br><span class="line">                    <span class="string">"SendThread exited loop for session: 0x"</span></span><br><span class="line">                           + Long.toHexString(getSessionId()));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="client-和-server的网络交互"><a href="#client-和-server的网络交互" class="headerlink" title="client 和 server的网络交互"></a>client 和 server的网络交互</h3><p><code>doTransport</code>有两种实现，一种<code>java nio</code>，另一种是<code>netty</code></p>
<p>这里就是sendThread的run方法，发送数据的具体代码。pendingQueue表示处于已经发送过等待响应的packet队列。outgoingQueue为待发送的数据包队列。这里先从<code>outgoingQueue.poll</code>出一个package，准备发送。再调用<code>doWrite(pendingQueue, head, cnxn)</code>放入pendingQueue中，等待server的响应。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> doTransport(<span class="built_in">int</span> waitTimeOut, <span class="built_in">List</span>&lt;Packet&gt; pendingQueue, ClientCnxn cnxn) throws IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!firstConnect.<span class="keyword">await</span>(waitTimeOut, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Packet head = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (needSasl.<span class="keyword">get</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!waitSasl.tryAcquire(waitTimeOut, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//判断outgoingQueue是否存在待发送的数据包，不存在则直接返回</span></span><br><span class="line">                <span class="keyword">if</span> ((head = outgoingQueue.poll(waitTimeOut, TimeUnit.MILLISECONDS)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check if being waken up on closing.</span></span><br><span class="line">            <span class="keyword">if</span> (!sendThread.getZkState().isAlive()) &#123;</span><br><span class="line">                <span class="comment">// adding back the patck to notify of failure in conLossPacket().</span></span><br><span class="line">                addBack(head);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// channel disconnection happened</span></span><br><span class="line">            <span class="keyword">if</span> (disconnected.<span class="keyword">get</span>()) &#123; <span class="comment">//异常流程，channel关闭了，讲当前的packet添加到addBack中</span></span><br><span class="line">                addBack(head);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(<span class="string">"channel for sessionid 0x"</span></span><br><span class="line">                        + Long.toHexString(sessionId)</span><br><span class="line">                        + <span class="string">" is lost"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123; <span class="comment">//如果当前存在需要发送的数据包，则调用doWrite方法，pendingQueue表示处于已经发送过等待响应的packet队列</span></span><br><span class="line">                doWrite(pendingQueue, head, cnxn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            updateNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="DoWrite方法"><a href="#DoWrite方法" class="headerlink" title="DoWrite方法"></a>DoWrite方法</h4><p>将当前的packet添加到pendingQueue队列中</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span>(<span class="params">List&lt;Packet&gt; pendingQueue, Packet p, ClientCnxn cnxn</span>) </span>&#123;</span><br><span class="line">    updateNow();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != WakeupPacket.getInstance()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p.requestHeader != <span class="literal">null</span>) &amp;&amp; <span class="comment">//判断请求头以及判断当前请求类型不是ping或者auth操作</span></span><br><span class="line">                    (p.requestHeader.getType() != ZooDefs.OpCode.ping) &amp;&amp;</span><br><span class="line">                    (p.requestHeader.getType() != ZooDefs.OpCode.auth)) &#123;</span><br><span class="line">                p.requestHeader.setXid(cnxn.getXid());  <span class="comment">//设置xid，这个xid用来区分请求类型</span></span><br><span class="line">                synchronized (pendingQueue) &#123;</span><br><span class="line">                    pendingQueue.<span class="keyword">add</span>(p); <span class="comment">//将当前的packet添加到pendingQueue队列中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sendPkt(p); <span class="comment">//将数据包发送出去</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outgoingQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = outgoingQueue.<span class="keyword">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sendPkt"><a href="#sendPkt" class="headerlink" title="sendPkt"></a>sendPkt</h4><p>通过nio channel发送字节缓存到服务端</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">private</span> <span class="selector-tag">void</span> <span class="selector-tag">sendPkt</span>(Packet p) &#123;</span><br><span class="line">     <span class="comment">// Assuming the packet will be sent out successfully. Because if it fails,</span></span><br><span class="line">     <span class="comment">// the channel will close and clean up queues.</span></span><br><span class="line">     <span class="selector-tag">p</span><span class="selector-class">.createBB</span>(); <span class="comment">//序列化请求数据</span></span><br><span class="line">     <span class="selector-tag">updateLastSend</span>(); <span class="comment">//更新最后一次发送updateLastSend</span></span><br><span class="line">     <span class="selector-tag">sentCount</span>++; <span class="comment">//更新发送次数</span></span><br><span class="line">     <span class="selector-tag">channel</span><span class="selector-class">.write</span>(ChannelBuffers.wrappedBuffer(p.bb)); <span class="comment">//通过nio channel发送字节缓存到服务端</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="createBB"><a href="#createBB" class="headerlink" title="createBB"></a>createBB</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> void createBB() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">ByteArrayOutputStream </span><span class="keyword">baos </span>= new <span class="keyword">ByteArrayOutputStream();</span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">BinaryOutputArchive </span><span class="keyword">boa </span>= <span class="keyword">BinaryOutputArchive.getArchive(baos);</span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">boa.writeInt(-1, </span><span class="string">"len"</span>)<span class="comment">; // We'll fill this in later</span></span><br><span class="line">                <span class="meta">if</span> (requestHeader != null) &#123;</span><br><span class="line">                    requestHeader.serialize(<span class="keyword">boa, </span><span class="string">"header"</span>)<span class="comment">; //序列化header头(requestHeader)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">if</span> (request instanceof ConnectRequest) &#123;</span><br><span class="line">                    request.serialize(<span class="keyword">boa, </span><span class="string">"connect"</span>)<span class="comment">;</span></span><br><span class="line">                    // append <span class="string">"am-I-allowed-to-be-readonly"</span> flag</span><br><span class="line">                    <span class="keyword">boa.writeBool(readOnly, </span><span class="string">"readOnly"</span>)<span class="comment">;</span></span><br><span class="line">                &#125; <span class="meta">else</span> <span class="meta">if</span> (request != null) &#123;</span><br><span class="line">                    request.serialize(<span class="keyword">boa, </span><span class="string">"request"</span>)<span class="comment">; //序列化request(request)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">baos.close();</span></span><br><span class="line"><span class="keyword"> </span>               this.<span class="keyword">bb </span>= <span class="keyword">ByteBuffer.wrap(baos.toByteArray());</span></span><br><span class="line"><span class="keyword"> </span>               this.<span class="keyword">bb.putInt(this.bb.capacity() </span>- <span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">                this.<span class="keyword">bb.rewind();</span></span><br><span class="line"><span class="keyword"> </span>           &#125; catch (IOException e) &#123;</span><br><span class="line">                LOG.warn(<span class="string">"Ignoring unexpected exception"</span>, e)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>从createBB方法中，我们看到在底层实际的网络传输序列化中，zookeeper只会讲requestHeader和request两个属性进行序列化，即只有这两个会被序列化到底层字节数组中去进行网络传输，不会将watchRegistration相关的信息进行网络传输。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用户调用exists注册监听以后，会做几个事情</p>
<ol>
<li><p>讲请求数据封装为packet，添加到outgoingQueue</p>
</li>
<li><p>SendThread这个线程会执行数据发送操作，主要是将outgoingQueue队列中的数据发送到服务端</p>
</li>
<li><p>通过clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this); 其中ClientCnxnSocket只zookeeper客户端和服务端的连接通信的封装，有两个具体的实现类ClientCnxnSocketNetty和ClientCnxnSocketNIO;具体使用哪一个类来实现发送，是在初始化过程是在实例化Zookeeper的时候设置的，代码如下</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cnxn = <span class="keyword">new</span>   <span class="type">ClientCnxn</span>(connectStringParser.getChrootPath(),                   hostProvider, sessionTimeout,   <span class="built_in">this</span>, watchManager,                   getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClientCnxnSocket getClientCnxnSocket() throws IOException &#123;</span><br><span class="line">        <span class="keyword">String</span> clientCnxnSocketName = getClientConfig().getProperty(</span><br><span class="line">                ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);</span><br><span class="line">        <span class="keyword">if</span> (clientCnxnSocketName == <span class="literal">null</span>) &#123;</span><br><span class="line">            clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; clientCxnConstructor = Class.forName(clientCnxnSocketName).getDeclaredConstructor(ZKClientConfig.class);</span><br><span class="line">            ClientCnxnSocket clientCxnSocket = (ClientCnxnSocket) clientCxnConstructor.<span class="keyword">new</span><span class="type">Instance</span>(getClientConfig());</span><br><span class="line">            <span class="keyword">return</span> clientCxnSocket;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            IOException ioe = <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">"Couldn't instantiate "</span></span><br><span class="line">                    + clientCnxnSocketName);</span><br><span class="line">            ioe.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ioe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于第3步，最终会在ClientCnxnSocketNetty方法中执行sendPkt将请求的数据包发送到服务端</p>
</li>
</ol>
<h1 id="服务端接收请求处理流程"><a href="#服务端接收请求处理流程" class="headerlink" title="服务端接收请求处理流程"></a>服务端接收请求处理流程</h1><p>服务端有一个NettyServerCnxn类，用来处理客户端发送过来的请求。</p>
<p>通过<code>zks.processPacket(this, bb)</code>处理客户端传过来的数据包。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public void receiveMessage(ChannelBuffer message) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">while</span>(message.readable() &amp;&amp; !throttled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bb != <span class="built_in">null</span>) &#123; <span class="comment">//ByteBuffer不为空</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">LOG</span>.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(<span class="string">"message readable "</span> + message.readableBytes()</span><br><span class="line">                                + <span class="string">" bb len "</span> + bb.remaining() + <span class="string">" "</span> + bb);</span><br><span class="line">                        ByteBuffer dat = bb.duplicate();</span><br><span class="line">                        dat.flip();</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(Long.toHexString(sessionId)</span><br><span class="line">                                + <span class="string">" bb 0x"</span></span><br><span class="line">                                + ChannelBuffers.hexDump(</span><br><span class="line">                                        ChannelBuffers.copiedBuffer(dat)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//bb剩余空间大于message中可读字节大小</span></span><br><span class="line">                    <span class="keyword">if</span> (bb.remaining() &gt; message.readableBytes()) &#123;</span><br><span class="line">                        int newLimit = bb.position() + message.readableBytes();</span><br><span class="line">                        bb.limit(newLimit);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将message写入bb中</span></span><br><span class="line">                    message.readBytes(bb);</span><br><span class="line">                    bb.limit(bb.capacity());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">LOG</span>.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(<span class="string">"after readBytes message readable "</span></span><br><span class="line">                                + message.readableBytes()</span><br><span class="line">                                + <span class="string">" bb len "</span> + bb.remaining() + <span class="string">" "</span> + bb);</span><br><span class="line">                        ByteBuffer dat = bb.duplicate();</span><br><span class="line">                        dat.flip();</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(<span class="string">"after readbytes "</span></span><br><span class="line">                                + Long.toHexString(sessionId)</span><br><span class="line">                                + <span class="string">" bb 0x"</span></span><br><span class="line">                                + ChannelBuffers.hexDump(</span><br><span class="line">                                        ChannelBuffers.copiedBuffer(dat)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (bb.remaining() == <span class="number">0</span>) &#123; <span class="comment">// 已经读完message，表示内容已经全部接收</span></span><br><span class="line">                        packetReceived(); <span class="comment">// 统计接收信息</span></span><br><span class="line">                        bb.flip();</span><br><span class="line"></span><br><span class="line">                        ZooKeeperServer zks = this.zkServer;</span><br><span class="line">                        <span class="keyword">if</span> (zks == <span class="built_in">null</span> || !zks.isRunning()) &#123;<span class="comment">//Zookeeper服务器为空 ,说明服务端挂了</span></span><br><span class="line">                            throw <span class="keyword">new</span> IOException(<span class="string">"ZK down"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">                            <span class="comment">//处理客户端传过来的数据包</span></span><br><span class="line">                            zks.processPacket(this, bb);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (zks.shouldThrottle(outstandingCount.incrementAndGet())) &#123;</span><br><span class="line">                                disableRecvNoWait();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"got conn req request from "</span></span><br><span class="line">                                    + getRemoteSocketAddress());</span><br><span class="line">                            zks.processConnectRequest(this, bb);</span><br><span class="line">                            initialized = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        bb = <span class="built_in">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//bb为null的情况，大家自己去看，我就不细讲了</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">LOG</span>.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(<span class="string">"message readable "</span></span><br><span class="line">                                + message.readableBytes()</span><br><span class="line">                                + <span class="string">" bblenrem "</span> + bbLen.remaining());</span><br><span class="line">                        ByteBuffer dat = bbLen.duplicate();</span><br><span class="line">                        dat.flip();</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(Long.toHexString(sessionId)</span><br><span class="line">                                + <span class="string">" bbLen 0x"</span></span><br><span class="line">                                + ChannelBuffers.hexDump(</span><br><span class="line">                                        ChannelBuffers.copiedBuffer(dat)));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (message.readableBytes() &lt; bbLen.remaining()) &#123;</span><br><span class="line">                        bbLen.limit(bbLen.position() + message.readableBytes());</span><br><span class="line">                    &#125;</span><br><span class="line">                    message.readBytes(bbLen);</span><br><span class="line">                    bbLen.limit(bbLen.capacity());</span><br><span class="line">                    <span class="keyword">if</span> (bbLen.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">                        bbLen.flip();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">LOG</span>.isTraceEnabled()) &#123;</span><br><span class="line">                            <span class="built_in">LOG</span>.<span class="keyword">trace</span>(Long.toHexString(sessionId)</span><br><span class="line">                                    + <span class="string">" bbLen 0x"</span></span><br><span class="line">                                    + ChannelBuffers.hexDump(</span><br><span class="line">                                            ChannelBuffers.copiedBuffer(bbLen)));</span><br><span class="line">                        &#125;</span><br><span class="line">                        int len = bbLen.getInt();</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">LOG</span>.isTraceEnabled()) &#123;</span><br><span class="line">                            <span class="built_in">LOG</span>.<span class="keyword">trace</span>(Long.toHexString(sessionId)</span><br><span class="line">                                    + <span class="string">" bbLen len is "</span> + len);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        bbLen.<span class="keyword">clear</span>();</span><br><span class="line">                        <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (checkFourLetterWord(channel, message, len)) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (len &lt; <span class="number">0</span> || len &gt; BinaryInputArchive.maxBuffer) &#123;</span><br><span class="line">                            throw <span class="keyword">new</span> IOException(<span class="string">"Len error "</span> + len);</span><br><span class="line">                        &#125;</span><br><span class="line">                        bb = ByteBuffer.allocate(len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(IOException e) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>.warn(<span class="string">"Closing connection to "</span> + getRemoteSocketAddress(), e);</span><br><span class="line">            <span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="NettyServerCnxn"><a href="#NettyServerCnxn" class="headerlink" title="NettyServerCnxn"></a>NettyServerCnxn</h2><h2 id="ZookeeperServer-zks-processPacket-this-bb"><a href="#ZookeeperServer-zks-processPacket-this-bb" class="headerlink" title="ZookeeperServer-zks.processPacket(this, bb);"></a>ZookeeperServer-zks.processPacket(this, bb);</h2><p>处理客户端传送过来的数据包，封装请求对象，并发送。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request si = new Request(<span class="name">cnxn</span>, cnxn.getSessionId(), h.getXid(),</span><br><span class="line">                  h.getType(), incomingBuffer, cnxn.getAuthInfo())<span class="comment">;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">        <span class="comment">// We have the request, now process and setup for next</span></span><br><span class="line">        InputStream bais = <span class="keyword">new</span> ByteBufferInputStream(incomingBuffer);</span><br><span class="line">        BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);</span><br><span class="line">        RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">        h.deserialize(bia, <span class="string">"header"</span>); <span class="comment">//反序列化客户端header头信息</span></span><br><span class="line">        <span class="comment">// Through the magic of byte buffers, txn will not be</span></span><br><span class="line">        <span class="comment">// pointing</span></span><br><span class="line">        <span class="comment">// to the start of the txn</span></span><br><span class="line">        incomingBuffer = incomingBuffer.slice();</span><br><span class="line">        <span class="keyword">if</span> (h.getType() == OpCode.auth) &#123; <span class="comment">//判断当前操作类型，如果是auth操作，则执行下面的代码</span></span><br><span class="line">            <span class="built_in">LOG</span>.info(<span class="string">"got auth packet "</span> + cnxn.getRemoteSocketAddress());</span><br><span class="line">            AuthPacket authPacket = <span class="keyword">new</span> AuthPacket();</span><br><span class="line">            ByteBufferInputStream.byteBuffer2Record(incomingBuffer, authPacket);</span><br><span class="line">            <span class="keyword">String</span> scheme = authPacket.getScheme();</span><br><span class="line">            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);</span><br><span class="line">            <span class="built_in">Code</span> authReturn = KeeperException.<span class="built_in">Code</span>.AUTHFAILED;</span><br><span class="line">            <span class="keyword">if</span>(ap != <span class="built_in">null</span>) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    authReturn = ap.handleAuthentication(<span class="keyword">new</span> ServerAuthenticationProvider.ServerObjs(this, cnxn), authPacket.getAuth());</span><br><span class="line">                &#125; catch(RuntimeException e) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.warn(<span class="string">"Caught runtime exception from AuthenticationProvider: "</span> + scheme + <span class="string">" due to "</span> + e);</span><br><span class="line">                    authReturn = KeeperException.<span class="built_in">Code</span>.AUTHFAILED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (authReturn == KeeperException.<span class="built_in">Code</span>.OK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Authentication succeeded for scheme: "</span> + scheme);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">LOG</span>.info(<span class="string">"auth success "</span> + cnxn.getRemoteSocketAddress());</span><br><span class="line">                ReplyHeader rh = <span class="keyword">new</span> ReplyHeader(h.getXid(), <span class="number">0</span>,</span><br><span class="line">                        KeeperException.<span class="built_in">Code</span>.OK.intValue());</span><br><span class="line">                cnxn.sendResponse(rh, <span class="built_in">null</span>, <span class="built_in">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ap == <span class="built_in">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.warn(<span class="string">"No authentication provider for scheme: "</span></span><br><span class="line">                            + scheme + <span class="string">" has "</span></span><br><span class="line">                            + ProviderRegistry.listProviders());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.warn(<span class="string">"Authentication failed for scheme: "</span> + scheme);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// send a response...</span></span><br><span class="line">                ReplyHeader rh = <span class="keyword">new</span> ReplyHeader(h.getXid(), <span class="number">0</span>,</span><br><span class="line">                        KeeperException.<span class="built_in">Code</span>.AUTHFAILED.intValue());</span><br><span class="line">                cnxn.sendResponse(rh, <span class="built_in">null</span>, <span class="built_in">null</span>);</span><br><span class="line">                <span class="comment">// ... and close connection</span></span><br><span class="line">                cnxn.sendBuffer(ServerCnxnFactory.closeConn);</span><br><span class="line">                cnxn.disableRecv();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不是授权操作，再判断是否为sasl操作</span></span><br><span class="line">            <span class="keyword">if</span> (h.getType() == OpCode.sasl) &#123;</span><br><span class="line">                Record rsp = processSasl(incomingBuffer,cnxn);</span><br><span class="line">                ReplyHeader rh = <span class="keyword">new</span> ReplyHeader(h.getXid(), <span class="number">0</span>, KeeperException.<span class="built_in">Code</span>.OK.intValue());</span><br><span class="line">                cnxn.sendResponse(rh,rsp, <span class="string">"response"</span>); <span class="comment">// not sure about 3rd arg..what is it?</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//最终进入这个代码块进行处理</span></span><br><span class="line">                <span class="comment">//封装请求对象</span></span><br><span class="line">                Request si = <span class="keyword">new</span> Request(cnxn, cnxn.getSessionId(), h.getXid(),</span><br><span class="line">                  h.getType(), incomingBuffer, cnxn.getAuthInfo());</span><br><span class="line">                si.setOwner(ServerCnxn.me);</span><br><span class="line">                <span class="comment">// Always treat packet from the client as a possible</span></span><br><span class="line">                <span class="comment">// local request.</span></span><br><span class="line">                setLocalSessionFlag(si);</span><br><span class="line">                submitRequest(si); <span class="comment">//提交请求</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnxn.incrOutstandingRequests(h);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="submitRequest"><a href="#submitRequest" class="headerlink" title="submitRequest"></a>submitRequest</h2><p>负责在服务端提交当前请求</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">(Request si)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span>) &#123; <span class="comment">//processor处理器，request过来以后会经历一系列处理器的处理过程</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Since all requests are passed to the request</span></span><br><span class="line">                    <span class="comment">// processor it should wait for setting up the request</span></span><br><span class="line">                    <span class="comment">// processor chain. The state will be updated to RUNNING</span></span><br><span class="line">                    <span class="comment">// after the setup.</span></span><br><span class="line">                    <span class="keyword">while</span> (state == State.INITIAL) &#123;</span><br><span class="line">                        wait(<span class="number">1000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">"Unexpected interruption"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span> || state != State.RUNNING) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not started"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            touch(si.cnxn);</span><br><span class="line">            <span class="keyword">boolean</span> validpacket = Request.isValid(si.type); <span class="comment">//判断是否合法</span></span><br><span class="line">            <span class="keyword">if</span> (validpacket) &#123;</span><br><span class="line">                firstProcessor.processRequest(si);  调用firstProcessor发起请求，而这个firstProcess是一个接口，有多个实现类，具体的调用链是怎么样的？往下看吧</span><br><span class="line">                <span class="keyword">if</span> (si.cnxn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    incInProcess();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG.warn(<span class="string">"Received packet at server of unknown type "</span> + si.type);</span><br><span class="line">                <span class="keyword">new</span> UnimplementedRequestProcessor().processRequest(si);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MissingSessionException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                LOG.debug(<span class="string">"Dropping request: "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</span><br><span class="line">            LOG.<span class="keyword">error</span>(<span class="string">"Unable to process request:"</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="firstProcessor的请求链组成"><a href="#firstProcessor的请求链组成" class="headerlink" title="firstProcessor的请求链组成"></a>firstProcessor的请求链组成</h3><ol>
<li>firstProcessor的初始化是在ZookeeperServer的setupRequestProcessor中完成的，代码如下</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</span><br><span class="line">        RequestProcessor syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>, finalProcessor);</span><br><span class="line">        ((SyncRequestProcessor)syncProcessor).start();</span><br><span class="line">        firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, syncProcessor);<span class="comment">//需要注意的是，PrepRequestProcessor中传递的是一个syncProcessor</span></span><br><span class="line">        ((PrepRequestProcessor)firstProcessor).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看到firstProcessor的实例是一个PrepRequestProcessor，而这个构造方法中又传递了一个Processor构成了一个调用链。</p>
<p>RequestProcessor syncProcessor = new SyncRequestProcessor(this, finalProcessor);</p>
<p>而syncProcessor的构造方法传递的又是一个Processor，对应的是FinalRequestProcessor</p>
<ol>
<li>所以整个调用链是PrepRequestProcessor -&gt; SyncRequestProcessor -&gt;FinalRequestProcessor</li>
</ol>
<h2 id="PredRequestProcessor-processRequest-si"><a href="#PredRequestProcessor-processRequest-si" class="headerlink" title="PredRequestProcessor.processRequest(si);"></a>PredRequestProcessor.processRequest(si);</h2><p>通过上面了解到调用链关系以后，我们继续再看firstProcessor.processRequest(si)； 会调用到PrepRequestProcessor</p>
<p>唉，很奇怪，processRequest只是把request添加到submittedRequests中，根据前面的经验，很自然的想到这里又是一个异步操作。而subittedRequests又是一个阻塞队列</p>
<p><code>LinkedBlockingQueue&lt;Request&gt; submittedRequests = new LinkedBlockingQueue&lt;Request&gt;();</code></p>
<p>而PrepRequestProcessor这个类又继承了线程类，因此我们直接找到当前类中的<code>run</code>方法如下</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Request request = submittedRequests.take(); <span class="comment">//ok，从队列中拿到请求进行处理</span></span><br><span class="line">                <span class="keyword">long</span> traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">                <span class="keyword">if</span> (request.type == OpCode.ping) &#123;</span><br><span class="line">                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                    ZooTrace.logRequest(LOG, traceMask, <span class="string">'P'</span>, request, <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Request.requestOfDeath == request) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pRequest(request); <span class="comment">//调用pRequest进行预处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> XidRolloverException) &#123;</span><br><span class="line">                LOG.info(e.getCause().getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            handleException(<span class="keyword">this</span>.getName(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            handleException(<span class="keyword">this</span>.getName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">"PrepRequestProcessor exited loop!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="pRequest"><a href="#pRequest" class="headerlink" title="pRequest"></a>pRequest</h3><p>预处理这块的代码太长，就不好贴了。前面的N行代码都是根据当前的OP类型进行判断和做相应的处理，在这个方法中的最后一行中，我们会看到如下代码</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextProcessor.processRequest(request)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>很显然，nextProcessor对应的应该是SyncRequestProcessor</p>
<h2 id="SyncRequestProcessor-processRequest"><a href="#SyncRequestProcessor-processRequest" class="headerlink" title="SyncRequestProcessor. processRequest"></a>SyncRequestProcessor. processRequest</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span>(<span class="params">Request request</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// request.addRQRec("&gt;sync");</span></span><br><span class="line">        queuedRequests.<span class="keyword">add</span>(request);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 这个方法的代码也是一样，基于异步化的操作，把请求添加到queuedRequets中，那么我们继续在当前类找到run方法</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> logCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we do this in an attempt to ensure that not all of the servers</span></span><br><span class="line">            <span class="comment">// in the ensemble take a snapshot at the same time</span></span><br><span class="line">            <span class="built_in">int</span> randRoll = r.nextInt(snapCount/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Request si = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//从阻塞队列中获取请求</span></span><br><span class="line">                <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</span><br><span class="line">                    si = queuedRequests.take();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    si = queuedRequests.poll();</span><br><span class="line">                    <span class="keyword">if</span> (si == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        flush(toFlush);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (si == requestOfDeath) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// track the number of records written to the log</span></span><br><span class="line">                    <span class="comment">//下面这块代码，粗略看来是触发快照操作，启动一个处理快照的线程</span></span><br><span class="line">                    <span class="keyword">if</span> (zks.getZKDatabase().<span class="built_in">append</span>(si)) &#123;</span><br><span class="line">                        logCount++;</span><br><span class="line">                        <span class="keyword">if</span> (logCount &gt; (snapCount / <span class="number">2</span> + randRoll)) &#123;</span><br><span class="line">                            randRoll = r.nextInt(snapCount/<span class="number">2</span>);</span><br><span class="line">                            <span class="comment">// roll the log</span></span><br><span class="line">                            zks.getZKDatabase().rollLog();</span><br><span class="line">                            <span class="comment">// take a snapshot</span></span><br><span class="line">                            <span class="keyword">if</span> (snapInProcess != <span class="keyword">null</span> &amp;&amp; snapInProcess.isAlive()) &#123;</span><br><span class="line">                                LOG.warn(<span class="string">"Too busy to snap, skipping"</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                snapInProcess = <span class="keyword">new</span> ZooKeeperThread(<span class="string">"Snapshot Thread"</span>) &#123;</span><br><span class="line">                                        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                                zks.takeSnapshot();</span><br><span class="line">                                            &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                                                LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;;</span><br><span class="line">                                snapInProcess.start();</span><br><span class="line">                            &#125;</span><br><span class="line">                            logCount = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// optimization for read heavy workloads</span></span><br><span class="line">                        <span class="comment">// iff this is a read, and there are no pending</span></span><br><span class="line">                        <span class="comment">// flushes (writes), then just pass this to the next</span></span><br><span class="line">                        <span class="comment">// processor</span></span><br><span class="line">                        <span class="keyword">if</span> (nextProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            nextProcessor.processRequest(si); <span class="comment">//继续调用下一个处理器来处理请求</span></span><br><span class="line">                            <span class="keyword">if</span> (nextProcessor <span class="keyword">instanceof</span> Flushable) &#123;</span><br><span class="line">                                ((Flushable)nextProcessor).flush();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    toFlush.<span class="built_in">add</span>(si);</span><br><span class="line">                    <span class="keyword">if</span> (toFlush.<span class="built_in">size</span>() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                        flush(toFlush);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleException(<span class="keyword">this</span>.getName(), t);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">"SyncRequestProcessor exited!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="FinalRequestProcessor-processRequest"><a href="#FinalRequestProcessor-processRequest" class="headerlink" title="FinalRequestProcessor. processRequest"></a>FinalRequestProcessor. processRequest</h2><p>这个方法就是我们在课堂上分析到的方法了，FinalRequestProcessor.processRequest方法并根据Request对象中的操作更新内存中Session信息或者znode数据。</p>
<p>这块代码有小300多行，就不全部贴出来了，我们直接定位到关键代码，根据客户端的OP类型找到如下的代码</p>
 <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">case</span> OpCode.exists: <span class="type"></span>&#123;</span><br><span class="line">                lastOp = <span class="string">"EXIS"</span>;</span><br><span class="line">                <span class="comment">// TODO we need to figure out the security requirement for this!</span></span><br><span class="line">                ExistsRequest existsRequest = <span class="keyword">new</span> <span class="type">ExistsRequest</span>();</span><br><span class="line">                <span class="comment">//反序列化  (将ByteBuffer反序列化成为ExitsRequest.这个就是我们在客户端发起请求的时候传递过来的Request对象</span></span><br><span class="line">                ByteBufferInputStream.byteBuffer2Record(request.request,</span><br><span class="line">                        existsRequest);</span><br><span class="line">                <span class="keyword">String</span> path = existsRequest.getPath(); <span class="comment">//得到请求的路径</span></span><br><span class="line">                <span class="keyword">if</span> (path.indexOf(<span class="string">'\0'</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KeeperException</span>.BadArgumentsException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//终于找到一个很关键的代码，判断请求的getWatch是否存在，如果存在，则传递cnxn（servercnxn）</span></span><br><span class="line"><span class="comment">//对于exists请求，需要监听data变化事件，添加watcher</span></span><br><span class="line">                Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : <span class="type">null</span>);</span><br><span class="line">                rsp = <span class="keyword">new</span> <span class="type">ExistsResponse</span>(stat); <span class="comment">//在服务端内存数据库中根据路径得到结果进行组装，设置为ExistsResponse</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h2 id="statNode这个方法做了什么？"><a href="#statNode这个方法做了什么？" class="headerlink" title="statNode这个方法做了什么？"></a>statNode这个方法做了什么？</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stat statNode(String path, ServerCnxn serverCnxn) <span class="keyword">throws</span> KeeperException.NoNodeException &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> dataTree.<span class="title">statNode</span><span class="params">(path, serverCnxn)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一路向下，在下面这个方法中，讲ServerCnxn向上转型为Watcher了。 因为ServerCnxn实现了Watcher接口</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stat statNode(<span class="keyword">String</span> path, Watcher watcher)</span><br><span class="line">            throws KeeperException.NoNodeException &#123;</span><br><span class="line">        Stat stat = <span class="keyword">new</span> <span class="type">Stat</span>();</span><br><span class="line">        DataNode n = nodes.<span class="keyword">get</span>(path); <span class="comment">//获得节点数据</span></span><br><span class="line">        <span class="keyword">if</span> (watcher != <span class="literal">null</span>) &#123; <span class="comment">//如果watcher不为空，则讲当前的watcher和path进行绑定</span></span><br><span class="line">            dataWatches.addWatch(path, watcher);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KeeperException</span>.NoNodeException();</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (n) &#123;</span><br><span class="line">            n.copyStat(stat);</span><br><span class="line">            <span class="keyword">return</span> stat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="WatchManager-addWatch-path-watcher"><a href="#WatchManager-addWatch-path-watcher" class="headerlink" title="WatchManager.addWatch(path, watcher);"></a>WatchManager.addWatch(path, watcher);</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">synchronized <span class="literal">void</span> addWatch(<span class="built_in">String</span> path, Watcher watcher) &#123;</span><br><span class="line">        HashSet&lt;Watcher&gt; <span class="built_in">list</span> = watchTable.get(path);  <span class="comment">//判断watcherTable中是否存在当前路径对应的watcher</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="built_in">null</span>) &#123; <span class="comment">//不存在则主动添加</span></span><br><span class="line">            <span class="comment">// don't waste memory if there are few watches on a node</span></span><br><span class="line">            <span class="comment">// rehash when the 4th entry is added, doubling size thereafter</span></span><br><span class="line">            <span class="comment">// seems like a good compromise</span></span><br><span class="line">            <span class="built_in">list</span> = <span class="literal">new</span> HashSet&lt;Watcher&gt;(<span class="number">4</span>); <span class="comment">// 新生成watcher集合</span></span><br><span class="line">            watchTable.put(path, <span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>.add(watcher); <span class="comment">//添加到watcher表</span></span><br><span class="line"></span><br><span class="line">        HashSet&lt;<span class="built_in">String</span>&gt; paths = watch2Paths.get(watcher);</span><br><span class="line">        <span class="keyword">if</span> (paths == <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="comment">// cnxns typically have many watches, so use default cap here</span></span><br><span class="line">            paths = <span class="literal">new</span> HashSet&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">            watch2Paths.put(watcher, paths); <span class="comment">// 设置watcher到节点路径的映射</span></span><br><span class="line">        &#125;</span><br><span class="line">        paths.add(path);  <span class="comment">// 将路径添加至paths集合</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其大致流程如下</p>
<p>　　① 通过传入的path（节点路径）从watchTable获取相应的watcher集合，进入②</p>
<p>　　② 判断①中的watcher是否为空，若为空，则进入③，否则，进入④</p>
<p>　　③ 新生成watcher集合，并将路径path和此集合添加至watchTable中，进入④</p>
<p>　　④ 将传入的watcher添加至watcher集合，即完成了path和watcher添加至watchTable的步骤，进入⑤</p>
<p>　　⑤ 通过传入的watcher从watch2Paths中获取相应的path集合，进入⑥</p>
<p>　　⑥ 判断path集合是否为空，若为空，则进入⑦，否则，进入⑧</p>
<p>　　⑦ 新生成path集合，并将watcher和paths添加至watch2Paths中，进入⑧</p>
<p>　　⑧ 将传入的path（节点路径）添加至path集合，即完成了path和watcher添加至watch2Paths的步骤</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>调用关系链如下</p>
<p>NettyServerCnxn(processPackage) -&gt; ZookeeperServer(processRequest) -&gt; PredRequestProcessor(processRequest) -&gt; SyncRequestProcessor(processRequest) -&gt; FinalRequestProcessor(processRequest) -&gt; ZKDataBase (statNode)-&gt; DataTree(statNode) -&gt;  WatchManager(addWatch)</p>
<h1 id="客户端接收服务端处理完成的响应"><a href="#客户端接收服务端处理完成的响应" class="headerlink" title="客户端接收服务端处理完成的响应"></a>客户端接收服务端处理完成的响应</h1><h2 id="ClientCnxnSocketNetty-messageReceived"><a href="#ClientCnxnSocketNetty-messageReceived" class="headerlink" title="ClientCnxnSocketNetty.messageReceived"></a>ClientCnxnSocketNetty.messageReceived</h2><p>服务端处理完成以后，会通过NettyServerCnxn.sendResponse发送返回的响应信息，</p>
<p>客户端会在ClientCnxnSocketNetty.messageReceived接收服务端的返回</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void messageReceived(ChannelHandlerContext ctx,</span><br><span class="line">                                    MessageEvent e) throws Exception &#123;</span><br><span class="line">            updateNow()<span class="comment">;</span></span><br><span class="line">            ChannelBuffer <span class="keyword">buf </span>= (ChannelBuffer) e.getMessage()<span class="comment">;</span></span><br><span class="line">            while (<span class="keyword">buf.readable()) </span>&#123;</span><br><span class="line">                if (incomingBuffer.remaining() &gt; <span class="keyword">buf.readableBytes()) </span>&#123;</span><br><span class="line">                    int newLimit = incomingBuffer.position()</span><br><span class="line">                            + <span class="keyword">buf.readableBytes();</span></span><br><span class="line"><span class="keyword"> </span>                   incomingBuffer.limit(newLimit)<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">buf.readBytes(incomingBuffer);</span></span><br><span class="line"><span class="keyword"> </span>               incomingBuffer.limit(incomingBuffer.capacity())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">                if (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">                    incomingBuffer.flip()<span class="comment">;</span></span><br><span class="line">                    if (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">                        recvCount++<span class="comment">;</span></span><br><span class="line">                        readLength()<span class="comment">;</span></span><br><span class="line">                    &#125; else if (!initialized) &#123;</span><br><span class="line">                        readConnectResult()<span class="comment">;</span></span><br><span class="line">                        lenBuffer.clear()<span class="comment">;</span></span><br><span class="line">                        incomingBuffer = lenBuffer<span class="comment">;</span></span><br><span class="line">                        initialized = true<span class="comment">;</span></span><br><span class="line">                        updateLastHeard()<span class="comment">;</span></span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        sendThread.readResponse(incomingBuffer)<span class="comment">; //收到消息以后触发SendThread.readResponse方法</span></span><br><span class="line">                        lenBuffer.clear()<span class="comment">;</span></span><br><span class="line">                        incomingBuffer = lenBuffer<span class="comment">;</span></span><br><span class="line">                        updateLastHeard()<span class="comment">;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            wakeupCnxn()<span class="comment">;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="SendThread-readResponse"><a href="#SendThread-readResponse" class="headerlink" title="SendThread. readResponse"></a>SendThread. readResponse</h2><p>这个方法里面主要的流程如下</p>
<p>首先读取header，如果其xid == -2，表明是一个ping的response，return</p>
<p>如果xid是 -4 ，表明是一个AuthPacket的response return</p>
<p>如果xid是 -1，表明是一个notification,此时要继续读取并构造一个enent，通过EventThread.queueEvent发送，return</p>
<p>其它情况下：</p>
<p>从pendingQueue拿出一个Packet，校验后更新packet信息</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">void readResponse(ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">            ByteBufferInputStream bbis = <span class="keyword">new</span> ByteBufferInputStream(</span><br><span class="line">                    incomingBuffer);</span><br><span class="line">            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">            ReplyHeader replyHdr = <span class="keyword">new</span> ReplyHeader();</span><br><span class="line"></span><br><span class="line">            replyHdr.deserialize(bbia, <span class="string">"header"</span>); <span class="comment">//反序列化header</span></span><br><span class="line">            <span class="keyword">if</span> (replyHdr.getXid() == <span class="number">-2</span>) &#123; <span class="comment">//?</span></span><br><span class="line">                <span class="comment">// -2 is the xid for pings</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Got ping response for sessionid: 0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId)</span><br><span class="line">                            + <span class="string">" after "</span></span><br><span class="line">                            + ((<span class="keyword">System</span>.nanoTime() - lastPingSentNs) / <span class="number">1000000</span>)</span><br><span class="line">                            + <span class="string">"ms"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (replyHdr.getXid() == <span class="number">-4</span>) &#123;</span><br><span class="line">                <span class="comment">// -4 is the xid for AuthPacket</span></span><br><span class="line">                <span class="keyword">if</span>(replyHdr.getErr() == KeeperException.<span class="built_in">Code</span>.AUTHFAILED.intValue()) &#123;</span><br><span class="line">                    state = States.AUTH_FAILED;</span><br><span class="line">                    eventThread.queueEvent( <span class="keyword">new</span> WatchedEvent(Watcher.Event.EventType.None,</span><br><span class="line">                            Watcher.Event.KeeperState.AuthFailed, <span class="built_in">null</span>) );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Got auth sessionid:0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (replyHdr.getXid() == <span class="number">-1</span>) &#123; <span class="comment">//表示当前的消息类型为一个notification(意味着是服务端的一个响应事件)</span></span><br><span class="line">                <span class="comment">// -1 means notification</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Got notification sessionid:0x"</span></span><br><span class="line">                        + Long.toHexString(sessionId));</span><br><span class="line">                &#125;</span><br><span class="line">                WatcherEvent event = <span class="keyword">new</span> WatcherEvent();<span class="comment">//?</span></span><br><span class="line">                event.deserialize(bbia, <span class="string">"response"</span>);  <span class="comment">//反序列化响应信息</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// convert from a server path to a client path</span></span><br><span class="line">                <span class="keyword">if</span> (chrootPath != <span class="built_in">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">String</span> serverPath = event.<span class="built_in">getPath</span>();</span><br><span class="line">                    <span class="keyword">if</span>(serverPath.compareTo(chrootPath)==<span class="number">0</span>)</span><br><span class="line">                        event.setPath(<span class="string">"/"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                        event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                    	<span class="built_in">LOG</span>.warn(<span class="string">"Got server path "</span> + event.<span class="built_in">getPath</span>()</span><br><span class="line">                    			+ <span class="string">" which is too short for chroot path "</span></span><br><span class="line">                    			+ chrootPath);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                WatchedEvent we = <span class="keyword">new</span> WatchedEvent(event);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Got "</span> + we + <span class="string">" for sessionid 0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                eventThread.queueEvent( we );</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If SASL authentication is currently in progress, construct and</span></span><br><span class="line">            <span class="comment">// send a response packet immediately, rather than queuing a</span></span><br><span class="line">            <span class="comment">// response as with other packets.</span></span><br><span class="line">            <span class="keyword">if</span> (tunnelAuthInProgress()) &#123;</span><br><span class="line">                GetSASLRequest request = <span class="keyword">new</span> GetSASLRequest();</span><br><span class="line">                request.deserialize(bbia,<span class="string">"token"</span>);</span><br><span class="line">                zooKeeperSaslClient.respondToServer(request.getToken(),</span><br><span class="line">                  ClientCnxn.this);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Packet packet;</span><br><span class="line">            synchronized (pendingQueue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pendingQueue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    throw <span class="keyword">new</span> IOException(<span class="string">"Nothing in the queue, but got "</span></span><br><span class="line">                            + replyHdr.getXid());</span><br><span class="line">                &#125;</span><br><span class="line">                packet = pendingQueue.remove(); <span class="comment">//因为当前这个数据包已经收到了响应，所以讲它从pendingQueued中移除</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Since requests are processed in order, we better get a response</span></span><br><span class="line"><span class="comment">             * to the first request!</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            try &#123;<span class="comment">//校验数据包信息，校验成功后讲数据包信息进行更新（替换为服务端的信息）</span></span><br><span class="line">                <span class="keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</span><br><span class="line">                    packet.replyHeader.setErr(</span><br><span class="line">                            KeeperException.<span class="built_in">Code</span>.CONNECTIONLOSS.intValue());</span><br><span class="line">                    throw <span class="keyword">new</span> IOException(<span class="string">"Xid out of order. Got Xid "</span></span><br><span class="line">                            + replyHdr.getXid() + <span class="string">" with err "</span> +</span><br><span class="line">                            + replyHdr.getErr() +</span><br><span class="line">                            <span class="string">" expected Xid "</span></span><br><span class="line">                            + packet.requestHeader.getXid()</span><br><span class="line">                            + <span class="string">" for a packet with details: "</span></span><br><span class="line">                            + packet );</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                packet.replyHeader.setXid(replyHdr.getXid());</span><br><span class="line">                packet.replyHeader.setErr(replyHdr.getErr());</span><br><span class="line">                packet.replyHeader.setZxid(replyHdr.getZxid());</span><br><span class="line">                <span class="keyword">if</span> (replyHdr.getZxid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    lastZxid = replyHdr.getZxid();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (packet.response != <span class="built_in">null</span> &amp;&amp; replyHdr.getErr() == <span class="number">0</span>) &#123;</span><br><span class="line">                    packet.response.deserialize(bbia, <span class="string">"response"</span>); <span class="comment">//获得服务端的响应，反序列化以后设置到packet.response属性中。所以我们可以在exists方法的最后一行通过packet.response拿到改请求的返回结果</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Reading reply sessionid:0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId) + <span class="string">", packet:: "</span> + packet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                finishPacket(packet); <span class="comment">//最后调用finishPacket方法完成处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="finishPacket方法"><a href="#finishPacket方法" class="headerlink" title="finishPacket方法"></a>finishPacket方法</h2><p>主要功能是把从 Packet 中取出对应的 Watcher 并注册到 ZKWatchManager 中去</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> finishPacket(Packet p) &#123;</span><br><span class="line">        <span class="built_in">int</span> err = p.replyHeader.getErr();</span><br><span class="line">        <span class="keyword">if</span> (p.watchRegistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.watchRegistration.register(err);   <span class="comment">//将事件注册到zkwatchemanager中</span></span><br><span class="line">watchRegistration，熟悉吗？在组装请求的时候，我们初始化了这个对象</span><br><span class="line">把watchRegistration 子类里面的 Watcher 实例放到 ZKWatchManager 的 existsWatches 中存储起来。</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将所有移除的监视事件添加到事件队列, 这样客户端能收到 “data/child 事件被移除”的事件类型</span></span><br><span class="line">        <span class="keyword">if</span> (p.watchDeregistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="built_in">Map</span>&lt;EventType, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; materializedWatchers = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                materializedWatchers = p.watchDeregistration.unregister(err);</span><br><span class="line">                <span class="keyword">for</span> (Entry&lt;EventType, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; entry : materializedWatchers.entrySet()) &#123;</span><br><span class="line">                    <span class="built_in">Set</span>&lt;Watcher&gt; watchers = entry.getValue();</span><br><span class="line">                    <span class="keyword">if</span> (watchers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        queueEvent(p.watchDeregistration.getClientPath(), err,</span><br><span class="line">                                watchers, entry.getKey());</span><br><span class="line">                        <span class="comment">// ignore connectionloss when removing from local</span></span><br><span class="line">                        <span class="comment">// session</span></span><br><span class="line">                        p.replyHeader.setErr(Code.OK.intValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException.NoWatcherException nwe) &#123;</span><br><span class="line">                p.replyHeader.setErr(nwe.code().intValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException ke) &#123;</span><br><span class="line">                p.replyHeader.setErr(ke.code().intValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cb就是AsnycCallback，如果为null，表明是同步调用的接口，不需要异步回掉，因此，直接notifyAll即可。</span></span><br><span class="line">        <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            synchronized (p) &#123;</span><br><span class="line">                p.finished = <span class="keyword">true</span>;</span><br><span class="line">                p.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.finished = <span class="keyword">true</span>;</span><br><span class="line">            eventThread.queuePacket(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="watchRegistration"><a href="#watchRegistration" class="headerlink" title="watchRegistration"></a>watchRegistration</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> register(<span class="built_in">int</span> rc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldAddWatch(rc)) &#123;</span><br><span class="line">                <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; watches = getWatches(rc); <span class="comment">// //通过子类的实现取得ZKWatchManager 中的 existsWatches</span></span><br><span class="line">                synchronized(watches) &#123;</span><br><span class="line">                    <span class="built_in">Set</span>&lt;Watcher&gt; watchers = watches.<span class="keyword">get</span>(clientPath);</span><br><span class="line">                    <span class="keyword">if</span> (watchers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        watchers = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line">                        watches.put(clientPath, watchers);</span><br><span class="line">                    &#125;</span><br><span class="line">                    watchers.add(watcher); <span class="comment">//将 Watcher 对象放到 ZKWatchManager 中的 existsWatches里面</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p> 下面这段代码是客户端存储watcher的几个map集合，分别对应三种注册监听事件</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatchManager</span> <span class="keyword">implements</span> <span class="title">ClientWatchManager</span> </span>&#123;</span><br><span class="line">        private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; dataWatches =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt;();</span><br><span class="line">        private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; existWatches =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt;();</span><br><span class="line">        private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; childWatches =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>总的来说，当使用ZooKeeper 构造方法或者使用 getData、exists 和 getChildren 三个接口来向 ZooKeeper 服务器注册 Watcher 的时候，首先将此消息传递给服务端，传递成功后，服务端会通知客户端，然后客户端将该路径和Watcher对应关系存储起来备用。</p>
<h3 id="EventThread-queuePacket"><a href="#EventThread-queuePacket" class="headerlink" title="EventThread.queuePacket()"></a>EventThread.queuePacket()</h3><p>finishPacket方法最终会调用eventThread.queuePacket， 讲当前的数据包添加到等待事件通知的队列中</p>
 <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">queuePacket</span><span class="params">(Packet packet)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (wasKilled) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (waitingEvents) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRunning) waitingEvents.add(packet);</span><br><span class="line">                <span class="function"><span class="keyword">else</span> <span class="title">processEvent</span><span class="params">(packet)</span></span>;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             waitingEvents.add(packet);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h1 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h1><p>前面这么长的说明，只是为了清洗的说明事件的注册流程，最终的触发，还得需要通过事务型操作来完成</p>
<p>在我们最开始的案例中，通过如下代码去完成了事件的触发</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.setData(“/mic”, “<span class="number">1</span>”.getByte(),<span class="number">-1</span>) ; <span class="comment">//修改节点的值触发监听</span></span><br></pre></td></tr></table></figure>
<p>前面的客户端和服务端对接的流程就不再重复讲解了，交互流程是一样的，唯一的差别在于事件触发了</p>
<h2 id="服务端的事件响应DataTree-setData"><a href="#服务端的事件响应DataTree-setData" class="headerlink" title="服务端的事件响应DataTree.setData()"></a>服务端的事件响应DataTree.setData()</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stat setData(<span class="keyword">String</span> path, <span class="built_in">byte</span> data[], <span class="built_in">int</span> version, <span class="keyword">long</span> zxid,</span><br><span class="line">            <span class="keyword">long</span> time) <span class="keyword">throws</span> KeeperException.NoNodeException &#123;</span><br><span class="line">        Stat s = <span class="keyword">new</span> Stat();</span><br><span class="line">        DataNode n = nodes.<span class="built_in">get</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">byte</span> lastdata[] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (n) &#123;</span><br><span class="line">            lastdata = n.data;</span><br><span class="line">            n.data = data;</span><br><span class="line">            n.stat.setMtime(time);</span><br><span class="line">            n.stat.setMzxid(zxid);</span><br><span class="line">            n.stat.setVersion(version);</span><br><span class="line">            n.copyStat(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// now update if the path is in a quota subtree.</span></span><br><span class="line">        <span class="keyword">String</span> lastPrefix = getMaxPrefixWithQuota(path);</span><br><span class="line">        <span class="keyword">if</span>(lastPrefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.updateBytes(lastPrefix, (data == <span class="keyword">null</span> ? <span class="number">0</span> : data.length)</span><br><span class="line">              - (lastdata == <span class="keyword">null</span> ? <span class="number">0</span> : lastdata.length));</span><br><span class="line">        &#125;</span><br><span class="line">        dataWatches.triggerWatch(path, EventType.NodeDataChanged); <span class="comment">//触发对应节点的NodeDataChanged事件</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="WatcherManager-triggerWatch"><a href="#WatcherManager-triggerWatch" class="headerlink" title="WatcherManager. triggerWatch"></a>WatcherManager. triggerWatch</h3> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>&lt;Watcher&gt; triggerWatch(<span class="built_in">String</span> path, EventType type, <span class="built_in">Set</span>&lt;Watcher&gt; supress) &#123;</span><br><span class="line">        WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type, KeeperState.SyncConnected, path); <span class="comment">//  根据事件类型、连接状态、节点路径创建WatchedEvent</span></span><br><span class="line">        HashSet&lt;Watcher&gt; watchers;</span><br><span class="line">        synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">            watchers = watchTable.remove(path); <span class="comment">// 从watcher表中移除path，并返回其对应的watcher集合</span></span><br><span class="line">            <span class="keyword">if</span> (watchers == <span class="keyword">null</span> || watchers.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                    ZooTrace.logTraceMessage(LOG,</span><br><span class="line">                            ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                            <span class="string">"No watchers for "</span> + path);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Watcher w : watchers) &#123; <span class="comment">// 遍历watcher集合</span></span><br><span class="line">                HashSet&lt;<span class="built_in">String</span>&gt; paths = watch2Paths.<span class="keyword">get</span>(w); <span class="comment">// 根据watcher从watcher表中取出路径集合</span></span><br><span class="line">                <span class="keyword">if</span> (paths != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    paths.remove(path); <span class="comment">//移除路径</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Watcher w : watchers) &#123; <span class="comment">// 遍历watcher集合</span></span><br><span class="line">            <span class="keyword">if</span> (supress != <span class="keyword">null</span> &amp;&amp; supress.contains(w)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            w.process(e); <span class="comment">//OK，重点又来了，w.process是做什么呢？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> watchers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="w-process-e"><a href="#w-process-e" class="headerlink" title="w.process(e);"></a>w.process(e);</h3><p>还记得我们在服务端绑定事件的时候，watcher绑定是是什么？是ServerCnxn， 所以w.process(e)，其实调用的应该是ServerCnxn的process方法。而servercnxn又是一个抽象方法，有两个实现类，分别是：NIOServerCnxn和NettyServerCnxn。那接下来我们扒开NettyServerCnxn这个类的process方法看看究竟</p>
 <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span>(<span class="params">WatchedEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">        ReplyHeader h = <span class="keyword">new</span> ReplyHeader(<span class="number">-1</span>, <span class="number">-1</span>L, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                                     <span class="string">"Deliver event "</span> + <span class="keyword">event</span> + <span class="string">" to 0x"</span></span><br><span class="line">                                     + Long.toHexString(<span class="keyword">this</span>.sessionId)</span><br><span class="line">                                     + <span class="string">" through "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert WatchedEvent to a type that can be sent over the wire</span></span><br><span class="line">        WatcherEvent e = <span class="keyword">event</span>.getWrapper();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendResponse(h, e, <span class="string">"notification"</span>);  <span class="comment">//look， 这个地方发送了一个事件，事件对象为WatcherEvent。完美</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                LOG.debug(<span class="string">"Problem sending to "</span> + getRemoteSocketAddress(), e1);</span><br><span class="line">            &#125;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那接下里，客户端会收到这个response，触发SendThread.readResponse方法</p>
<h2 id="客户端处理事件响应"><a href="#客户端处理事件响应" class="headerlink" title="客户端处理事件响应"></a>客户端处理事件响应</h2><h3 id="SendThread-readResponse-1"><a href="#SendThread-readResponse-1" class="headerlink" title="SendThread.readResponse"></a>SendThread.readResponse</h3><p>这块代码上面已经贴过了，所以我们只挑选当前流程的代码进行讲解，按照前面我们将到过的，notifacation通知消息的xid为-1，意味着~直接找到-1的判断进行分析<br>在下面代码标红处.</p>
<h3 id="eventThread-queueEvent"><a href="#eventThread-queueEvent" class="headerlink" title="eventThread.queueEvent"></a>eventThread.queueEvent</h3><p>  SendThread 接收到服务端的通知事件后，会通过调用 EventThread 类的 queueEvent 方法将事件传给 EventThread 线程，queueEvent 方法根据该通知事件，从 ZKWatchManager 中取出所有相关的 Watcher，如果获取到相应的Watcher，就会让Watcher移除失效。</p>
<h3 id="Meterialize方法"><a href="#Meterialize方法" class="headerlink" title="Meterialize方法"></a>Meterialize方法</h3><p>通过dataWatches或者existWatches或者childWatches的remove取出对应的watch，表明客户端watch也是注册一次就移除<br>同时需要根据keeperState、eventType和path返回应该被通知的Watcher集合</p>
<h3 id="waitingEvents-add"><a href="#waitingEvents-add" class="headerlink" title="waitingEvents.add"></a>waitingEvents.add</h3><p>最后一步，接近真相了<br>waitingEvents是EventThread这个线程中的阻塞队列，很明显，又是在我们第一步操作的时候实例化的一个线程。<br>从名字可以指导，waitingEvents 是一个待处理 Watcher 的队列，EventThread 的 run() 方法会不断从队列中取数据，交由 processEvent 方法处理：</p>
<h3 id="ProcessEvent"><a href="#ProcessEvent" class="headerlink" title="ProcessEvent"></a>ProcessEvent</h3><p>由于这块的代码太长，我只把核心的代码贴出来，这里就是处理事件触发的核心代</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouxiaowu.coding.me/2018/06/09/zookeeper学习笔记_05_原生API的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/09/zookeeper学习笔记_05_原生API的使用/" itemprop="url">zookeeper原生API使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-09T09:49:41+08:00">
                2018-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/09/zookeeper学习笔记_05_原生API的使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/09/zookeeper学习笔记_05_原生API的使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h3><h4 id="1-1、jar包"><a href="#1-1、jar包" class="headerlink" title="1.1、jar包"></a>1.1、jar包</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2、准备工作"><a href="#1-2、准备工作" class="headerlink" title="1.2、准备工作"></a>1.2、准备工作</h4><p>本人使用的是VMware + CentOS7环境，即虚拟机，这里需要将zookeeper客户端访问接口对外暴露。<br><br>参考：<a href="https://blog.csdn.net/u011846257/article/details/54707864" target="_blank" rel="external">Centos防火墙设置与端口开放的方法</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在指定区域打开端口</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent    // 永久生效</span><br><span class="line"></span><br><span class="line">// 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p>
<h3 id="2、创建连接、创建节点、修改节点、删除节点"><a href="#2、创建连接、创建节点、修改节点、删除节点" class="headerlink" title="2、创建连接、创建节点、修改节点、删除节点"></a>2、创建连接、创建节点、修改节点、删除节点</h3><h4 id="2-1、创建连接"><a href="#2-1、创建连接" class="headerlink" title="2.1、创建连接"></a>2.1、创建连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">boolean</span> canBeReadOnly)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher, <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd, <span class="keyword">boolean</span> canBeReadOnly)</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">connectString</td>
<td style="text-align:left">Zookeeper服务器的地址和端口号<code>ip:port</code>。集群环境使用逗号隔开。</td>
</tr>
<tr>
<td style="text-align:left">sessionTimeout</td>
<td style="text-align:left">超时时间，超过一定时间不在连接</td>
</tr>
<tr>
<td style="text-align:left">watcher</td>
<td style="text-align:left">监听事件</td>
</tr>
<tr>
<td style="text-align:left">canBeReadOnly</td>
<td style="text-align:left">表示当前new的对象只能执行读操作，不能执行写操作。默认：false</td>
</tr>
<tr>
<td style="text-align:left">sessionId</td>
<td style="text-align:left">因Zookeeper的重连机制，即断开连接后，在一定时间内可再次连接，保持同一个会话。<br><code>zookeeper.getSessionId()</code>可以在断开连接前获取sessionId</td>
</tr>
<tr>
<td style="text-align:left">sessionPasswd</td>
<td style="text-align:left">因Zookeeper的重连机制，即断开连接后，在一定时间内可再次连接，保持同一个会话。<br><code>zookeeper.getSessionPasswd()</code>sessionPasswd</td>
</tr>
</tbody>
</table>
<p>参考：<a href="https://blog.csdn.net/andy2019/article/details/73065449" target="_blank" rel="external">Zookeeper实例原生API–复用sessionId和sessionPasswd</a></p>
<h4 id="2-2、创建节点"><a href="#2-2、创建节点" class="headerlink" title="2.2、创建节点"></a>2.2、创建节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">create</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode,  StringCallback cb, Object ctx)</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">path</td>
<td style="text-align:left">被创建节点的路径</td>
</tr>
<tr>
<td style="text-align:left">data</td>
<td style="text-align:left">被创建节点的值</td>
</tr>
<tr>
<td style="text-align:left">acl</td>
<td style="text-align:left">acl策略。详见<a href="zookeeper学习笔记_04_客户端的使用.md">zookeeper客户端的使用</a>的1.6章节</td>
</tr>
<tr>
<td style="text-align:left">createMode</td>
<td style="text-align:left">节点类型，临时或者持久，有序节点等。详见<a href="zookeeper学习笔记_04_客户端的使用.md">zookeeper客户端的使用</a>的1.2、1.3章节</td>
</tr>
<tr>
<td style="text-align:left">cb</td>
<td style="text-align:left">异步创建方法参数。注册的回调函数，需实现StringCallback接口。数据节点创建完成之后，会调用此方法进行业务逻辑处理。主要针对<code>public void processResult(int rc, String path, Object ctx, String name)</code>接口进行重写。<br>参考：<a href="https://blog.csdn.net/wo541075754/article/details/65625481" target="_blank" rel="external">Zookeeper客户端API之创建节点（七）</a></td>
</tr>
<tr>
<td style="text-align:left">ctx</td>
<td style="text-align:left">异步创建方法参数。用户传递一个对象，可以在回调方法执行时使用</td>
</tr>
</tbody>
</table>
<ul>
<li><b>临时节点下不能创建子节点</b><br></li>
<li><b>因为是原生API，故不能在没有父节点的前提下直接创建子节点</b><br></li>
</ul>
<h5 id="2-2-1、关于StringCallback"><a href="#2-2-1、关于StringCallback" class="headerlink" title="2.2.1、关于StringCallback"></a>2.2.1、关于StringCallback</h5><p>转自：<a href="https://blog.csdn.net/wo541075754/article/details/65625481" target="_blank" rel="external">Zookeeper客户端API之创建节点（七）</a></p>
<p><code>StringCallback</code>接口继承了<code>AsyncCallback</code>接口，来实现回调时的业务处理。<br><br>其中<code>AsyncCallback</code>接口还包8个回调接口：<code>StatCallback</code>、<code>DataCallback</code>、<code>ACLCallback</code>、<code>ChildrenCallback</code>、<code>Children2Callback</code>、<code>VoidCallback</code>、<code>MultiCallback</code>、<code>StringCallback</code>。可以在不同的异步接口中实现不同的回调接口。</p>
<p><code>StringCallback</code>接口的<code>public void processResult(int rc, String path, Object ctx, String name)</code>方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">rc</td>
<td style="text-align:left">服务器的响应码，即<code>Event.KeeperState</code>，0表示调用成功，-4表示连接已断开，-110表示指定节点已存在，-112表示会话已过期。</td>
</tr>
<tr>
<td style="text-align:left">path</td>
<td style="text-align:left">调用create方法时传入的path。</td>
</tr>
<tr>
<td style="text-align:left">ctx</td>
<td style="text-align:left">调用create方法时传入的ctx。</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">创建成功的节点名称。</td>
</tr>
</tbody>
</table>
<h4 id="2-3、修改节点"><a href="#2-3、修改节点" class="headerlink" title="2.3、修改节点"></a>2.3、修改节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stat <span class="title">setData</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version, StatCallback cb, Object ctx)</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">path</td>
<td style="text-align:left">被修改节点的路径</td>
</tr>
<tr>
<td style="text-align:left">data</td>
<td style="text-align:left">被修改节点的新值</td>
</tr>
<tr>
<td style="text-align:left">version</td>
<td style="text-align:left">代表节点的版本号，如果该值与zookeeper服务器此节点的dataVersion属性值不相同，则修改失败。 <code>-1</code>代表忽略版本号的作用，强制修改！</td>
</tr>
<tr>
<td style="text-align:left">cb</td>
<td style="text-align:left">异步创建方法参数。注册的回调函数，需实现StatCallback接口。数据节点创建完成之后，会调用此方法进行业务逻辑处理。</td>
</tr>
<tr>
<td style="text-align:left">ctx</td>
<td style="text-align:left">异步创建方法参数。用户传递一个对象，可以在回调方法执行时使用</td>
</tr>
<tr>
<td style="text-align:left">返回值Stat</td>
<td style="text-align:left">描述一个节点的信息，具体可以查看<a href="zookeeper学习笔记_04_客户端的使用.md">zookeeper客户端的使用</a>的章节2</td>
</tr>
</tbody>
</table>
<ul>
<li>关于<code>StatCallback</code>，与<code>StringCallback</code>类似。<ul>
<li>实现的方法是<code>public void processResult(int rc, String path, Object ctx, Stat stat)</code></li>
</ul>
</li>
</ul>
<h4 id="2-4、删除节点"><a href="#2-4、删除节点" class="headerlink" title="2.4、删除节点"></a>2.4、删除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">int</span> version)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">int</span> version, VoidCallback cb, Object ctx)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>与修改节点<code>setData</code>方法类似。</li>
<li><b>因为是原始API，不允许删除存在子节点的节点</b></li>
</ul>
<h4 id="2-5、Demo"><a href="#2-5、Demo" class="headerlink" title="2.5、Demo"></a>2.5、Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiZookeeper</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 集群环境用,隔开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONNECTSTRING = <span class="string">"192.168.27.128:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zookeeper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        connect();</span><br><span class="line">        createNode(<span class="string">"/xych"</span>, <span class="string">"xych"</span>);</span><br><span class="line">        <span class="comment">// createNode("/xych1/lanboo","lanboo"); // 报错</span></span><br><span class="line">        setNode(<span class="string">"/xych"</span>, <span class="string">"XYCH"</span>, -<span class="number">1</span>);</span><br><span class="line">        deleteNode(<span class="string">"/xych"</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(String nodePath, <span class="keyword">int</span> version)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        zookeeper.delete(nodePath, version);</span><br><span class="line">        System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setNode</span><span class="params">(String nodePath, String value, <span class="keyword">int</span> version)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stat stat = zookeeper.setData(nodePath, value.getBytes(), version);</span><br><span class="line">        System.out.println(<span class="string">"修改成功 "</span> + stat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(String nodePath, String value)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String result = zookeeper.create(nodePath, value.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        System.out.println(<span class="string">"创建成功 "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 使用CountDownLatch，使主线程等待</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        zookeeper = <span class="keyword">new</span> ZooKeeper(CONNECTSTRING, <span class="number">10000</span>, <span class="keyword">new</span> Watcher()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(event.getState() == Event.KeeperState.SyncConnected)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Watcher "</span> + zookeeper.getState());</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"connect "</span> + zookeeper.getState());</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"connect "</span> + zookeeper.getState());</span><br><span class="line">        <span class="comment">// zookeeper.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">connect CONNECTING</span></span><br><span class="line"><span class="comment">Watcher CONNECTED</span></span><br><span class="line"><span class="comment">connect CONNECTED</span></span><br><span class="line"><span class="comment">创建成功 /xych</span></span><br><span class="line"><span class="comment">修改成功 46,47,1524152856857,1524152856864,1,0,0,72057600313458694,4,0,46</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">删除成功</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="3、exists、getData、getChildren"><a href="#3、exists、getData、getChildren" class="headerlink" title="3、exists、getData、getChildren"></a>3、exists、getData、getChildren</h3><h4 id="3-1、exists"><a href="#3-1、exists" class="headerlink" title="3.1、exists"></a>3.1、exists</h4><blockquote>
<p>判断某节点是否存在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stat <span class="title">exists</span><span class="params">(String path, <span class="keyword">boolean</span> watch)</span></span></span><br><span class="line"><span class="function">Stat <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exists</span><span class="params">(String path, <span class="keyword">boolean</span> watch, StatCallback cb, Object ctx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, StatCallback cb, Object ctx)</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">path</td>
<td style="text-align:left">被判断节点的路径</td>
</tr>
<tr>
<td style="text-align:left">watch</td>
<td style="text-align:left">是否添加一个默认Watcher</td>
</tr>
<tr>
<td style="text-align:left">watcher</td>
<td style="text-align:left">监听事件</td>
</tr>
<tr>
<td style="text-align:left">cb</td>
<td style="text-align:left">异步创建方法参数。注册的回调函数，需实现StatCallback接口。数据节点创建完成之后，会调用此方法进行业务逻辑处理。</td>
</tr>
<tr>
<td style="text-align:left">ctx</td>
<td style="text-align:left">异步创建方法参数。用户传递一个对象，可以在回调方法执行时使用</td>
</tr>
</tbody>
</table>
<p>关于<code>StatCallback</code>可以参考本文2.2.1。</p>
<h4 id="3-2、getData"><a href="#3-2、getData" class="headerlink" title="3.2、getData"></a>3.2、getData</h4><blockquote>
<p>获取节点内容，同步获取和异步获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getData(String path, <span class="keyword">boolean</span> watch, Stat stat)</span><br><span class="line"><span class="keyword">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">(String path, <span class="keyword">boolean</span> watch, DataCallback cb, Object ctx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, DataCallback cb, Object ctx)</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">path</td>
<td style="text-align:left">节点的路径</td>
</tr>
<tr>
<td style="text-align:left">watch</td>
<td style="text-align:left">是否注册一个默认Watcher</td>
</tr>
<tr>
<td style="text-align:left">watcher</td>
<td style="text-align:left">监听事件</td>
</tr>
<tr>
<td style="text-align:left">cb</td>
<td style="text-align:left">异步创建方法参数。注册的回调函数，需实现DataCallback接口。数据节点创建完成之后，会调用此方法进行业务逻辑处理。</td>
</tr>
<tr>
<td style="text-align:left">ctx</td>
<td style="text-align:left">异步创建方法参数。用户传递一个对象，可以在回调方法执行时使用</td>
</tr>
</tbody>
</table>
<p>关于<code>DataCallback</code>可以参考本文2.2.1。</p>
<h4 id="3-3、getChildren"><a href="#3-3、getChildren" class="headerlink" title="3.3、getChildren"></a>3.3、getChildren</h4><blockquote>
<p>获取子节点列表，同步获取和异步获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watch)</span></span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watch, Stat stat)</span></span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watch, ChildrenCallback cb, Object ctx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(String path, <span class="keyword">boolean</span> watch, Children2Callback cb, Object ctx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, ChildrenCallback cb, Object ctx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, Children2Callback cb, Object ctx)</span></span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">path</td>
<td style="text-align:left">节点的路径</td>
</tr>
<tr>
<td style="text-align:left">watch</td>
<td style="text-align:left">是否注册一个默认Watcher</td>
</tr>
<tr>
<td style="text-align:left">watcher</td>
<td style="text-align:left">监听事件</td>
</tr>
<tr>
<td style="text-align:left">stat</td>
<td style="text-align:left">描述一个节点的信息<br>会将path指定的节点的信息更新<br>具体可以查看<a href="zookeeper学习笔记_04_客户端的使用.md">zookeeper客户端的使用</a>的章节2</td>
</tr>
<tr>
<td style="text-align:left">cb</td>
<td style="text-align:left">异步创建方法参数。注册的回调函数，需实现ChildrenCallback、Children2Callback接口。数据节点创建完成之后，会调用此方法进行业务逻辑处理。</td>
</tr>
<tr>
<td style="text-align:left">ctx</td>
<td style="text-align:left">异步创建方法参数。用户传递一个对象，可以在回调方法执行时使用</td>
</tr>
</tbody>
</table>
<p>关于<code>ChildrenCallback</code>、<code>Children2Callback</code>可以参考本文2.2.1。</p>
<h3 id="4、Watcher事件监控"><a href="#4、Watcher事件监控" class="headerlink" title="4、Watcher事件监控"></a>4、Watcher事件监控</h3><ul>
<li><b>Watcher是一次性的，用完就会失效</b><br></li>
</ul>
<p>转自：<a href="https://www.cnblogs.com/programlearning/archive/2017/05/10/6834963.html" target="_blank" rel="external">ZooKeeper监听机制</a></p>
<h4 id="4-1、事件类型"><a href="#4-1、事件类型" class="headerlink" title="4.1、事件类型"></a>4.1、事件类型</h4><table>
<thead>
<tr>
<th style="text-align:left">事件类型</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">EventType.None</td>
<td style="text-align:left">与服务器建立连接时触发</td>
</tr>
<tr>
<td style="text-align:left">EventType.NodeCreated</td>
<td style="text-align:left">被监控的节点被创建触发</td>
</tr>
<tr>
<td style="text-align:left">EventType.NodeDeleted</td>
<td style="text-align:left">被监控的节点被删除触发</td>
</tr>
<tr>
<td style="text-align:left">EventType.NodeDataChanged</td>
<td style="text-align:left">被监控的节点被修改触发</td>
</tr>
<tr>
<td style="text-align:left">EventType.NodeChildrenChanged</td>
<td style="text-align:left">被监控的节点的子节点<b>数量</b>发生改变时触发</td>
</tr>
</tbody>
</table>
<h4 id="4-2、读操作绑定事件"><a href="#4-2、读操作绑定事件" class="headerlink" title="4.2、读操作绑定事件"></a>4.2、读操作绑定事件</h4><table>
<thead>
<tr>
<th style="text-align:left">读操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">new ZooKeeper</td>
<td style="text-align:left">不会指定某节点，故触发类型为<code>EventType.None</code></td>
</tr>
<tr>
<td style="text-align:left">exists</td>
<td style="text-align:left">判断某节点是否存在，同时对该节点添加Watcher</td>
</tr>
<tr>
<td style="text-align:left">getData</td>
<td style="text-align:left">获取某节点的值，同时对该节点添加Watcher</td>
</tr>
<tr>
<td style="text-align:left">getChildren</td>
<td style="text-align:left">获取某节点的子节点列表，同时对该节点添加Watcher</td>
</tr>
</tbody>
</table>
<h4 id="4-3、写操作触发事件"><a href="#4-3、写操作触发事件" class="headerlink" title="4.3、写操作触发事件"></a>4.3、写操作触发事件</h4><table>
<thead>
<tr>
<th style="text-align:left">写操作</th>
<th style="text-align:left">Event For “/path”</th>
<th style="text-align:left">Event For “/path/child”</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">create(“/path”)</td>
<td style="text-align:left">EventType.NodeCreated</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">delete(“/path”)</td>
<td style="text-align:left">EventType.NodeDeleted</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">setData(“/path”)</td>
<td style="text-align:left">EventType.NodeDataChanged</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">create(“/path/child”)</td>
<td style="text-align:left">EventType.NodeChildrenChanged</td>
<td style="text-align:left">EventType.NodeCreated</td>
</tr>
<tr>
<td style="text-align:left">delete(“/path/child”)</td>
<td style="text-align:left">EventType.NodeChildrenChanged</td>
<td style="text-align:left">EventType.NodeDeleted</td>
</tr>
<tr>
<td style="text-align:left">setData(“/path/child”)</td>
<td style="text-align:left">-</td>
<td style="text-align:left">EventType.NodeDataChanged</td>
</tr>
</tbody>
</table>
<h4 id="4-4、写操作触发-读操作绑定的事件"><a href="#4-4、写操作触发-读操作绑定的事件" class="headerlink" title="4.4、写操作触发[读操作绑定的事件]"></a>4.4、写操作触发[读操作绑定的事件]</h4><table><br>    <tr><br>        <td></td><br>        <td colspan="3">“/path”</td><br>        <td colspan="3">“/path/child”</td><br>    </tr><br>    <tr><br>        <td>写操作所触发的绑定事件</td><br>        <td>exists</td><br>        <td>getData</td><br>        <td>getChildren</td><br>        <td>exists</td><br>        <td>getData</td><br>        <td>getChildren</td><br>    </tr><br>    <tr><br>        <td>create(“/path”)</td><br>        <td>√</td><br>        <td>√</td><br>        <td></td><br>        <td></td><br>        <td></td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>delete(“/path”)</td><br>        <td>√</td><br>        <td>√</td><br>        <td>√</td><br>        <td></td><br>        <td></td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>setData(“/path”)</td><br>        <td>√</td><br>        <td>√</td><br>        <td></td><br>        <td></td><br>        <td></td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>create(“/path/child”)</td><br>        <td></td><br>        <td></td><br>        <td>√</td><br>        <td>√</td><br>        <td>√</td><br>        <td></td><br>    </tr><br>    <tr><br>        <td>delete(“/path/child”)</td><br>        <td></td><br>        <td></td><br>        <td>√</td><br>        <td>√</td><br>        <td>√</td><br>        <td>√</td><br>    </tr><br>    <tr><br>        <td>setData(“/path/child”)</td><br>        <td></td><br>        <td></td><br>        <td></td><br>        <td>√</td><br>        <td>√</td><br>        <td></td><br>    </tr><br></table>

<blockquote>
<ul>
<li><code>create(&quot;/path/child&quot;)</code>和<code>delete(&quot;/path/child&quot;)</code><b>只会触发</b><code>getChildren</code>对<code>&quot;/path&quot;</code>的绑定事件；<br></li>
<li>不会触发<code>exists</code>、<code>getData</code>对<code>&quot;/path&quot;</code>的绑定事件。<br></li>
</ul>
</blockquote>
<h4 id="4-4、Demo"><a href="#4-4、Demo" class="headerlink" title="4.4、Demo"></a>4.4、Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiZookeeperWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 集群环境用,隔开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONNECTSTRING = <span class="string">"192.168.27.131:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zookeeper;</span><br><span class="line">    <span class="comment">// 使用CountDownLatch，使主线程等待</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        connect();</span><br><span class="line">        createWatcher(<span class="string">"/xych"</span>, <span class="string">"xych"</span>);</span><br><span class="line">        setDataWatcher(<span class="string">"/xych"</span>, <span class="string">"XYCH"</span>);</span><br><span class="line">        deleteWatcher(<span class="string">"/xych"</span>);</span><br><span class="line">        <span class="comment">// 这里"/xych"已被删除，再次创建。（此时"/xych"没有任何Watcher）</span></span><br><span class="line">        <span class="comment">// 注意：临时节点下不能创建节点</span></span><br><span class="line">        <span class="keyword">if</span>(zookeeper.exists(<span class="string">"/xych1"</span>, <span class="keyword">false</span>) == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            zookeeper.create(<span class="string">"/xych1"</span>, <span class="string">"xych"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        createWatcher_Children(<span class="string">"/xych1"</span>, <span class="string">"/lanboo"</span>, <span class="string">"lanboo"</span>);</span><br><span class="line">        setDataWatcher_Children(<span class="string">"/xych1"</span>, <span class="string">"/lanboo"</span>, <span class="string">"LANBOO"</span>);</span><br><span class="line">        deleteWatcher_Children(<span class="string">"/xych1"</span>, <span class="string">"/lanboo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteWatcher_Children</span><span class="params">(String path, String children)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 利用getChildren，对父节点添加Watcher</span></span><br><span class="line">        List&lt;String&gt; pathChildren = zookeeper.getChildren(path, <span class="keyword">new</span> ApiZookeeperWatcher());</span><br><span class="line">        System.out.println(<span class="string">"deleteWatcher_Children："</span> + path + <span class="string">"的子节点："</span> + pathChildren);</span><br><span class="line">        <span class="comment">// 利用exists，对子节点添加Watcher</span></span><br><span class="line">        Stat childrenStat = zookeeper.exists(path + children, <span class="keyword">new</span> ApiZookeeperWatcher());</span><br><span class="line">        <span class="keyword">if</span>(pathChildren != <span class="keyword">null</span> &amp;&amp; childrenStat != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            zookeeper.delete(path + children, -<span class="number">1</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataWatcher_Children</span><span class="params">(String path, String children, String value)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 利用getChildren，对父节点添加Watcher</span></span><br><span class="line">        List&lt;String&gt; pathChildren = zookeeper.getChildren(path, <span class="keyword">new</span> ApiZookeeperWatcher());</span><br><span class="line">        System.out.println(<span class="string">"setDataWatcher_Children："</span> + path + <span class="string">"的子节点："</span> + pathChildren);</span><br><span class="line">        <span class="comment">// 利用exists，对子节点添加Watcher</span></span><br><span class="line">        Stat childrenStat = zookeeper.exists(path + children, <span class="keyword">new</span> ApiZookeeperWatcher());</span><br><span class="line">        <span class="keyword">if</span>(pathChildren != <span class="keyword">null</span> &amp;&amp; childrenStat != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            zookeeper.setData(path + children, value.getBytes(), -<span class="number">1</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对某节点添加Warcher，对该节点添加子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createWatcher_Children</span><span class="params">(String path, String children, String value)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 利用getChildren，对父节点添加Watcher</span></span><br><span class="line">        List&lt;String&gt; pathChildren = zookeeper.getChildren(path, <span class="keyword">new</span> ApiZookeeperWatcher());</span><br><span class="line">        System.out.println(<span class="string">"createWatcher_Children："</span> + path + <span class="string">"的子节点："</span> + pathChildren);</span><br><span class="line">        <span class="comment">// 利用exists，对子节点添加Watcher</span></span><br><span class="line">        Stat childrenStat = zookeeper.exists(path + children, <span class="keyword">new</span> ApiZookeeperWatcher());</span><br><span class="line">        <span class="keyword">if</span>(pathChildren != <span class="keyword">null</span> &amp;&amp; childrenStat == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            zookeeper.create(path + children, value.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对setData监控</span></span><br><span class="line"><span class="comment">     * 做法：</span></span><br><span class="line"><span class="comment">     * 1、利用exists，判断某节点是否存在，同时对该节点添加一个Watcher</span></span><br><span class="line"><span class="comment">     * 2、删除该节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteWatcher</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 判断"/xych"节点是否存在，并且对此节点添加一个Watcher</span></span><br><span class="line">        Stat stat = zookeeper.exists(path, <span class="keyword">new</span> ApiZookeeperWatcher());</span><br><span class="line">        System.out.println(<span class="string">"deleteWatcher："</span> + path + <span class="string">"的节点属性："</span> + stat);</span><br><span class="line">        <span class="keyword">if</span>(stat != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            zookeeper.delete(path, -<span class="number">1</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对setData监控</span></span><br><span class="line"><span class="comment">     * 做法：</span></span><br><span class="line"><span class="comment">     * 1、利用getData，获取某节点的value，同时对该节点添加一个Watcher</span></span><br><span class="line"><span class="comment">     * 2、创建该节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataWatcher</span><span class="params">(String path, String value)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = zookeeper.getData(path, <span class="keyword">new</span> ApiZookeeperWatcher(), stat);</span><br><span class="line">        System.out.println(<span class="string">"setDataWatcher："</span> + path + <span class="string">"的原始值 = "</span> + <span class="keyword">new</span> String(bytes));</span><br><span class="line">        System.out.println(<span class="string">"setDataWatcher："</span> + path + <span class="string">"的节点信息 = "</span> + stat);</span><br><span class="line">        zookeeper.setData(path, value.getBytes(), -<span class="number">1</span>);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对create监控</span></span><br><span class="line"><span class="comment">     * 做法：</span></span><br><span class="line"><span class="comment">     * 1、利用exists，判断某节点是否存在，同时对该节点添加一个Watcher</span></span><br><span class="line"><span class="comment">     * 2、创建该节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createWatcher</span><span class="params">(String path, String value)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 判断path节点是否存在，并且对此节点添加一个Watcher</span></span><br><span class="line">        Stat stat = zookeeper.exists(path, <span class="keyword">new</span> ApiZookeeperWatcher());</span><br><span class="line">        System.out.println(<span class="string">"createWatcher："</span> + path + <span class="string">"的节点属性："</span> + stat);</span><br><span class="line">        <span class="keyword">if</span>(stat == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            zookeeper.create(path, value.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        zookeeper = <span class="keyword">new</span> ZooKeeper(CONNECTSTRING, <span class="number">10000</span>, <span class="keyword">new</span> ApiZookeeperWatcher());</span><br><span class="line">        System.out.println(<span class="string">"connect "</span> + zookeeper.getState());</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"connect "</span> + zookeeper.getState());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 只在连接成功的情况下，进行事件监听</span></span><br><span class="line">        <span class="keyword">if</span>(watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Event.EventType.None == watchedEvent.getType())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Watcher："</span> + watchedEvent.getState() + <span class="string">"--&gt;"</span> + watchedEvent.getType());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(Event.EventType.NodeCreated == watchedEvent.getType())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Watcher："</span> + watchedEvent.getPath() + <span class="string">"被创建"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(Event.EventType.NodeDeleted == watchedEvent.getType())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Watcher："</span> + watchedEvent.getPath() + <span class="string">"被删除"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(Event.EventType.NodeDataChanged == watchedEvent.getType())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Watcher："</span> + watchedEvent.getPath() + <span class="string">"被修改"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(Event.EventType.NodeChildrenChanged == watchedEvent.getType())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Watcher："</span> + watchedEvent.getPath() + <span class="string">"的子节点数量发生改变"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Watcher："</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">connect CONNECTING</span><br><span class="line">Watcher：SyncConnected--&gt;None</span><br><span class="line">Watcher：com.xych.zookeeper.api.ApiZookeeperWatcher@<span class="number">7</span>b23ec81</span><br><span class="line">connect CONNECTED</span><br><span class="line"></span><br><span class="line">createWatcher：/xych的节点属性：<span class="keyword">null</span></span><br><span class="line">Watcher：/xych被创建</span><br><span class="line">Watcher：com.xych.zookeeper.api.ApiZookeeperWatcher@<span class="number">1</span>a7d63bd</span><br><span class="line"></span><br><span class="line">setDataWatcher：/xych的原始值 = xych</span><br><span class="line">setDataWatcher：/xych的节点信息 = <span class="number">165</span>,<span class="number">165</span>,<span class="number">1524221468877</span>,<span class="number">1524221468877</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">72057600313458724</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">165</span></span><br><span class="line"></span><br><span class="line">Watcher：/xych被修改</span><br><span class="line">Watcher：com.xych.zookeeper.api.ApiZookeeperWatcher@<span class="number">7</span>aa0aa6f</span><br><span class="line"></span><br><span class="line">deleteWatcher：/xych的节点属性：<span class="number">165</span>,<span class="number">166</span>,<span class="number">1524221468877</span>,<span class="number">1524221468884</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">72057600313458724</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">165</span></span><br><span class="line"></span><br><span class="line">Watcher：/xych被删除</span><br><span class="line">Watcher：com.xych.zookeeper.api.ApiZookeeperWatcher<span class="meta">@bb</span>15e0d</span><br><span class="line"></span><br><span class="line">createWatcher_Children：/xych1的子节点：[]</span><br><span class="line">Watcher：/xych1/lanboo被创建</span><br><span class="line">Watcher：com.xych.zookeeper.api.ApiZookeeperWatcher@<span class="number">2</span>cce4a9a</span><br><span class="line">Watcher：/xych1的子节点数量发生改变</span><br><span class="line">Watcher：com.xych.zookeeper.api.ApiZookeeperWatcher@<span class="number">2</span>d8e2810</span><br><span class="line"></span><br><span class="line">setDataWatcher_Children：/xych1的子节点：[lanboo]</span><br><span class="line">Watcher：/xych1/lanboo被修改</span><br><span class="line">Watcher：com.xych.zookeeper.api.ApiZookeeperWatcher@<span class="number">7333</span>dbfe</span><br><span class="line"></span><br><span class="line">deleteWatcher_Children：/xych1的子节点：[lanboo]</span><br><span class="line">Watcher：/xych1/lanboo被删除</span><br><span class="line">Watcher：com.xych.zookeeper.api.ApiZookeeperWatcher@<span class="number">7165</span>a6c4</span><br><span class="line">Watcher：/xych1的子节点数量发生改变</span><br><span class="line">Watcher：com.xych.zookeeper.api.ApiZookeeperWatcher@<span class="number">2f</span>21b320</span><br><span class="line">Watcher：/xych1的子节点数量发生改变</span><br><span class="line">Watcher：com.xych.zookeeper.api.ApiZookeeperWatcher@<span class="number">31</span>ecabd5</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouxiaowu.coding.me/2018/05/29/大型跨境电商JVM调优经历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/29/大型跨境电商JVM调优经历/" itemprop="url">大型跨境电商JVM调优经历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-29T09:49:41+08:00">
                2018-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/调优/" itemprop="url" rel="index">
                    <span itemprop="name">调优</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/29/大型跨境电商JVM调优经历/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/05/29/大型跨境电商JVM调优经历/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>引用自 <a href="https://juejin.im/post/5b091ee35188253892389683?utm_source=gold_browser_extension" target="_blank" rel="external">https://juejin.im/post/5b091ee35188253892389683?utm_source=gold_browser_extension</a></p>
</blockquote>
<p>前提：<br>某大型跨境电商业务发展非常快，线上机器扩容也很频繁，但是对于线上机器的运行情况，特别是jvm内存的情况，一直没有一个统一的标准来给到各个应用服务的owner。经过618大促之后，和运维的同学讨论了下，希望将线上服务器的jvm参数标准化，可以以一个统一的方式给到各个应用，提升线上服务器的稳定性，同时减少大家都去调整jvm参数的时间。<br>参考了之前在淘宝天猫工作的公司的经历：经过大家讨论，根据jdk的版本以及线上机器配置，确定了一个推荐的默认jvm模版：<br>最终推荐的jvm模版：<br>jdk版本 机器配置 建议jvm参数 备注</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdk1<span class="number">.7</span> <span class="number">6</span>V8G -server -Xms4g -Xmx4g -Xmn2g -Xss768k -<span class="string">XX:</span>PermSize=<span class="number">512</span>m -<span class="string">XX:</span>MaxPermSize=<span class="number">512</span>m -<span class="string">XX:</span>+UseConcMarkSweepGC -<span class="string">XX:</span>+UseParNewGC -<span class="string">XX:</span>+CMSClassUnloadingEnabled -<span class="string">XX:</span>+DisableExplicitGC -<span class="string">XX:</span>+UseCMSInitiatingOccupancyOnly -<span class="string">XX:</span>CMSInitiatingOccupancyFraction=<span class="number">68</span> -<span class="string">verbose:</span>gc -<span class="string">XX:</span>+PrintGCDetails -<span class="string">Xloggc:</span>&#123;CATALINA_BASE&#125;<span class="regexp">/logs/</span>gc.log -<span class="string">XX:</span>+PrintGCDateStamps -<span class="string">XX:</span>+HeapDumpOnOutOfMemoryError -<span class="string">XX:</span>HeapDumpPath=&#123;CATALINA_BASE&#125;/logs 前台</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdk1<span class="number">.7</span> <span class="number">8</span>V8G -server -Xms4g -Xmx4g -Xmn2g -Xss768k -<span class="string">XX:</span>PermSize=<span class="number">512</span>m -<span class="string">XX:</span>MaxPermSize=<span class="number">512</span>m -<span class="string">XX:</span>+UseConcMarkSweepGC -<span class="string">XX:</span>+UseParNewGC -<span class="string">XX:</span>+CMSClassUnloadingEnabled -<span class="string">XX:</span>+DisableExplicitGC -<span class="string">XX:</span>+UseCMSInitiatingOccupancyOnly -<span class="string">XX:</span>CMSInitiatingOccupancyFraction=<span class="number">68</span> -<span class="string">verbose:</span>gc -<span class="string">XX:</span>+PrintGCDetails -<span class="string">Xloggc:</span>&#123;CATALINA_BASE&#125;<span class="regexp">/logs/</span>gc.log -<span class="string">XX:</span>+PrintGCDateStamps -<span class="string">XX:</span>+HeapDumpOnOutOfMemoryError -<span class="string">XX:</span>HeapDumpPath=&#123;CATALINA_BASE&#125;/logs 前台</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdk1<span class="number">.7</span> <span class="number">4</span>V8G -server -Xms4g -Xmx4g -Xmn2g -Xss768k -<span class="string">XX:</span>PermSize=<span class="number">512</span>m -<span class="string">XX:</span>MaxPermSize=<span class="number">512</span>m -<span class="string">XX:</span>+UseConcMarkSweepGC -<span class="string">XX:</span>+UseParNewGC -<span class="string">XX:</span>+CMSClassUnloadingEnabled -<span class="string">XX:</span>+DisableExplicitGC -<span class="string">XX:</span>+UseCMSInitiatingOccupancyOnly -<span class="string">XX:</span>CMSInitiatingOccupancyFraction=<span class="number">68</span> -<span class="string">verbose:</span>gc -<span class="string">XX:</span>+PrintGCDetails -<span class="string">Xloggc:</span>&#123;CATALINA_BASE&#125;<span class="regexp">/logs/</span>gc.log -<span class="string">XX:</span>+PrintGCDateStamps -<span class="string">XX:</span>+HeapDumpOnOutOfMemoryError -<span class="string">XX:</span>HeapDumpPath=&#123;CATALINA_BASE&#125;/logs 前台</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdk1<span class="number">.7</span> <span class="number">6</span>V8G -server -Xms4g -Xmx4g -<span class="string">XX:</span>MaxPermSize=<span class="number">512</span>m \</span><br><span class="line"></span><br><span class="line">-<span class="string">verbose:</span>gc -<span class="string">XX:</span>+PrintGCDetails -Xloggc￼&#123;CATALINA_BASE&#125;<span class="regexp">/logs/</span>gc.log -<span class="string">XX:</span>+PrintGCTimeStamps \ 后台</span><br></pre></td></tr></table></figure>
<h2 id="配置说明："><a href="#配置说明：" class="headerlink" title="配置说明："></a>配置说明：</h2><ol>
<li>堆设置</li>
</ol>
<p>o -Xms:初始堆大小<br>o -Xmx:最大堆大小<br>o -XX:NewSize=n:设置年轻代大小<br>o -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4<br>o -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5<br>o -XX:MaxPermSize=n:设置持久代大小</p>
<ol>
<li>收集器设置</li>
</ol>
<p>o -XX:+UseSerialGC:设置串行收集器<br>o -XX:+UseParallelGC:设置并行收集器<br>o -XX:+UseParalledlOldGC:设置并行年老代收集器<br>o -XX:+UseConcMarkSweepGC:设置并发收集器</p>
<ol>
<li><p>垃圾回收统计信息<br>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename</p>
</li>
<li><p>并行收集器设置<br>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p>
</li>
<li><p>并发收集器设置<br>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>
</li>
</ol>
<h2 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h2><p>-Xms3072m -Xmx3072m<br>针对JVM堆的设置，通过-Xms -Xmx限定其最小、最大值</p>
<p>-Xmn1024m设置年轻代大小为1024m<br>整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小（perm）。</p>
<p>-Xss768k 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
<p>-XX:PermSize=512m -XX:MaxPermSize=512m<br>持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br>设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4</p>
<p>-XX:+UseConcMarkSweepGC<br><code>CMS收集器</code>也被称为<strong>短暂停顿并发收集器</strong>。它是对年老代进行垃圾收集的。CMS收集器通过多线程并发进行垃圾回收，尽量减少垃圾收集造成的停顿。CMS收集器对年轻代进行垃圾回收使用的算法和Parallel收集器一样。这个垃圾收集器适用于不能忍受长时间停顿要求快速响应的应用。</p>
<p>-XX:+UseParNewGC对年轻代采用多线程并行回收，这样收得快；</p>
<p>-XX:+CMSClassUnloadingEnabled<br>如果你启用了CMSClassUnloadingEnabled ，垃圾回收会清理持久代，移除不再使用的classes。这个参数只有在 UseConcMarkSweepGC  也启用的情况下才有用。</p>
<p>-XX:+DisableExplicitGC禁止System.gc()，免得程序员误调用gc方法影响性能；</p>
<p>-XX:+UseCMSInitiatingOccupancyOnly<br>标志来命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期。而是，当该标志被开启时，JVM通过CMSInitiatingOccupancyFraction的值进行每一次CMS收集，而不仅仅是第一次。然而，请记住大多数情况下，JVM比我们自己能作出更好的垃圾收集决策。因此，只有当我们充足的理由(比如测试)并且对应用程序产生的对象的生命周期有深刻的认知时，才应该使用该标志。</p>
<p>-XX:CMSInitiatingOccupancyFraction=68<br>默认CMS是在tenured generation(年老代）占满68%的时候开始进行CMS收集，如果你的年老代增长不是那么快，并且希望降低CMS次数的话，可以适当调高此值；</p>
<p>-XX:+UseParNewGC：对年轻代采用多线程并行回收，这样收得快；</p>
<p>-XX:HeapDumpPath<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:/usr/aaa/dump/heap_trace.txt<br>上面的的参数打Heap Dump信息</p>
<p>“ -XX:+HeapDumpOnOutOfMemoryError<br>此参数可以控制OutOfMemoryError时打印堆的信息</p>
<p>大家可能注意到了，这里<strong>推荐采用cms方式</strong>进行垃圾回收；<br>CMS是一种以获取最短回收停顿时间为目标的收集器，可以有效减少服务器停顿的时间；<br>CMS的GC线程对CPU的占用率会比较高，但在多核的服务器上还是展现了优越的特性，目前也被部署在国内的各大电商网站上。所以这里强烈推荐！<br>cms的概念：</p>
<p>CMS收集器也被称为短暂停顿并发收集器。它是对年老代进行垃圾收集的。CMS收集器通过多线程并发进行垃圾回收，尽量减少垃圾收集造成的停顿。CMS收集器对年轻代进行垃圾回收使用的算法和Parallel收集器一样。这个垃圾收集器适用于不能忍受长时间停顿要求快速响应的应用。<strong>CMS采用了多种方式尽可能降低GC的暂停时间,减少用户程序停顿。停顿时间降低的同时牺牲了CPU吞吐量 。这是在停顿时间和性能间做出的取舍，可以简单理解为”空间(性能)”换时间。</strong></p>
<p>调整的节奏：<br>由于怕影响线上应用，所以调整的步骤分三步：<br>第一步：部分影响少量机器试点，对比未调整的机器，观察调整后的结果；<br>第二步：调整部分应用的参数，进行压测，观察高并发压测之后的效果；<br>第三步：调整部分核心应用的jvm参数，通过818大促来实际检验效果；</p>
<p>一:长期表现，<br>第一个变化：fgc的次数减少，减少了大概一倍以上；<br>mobile工程，调整前基本上一天1-2辆次，调整后基本上就是2-3天一次：<br>online（另外一个工程）：可以明显看到fgc的统计频率少了很多；</p>
<p>第二个变化：fgc的时间减少<br>原来一次fgc要将近500ms，现在只要100ms不到了。<br>也证明了cms最大的好处就是减少fgc的停顿时间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouxiaowu.coding.me/2018/05/18/Mysql语句优化explain使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Mysql语句优化explain使用/" itemprop="url">Mysql语句优化explain使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T11:44:19+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/18/Mysql语句优化explain使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/05/18/Mysql语句优化explain使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是子查询，<span class="built_in">id</span>的序号会递增，<span class="built_in">id</span>的值越大优先级越高，越先被执行</span><br></pre></td></tr></table></figure>
<h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><p>查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询</p>
<ul>
<li><p><code>SIMPLE</code>:简单的select查询，查询中不包含子查询或者UNION</p>
</li>
<li><p><code>PRIMARY</code>:查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY（最后加载的那一个 ）</p>
</li>
<li><p><code>SUBQUERY</code>:在SELECT或WHERE列表中包含了子查询</p>
</li>
<li><p><code>DERIVED</code>:在FROM列表中包含的<strong>子查询</strong>被标记为DERIVED（衍生），Mysql会递归执行这些子查询，把结果放在临时表里。</p>
</li>
<li><p><code>UNION</code>:若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM字句的查询中，外层SELECT将被标记为:<code>DERIVED UNION</code></p>
</li>
<li><p><code>RESULT</code>:从UNION表获取结果的SELECT</p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2></li>
</ul>
<p>显示查询使用了何种类型，从最好到最差依次是<br>System&gt;const&gt;eq_ref&gt;range&gt;index&gt;All（<strong>全表扫描</strong>），一般来说<strong>至少达到range级别，最好达到ref</strong></p>
<ul>
<li><code>All</code>:全表扫描</li>
<li><code>System</code>:表只有一行记录，这是const类型的特例，平时不会出现(忽略不计)</li>
<li><code>const</code>:表示通过索引一次就找到了,const用于比较primary key或者unique索引，因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</li>
<li><code>const</code>:表示通过索引一次就找到了,const用于比较primary key或者unique索引，因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</li>
<li><code>eq_ref</code>:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</li>
<li><code>ref</code>：非唯一索引扫描，返回匹配某个单独值的行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</li>
<li><code>range</code>：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</li>
<li><code>index</code>:FULL INDEX SCAN,index与all区别为index类型只遍历索引树。这通常比all快，因为索引文件通常比数据文件小。</li>
</ul>
<h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><p>根据表统计信息及索引选用情况，大致估算出找到所需记录所需要读取的行数</p>
<h2 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h2><p>包含不适合在其他列中显示但十分重要的额外信息 包含的信息：</p>
<ul>
<li><strong>（危险!）</strong><code>Using filesort</code>:说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，MYSQL中无法利用索引完成的排序操作称为“文件排序”</li>
<li><strong>（特别危险!）</strong><code>Using temporary</code>:使用了临时表保存中间结果，MYSQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by</li>
<li><code>Using index</code>:表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错。如果同时出现<code>using where</code>，表明索引被用来执行索引键值的查找；如果没有同时出现<code>using where</code>，表明索引用来读取数据而非执行查找操作。</li>
</ul>
<h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h2><p>显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出， 但不一定被查询实际使用</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>实际使用的索引，如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引仅出现在key列表中，key参数可以<strong>作为使用了索引的判断标准</strong></p>
<h2 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h2><p>:表示索引中使用的字节数，可通过该列计算查询中索引的长度，在不损失精确性的情况下，<strong>长度越短越好</strong>，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>对应索引的赋值，显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引上的值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouxiaowu.coding.me/2018/05/15/基于-Redis-的分布式锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/基于-Redis-的分布式锁/" itemprop="url">基于 Redis 的分布式锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T18:41:02+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/缓存/" itemprop="url" rel="index">
                    <span itemprop="name">缓存</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/缓存/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/15/基于-Redis-的分布式锁/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/05/15/基于-Redis-的分布式锁/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式锁在分布式应用中应用广泛，想要搞懂一个新事物首先得了解它的由来，这样才能更加的理解甚至可以举一反三。</p>
<p>首先谈到分布式锁自然也就联想到分布式应用。</p>
<p>在我们将应用拆分为分布式应用之前的单机系统中，对一些并发场景读取公共资源时如扣库存，卖车票之类的需求可以简单的使用<a href="http://crossoverjie.top/2018/01/14/Synchronize/" target="_blank" rel="external">同步</a>或者是<a href="http://crossoverjie.top/2018/01/25/ReentrantLock/" target="_blank" rel="external">加锁</a>就可以实现。</p>
<p>但是应用分布式了之后系统由以前的单进程多线程的程序变为了多进程多线程，这时使用以上的解决方案明显就不够了。</p>
<p>因此业界常用的解决方案通常是借助于一个第三方组件并利用它自身的排他性来达到多进程的互斥。如：</p>
<ul>
<li>基于 DB 的唯一索引。</li>
<li>基于 ZK 的临时有序节点。</li>
<li>基于 Redis 的 <code>NX EX</code> 参数。</li>
</ul>
<p>这里主要基于 Redis 进行讨论。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然是选用了 Redis，那么它就得具有排他性才行。同时它最好也有锁的一些基本特性：</p>
<ul>
<li>高性能(加、解锁时高性能)</li>
<li>可以使用阻塞锁与非阻塞锁。</li>
<li>不能出现死锁。</li>
<li>可用性(不能出现节点 down 掉后加锁失败)。</li>
</ul>
<p>这里利用 <code>Redis set key</code> 时的一个 NX 参数可以保证在这个 key 不存在的情况下写入成功。并且再加上 EX 参数可以让该 key 在超时之后自动删除。</p>
<p>所以利用以上两个特性可以保证在同一时刻只会有一个进程获得锁，并且不会出现死锁(最坏的情况就是超时自动删除 key)。</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>实现代码如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="built_in">boolean</span> tryLock(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">String</span> request) &#123;</span><br><span class="line">    <span class="keyword">String</span> result = <span class="keyword">this</span>.jedis.<span class="built_in">set</span>(LOCK_PREFIX + <span class="built_in">key</span>, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class="number">10</span> * TIME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOCK_MSG.equals(result))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里使用的 jedis 的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">set</span>(<span class="keyword">String</span> <span class="keyword">key</span>, <span class="keyword">String</span> <span class="keyword">value</span>, <span class="keyword">String</span> nxxx, <span class="keyword">String</span> expx, <span class="keyword">long</span> <span class="keyword">time</span>);</span><br></pre></td></tr></table></figure>
<p>api。</p>
<p>该命令可以保证 NX EX 的原子性。</p>
<p>一定不要把两个命令(NX EX)分开执行，如果在 NX 之后程序出现问题就有可能产生死锁。</p>
<h4 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h4><p>同时也可以实现一个阻塞锁：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一直阻塞</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> lock(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">String</span> request) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="keyword">String</span> result = <span class="keyword">this</span>.jedis.<span class="built_in">set</span>(LOCK_PREFIX + <span class="built_in">key</span>, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class="number">10</span> * TIME);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_MSG.equals(result))&#123;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//防止一直消耗 CPU</span></span><br><span class="line">        Thread.sleep(DEFAULT_SLEEP_TIME) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//自定义阻塞时间</span></span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">boolean</span> lock(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">String</span> request,<span class="built_in">int</span> blockTime) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (blockTime &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> result = <span class="keyword">this</span>.jedis.<span class="built_in">set</span>(LOCK_PREFIX + <span class="built_in">key</span>, request, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, <span class="number">10</span> * TIME);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_MSG.equals(result))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        blockTime -= DEFAULT_SLEEP_TIME ;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(DEFAULT_SLEEP_TIME) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>解锁也很简单，其实就是把这个 key 删掉就万事大吉了，比如使用 <code>del key</code> 命令。</p>
<p>但现实往往没有那么 easy。</p>
<p>如果进程 A 获取了锁设置了超时时间，但是由于执行周期较长导致到了超时时间之后锁就自动释放了。这时进程 B 获取了该锁执行很快就释放锁。这样就会出现进程 B 将进程 A 的锁释放了。</p>
<p>所以最好的方式是在每次解锁时都需要判断锁<strong>是否是自己</strong>的。</p>
<p>这时就需要结合加锁机制一起实现了。</p>
<p>加锁时需要传递一个参数，将该参数作为这个 key 的 value，这样每次解锁时判断 value 是否相等即可。</p>
<p>所以解锁代码就不能是简单的 <code>del</code>了。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="built_in">boolean</span> unlock(<span class="keyword">String</span> <span class="built_in">key</span>,<span class="keyword">String</span> request)&#123;</span><br><span class="line">    <span class="comment">//lua script</span></span><br><span class="line">    <span class="keyword">String</span> script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Object</span> result = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">if</span> (jedis <span class="keyword">instanceof</span> Jedis)&#123;</span><br><span class="line">        result = ((Jedis)<span class="keyword">this</span>.jedis).eval(script, Collections.singletonList(LOCK_PREFIX + <span class="built_in">key</span>), Collections.singletonList(request));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (jedis <span class="keyword">instanceof</span> JedisCluster)&#123;</span><br><span class="line">        result = ((JedisCluster)<span class="keyword">this</span>.jedis).eval(script, Collections.singletonList(LOCK_PREFIX + <span class="built_in">key</span>), Collections.singletonList(request));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//throw new RuntimeException("instance is error") ;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UNLOCK_MSG.equals(result))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了一个 <code>lua</code> 脚本来判断 value 是否相等，相等才执行 del 命令。</p>
<p>使用 <code>lua</code> 也可以保证这里两个操作的原子性。</p>
<p>因此上文提到的四个基本特性也能满足了：</p>
<ul>
<li>使用 Redis 可以保证性能。</li>
<li>阻塞锁与非阻塞锁见上文。</li>
<li>利用超时机制解决了死锁。</li>
<li>Redis 支持集群部署提高了可用性。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我自己有撸了一个完整的实现，并且已经用于了生产，有兴趣的朋友可以开箱使用:</p>
<p>maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.crossoverjie.opensource<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>distributed-redis-lock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置 bean :</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> RedisLock build()&#123;</span><br><span class="line">        RedisLock redisLock = <span class="keyword">new</span> <span class="type">RedisLock</span>() ;</span><br><span class="line">        HostAndPort hostAndPort = <span class="keyword">new</span> <span class="type">HostAndPort</span>(<span class="string">"127.0.0.1"</span>,<span class="number">7000</span>) ;</span><br><span class="line">        JedisCluster jedisCluster = <span class="keyword">new</span> <span class="type">JedisCluster</span>(hostAndPort) ;</span><br><span class="line">        <span class="comment">// Jedis 或 JedisCluster 都可以</span></span><br><span class="line">        redisLock.setJedisCluster(jedisCluster) ;</span><br><span class="line">        <span class="keyword">return</span> redisLock ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> RedisLock redisLock ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> use() &#123;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">key</span> = <span class="string">"key"</span>;</span><br><span class="line">    <span class="keyword">String</span> request = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">boolean</span> locktest = redisLock.tryLock(<span class="built_in">key</span>, request);</span><br><span class="line">        <span class="keyword">if</span> (!locktest) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"locked error"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock(<span class="built_in">key</span>,request) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用很简单。这里主要是想利用 Spring 来帮我们管理 RedisLock 这个单例的 bean，所以在释放锁的时候需要手动(因为整个上下文只有一个 RedisLock 实例)的传入 key 以及 request(api 看起来不是特别优雅)。</p>
<p>也可以在每次使用锁的时候 new 一个 RedisLock 传入 key 以及 request，这样倒是在解锁时很方便。但是需要自行管理 RedisLock 的实例。各有优劣吧。</p>
<p>项目源码在：</p>
<p><a href="https://github.com/crossoverJie/distributed-lock-redis" target="_blank" rel="external">https://github.com/crossoverJie/distributed-lock-redis</a></p>
<p>欢迎讨论。</p>
<h2 id="单测"><a href="#单测" class="headerlink" title="单测"></a>单测</h2><p>在做这个项目的时候让我不得不想提一下<strong>单测</strong>。</p>
<p>因为这个应用是强依赖于第三方组件的(Redis)，但是在单测中我们需要排除掉这种依赖。比如其他伙伴 fork 了该项目想在本地跑一遍单测，结果运行不起来：</p>
<ol>
<li>有可能是 Redis 的 ip、端口和单测里的不一致。</li>
<li>Redis 自身可能也有问题。</li>
<li>也有可能是该同学的环境中并没有 Redis。</li>
</ol>
<p>所以最好是要把这些外部不稳定的因素排除掉，单测只测我们写好的代码。</p>
<p>于是就可以引入单测利器 <code>Mock</code> 了。</p>
<p>它的想法很简答，就是要把你所依赖的外部资源统统屏蔽掉。如：数据库、外部接口、外部文件等等。</p>
<p>使用方式也挺简单，可以参考该项目的单测：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void tryLock() throws Exception &#123;</span><br><span class="line">    String key = <span class="string">"test"</span>;</span><br><span class="line">    String request = UUID.<span class="keyword">random</span>UUID().<span class="keyword">to</span>String();</span><br><span class="line">    Mockito.when(jedisCluster.<span class="built_in">set</span>(Mockito.<span class="literal">any</span>String(), Mockito.<span class="literal">any</span>String(), Mockito.<span class="literal">any</span>String(),</span><br><span class="line">            Mockito.<span class="literal">any</span>String(), Mockito.<span class="literal">any</span>Long())).thenReturn(<span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line">    boolean locktest = redisLock.tryLock(key, request);</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"locktest="</span> + locktest);</span><br><span class="line"></span><br><span class="line">    Assert.assertTrue(locktest);</span><br><span class="line"></span><br><span class="line">    //check</span><br><span class="line">    Mockito.verify(jedisCluster).<span class="built_in">set</span>(Mockito.<span class="literal">any</span>String(), Mockito.<span class="literal">any</span>String(), Mockito.<span class="literal">any</span>String(),</span><br><span class="line">            Mockito.<span class="literal">any</span>String(), Mockito.<span class="literal">any</span>Long());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是简单演示下，可以的话下次仔细分析分析。</p>
<p>它的原理其实也挺简单，debug 的话可以很直接的看出来：</p>
<p><a href="https://ws2.sinaimg.cn/large/006tKfTcgy1fpxho866hbj311u0ej42f.jpg" target="_blank" rel="external"><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fpxho866hbj311u0ej42f.jpg" alt="img"></a></p>
<p>这里我们所依赖的 JedisCluster 其实是一个 <code>cglib 代理对象</code>。所以也不难想到它是如何工作的。</p>
<p>比如这里我们需要用到 JedisCluster 的 set 函数并需要它的返回值。</p>
<p>Mock 就将该对象代理了，并在实际执行 set 方法后给你返回了一个你自定义的值。</p>
<p>这样我们就可以随心所欲的测试了，<strong>完全把外部依赖所屏蔽了</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此一个基于 Redis 的分布式锁完成，但是依然有些问题。</p>
<ul>
<li>如在 key 超时之后业务并没有执行完毕但却自动释放锁了，这样就会导致并发问题。</li>
<li>就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key 在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master 宕机也是会出现上面的问题。</li>
</ul>
<p>感兴趣的朋友还可以参考 <a href="https://github.com/redisson/redisson" target="_blank" rel="external">Redisson</a> 的实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouxiaowu.coding.me/2018/05/15/Disruptor并发框架上手demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/Disruptor并发框架上手demo/" itemprop="url">Disruptor并发框架上手demo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T09:37:32+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/15/Disruptor并发框架上手demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/05/15/Disruptor并发框架上手demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h4><ul>
<li>Martin Fowler在自己网站上写了一篇LMAX架构的文章，在文章中他介绍了LMAX是一种新型零售金融交易平台，它能够以很低的延迟产生大量交易。这个系统是建立在JVM平台上，其核心是一个业务逻辑处理器，它能够在一个线程里每秒处理6百万订单。业务逻辑处理器完全是运行在<code>内存</code>中，使用<code>事件源驱动</code>方式。业务逻辑处理器的核心是Disruptor。</li>
<li>Disruptor它是一个开源的并发框架，并获得2011 Duke’s 程序框架创新奖，能够在无锁的情况下实现网络的Queue并发操作。</li>
<li>Disruptor是一个高性能的异步处理框架，或者可以认为是最快的消息框架（轻量的JMS），也可以认为是一个观察者模式的实现，或者事件监听模式的实现。</li>
</ul>
<blockquote>
<p>在使用之前，首先说明disruptor主要功能加以说明，你可以理解为他是一种高效的”生产者-消费者”模型。也就性能远远高于传统的BlockingQueue容器。</p>
</blockquote>
<h4 id="上手demo"><a href="#上手demo" class="headerlink" title="上手demo"></a>上手demo</h4><ul>
<li>首先声明一个Event来包含需要传递的数据：</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LongEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> <span class="keyword">value</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(<span class="params"><span class="keyword">long</span> <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>于需要让Disruptor为我们创建事件，我们同时还声明了一个EventFactory来实例化Event对象。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要让disruptor为我们创建事件，我们同时还声明了一个EventFactory来实例化Event对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">EventFactory</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Object <span class="keyword">new</span><span class="type">Instance</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">LongEvent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们还需要一个事件消费者，也就是一个事件处理器。这个事件处理器简单地把事件中存储的数据打印到终端：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt;  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent longEvent, <span class="keyword">long</span> l, <span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(longEvent.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>事件都会有一个生成事件的源，这个例子中假设事件是由于磁盘IO或者network读取数据的时候触发的，事件源使用一个ByteBuffer来模拟它接受到的数据，也就是说，事件源会在IO读取到一部分数据的时候触发事件（触发事件不是自动的，程序员需要在读取到数据的时候自己触发事件并发布）</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LongEventProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongEventProducer</span>(<span class="params">RingBuffer&lt;LongEvent&gt; ringBuffer</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * onData用来发布事件，每调用一次就发布一次事件</span></span><br><span class="line"><span class="comment">     * 它的参数会用过事件传递给消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span>(<span class="params">ByteBuffer bb</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1.可以把ringBuffer看做一个事件队列，那么next就是得到下面一个事件槽</span></span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.用上面的索引取出一个空的事件用于填充（获取该序号对应的事件对象）</span></span><br><span class="line">            LongEvent <span class="keyword">event</span> = ringBuffer.<span class="keyword">get</span>(sequence);</span><br><span class="line">            <span class="comment">//3.获取要通过事件传递的业务数据</span></span><br><span class="line">            <span class="keyword">event</span>.setValue(bb.getLong(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.发布事件</span></span><br><span class="line">            <span class="comment">//注意，最后的 ringBuffer.publish 方法必须包含在 finally 中以确保必须得到调用；</span></span><br><span class="line">            <span class="comment">// 如果某个请求的 sequence 未被提交，将会堵塞后续的发布操作或者其它的 producer。</span></span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main函数执行调用</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">//创建缓冲池</span></span><br><span class="line">        ExecutorService  executor = Executors.<span class="keyword">new</span><span class="type">CachedThreadPool</span>();</span><br><span class="line">        <span class="comment">//创建工厂</span></span><br><span class="line">        LongEventFactory factory = <span class="keyword">new</span> <span class="type">LongEventFactory</span>();</span><br><span class="line">        <span class="comment">//创建bufferSize ,也就是RingBuffer大小，必须是2的N次方</span></span><br><span class="line">        int ringBufferSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        //BlockingWaitStrategy 是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现</span></span><br><span class="line"><span class="comment">        WaitStrategy BLOCKING_WAIT = new BlockingWaitStrategy();</span></span><br><span class="line"><span class="comment">        //SleepingWaitStrategy 的性能表现跟BlockingWaitStrategy差不多，对CPU的消耗也类似，但其对生产者线程的影响最小，适合用于异步日志类似的场景</span></span><br><span class="line"><span class="comment">        WaitStrategy SLEEPING_WAIT = new SleepingWaitStrategy();</span></span><br><span class="line"><span class="comment">        //YieldingWaitStrategy 的性能是最好的，适合用于低延迟的系统。在要求极高性能且事件处理线数小于CPU逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性</span></span><br><span class="line"><span class="comment">        WaitStrategy YIELDING_WAIT = new YieldingWaitStrategy();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  参数说明：</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建disruptor</span></span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor =</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">Disruptor</span>&lt;LongEvent&gt;(factory, ringBufferSize, executor, ProducerType.SINGLE, <span class="keyword">new</span> <span class="type">YieldingWaitStrategy</span>());</span><br><span class="line">        <span class="comment">// 连接消费事件方法</span></span><br><span class="line">        disruptor.handleEventsWith(<span class="keyword">new</span> <span class="type">LongEventHandler</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Disruptor 的事件发布过程是一个两阶段提交的过程：</span></span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        LongEventProducer producer = <span class="keyword">new</span> <span class="type">LongEventProducer</span>(ringBuffer);</span><br><span class="line">        <span class="comment">//LongEventProducerWithTranslator producer = new LongEventProducerWithTranslator(ringBuffer);</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span>(long l = <span class="number">0</span>; l&lt;<span class="number">100</span>; l++)&#123;</span><br><span class="line">            byteBuffer.putLong(<span class="number">0</span>, l);</span><br><span class="line">            producer.onData(byteBuffer);</span><br><span class="line">            <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        disruptor.shutdown();<span class="comment">//关闭 disruptor，方法会堵塞，直至所有的事件都得到处理；</span></span><br><span class="line">        executor.shutdown();<span class="comment">//关闭 disruptor 使用的线程池；如果需要的话，必须手动关闭， disruptor 在 shutdown 时不会自动关闭；</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouxiaowu.coding.me/2018/05/14/Stream分组和分区/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/Stream分组和分区/" itemprop="url">Stream分组和分区</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T11:55:40+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/14/Stream分组和分区/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/05/14/Stream分组和分区/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  652
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章展示了如何使用 Streams API 中的 Collector 及 groupingBy 和 partitioningBy 来对流中的元素进行分组和分区。</p>
<p>思考一下 Employee 对象流，每个对象对应一个名字、城市和销售数量，如下表所示：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------+</span>------------<span class="code">+-----------------+</span></span><br><span class="line">| Name     | City       | Number of Sales |</span><br><span class="line"><span class="code">+----------+</span>------------<span class="code">+-----------------+</span></span><br><span class="line">| Alice    | London     | 200             |</span><br><span class="line">| Bob      | London     | 150             |</span><br><span class="line">| Charles  | New York   | 160             |</span><br><span class="line">| Dorothy  | Hong Kong  | 190             |</span><br><span class="line"><span class="code">+----------+</span>------------<span class="code">+-----------------+</span></span><br></pre></td></tr></table></figure>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>首先，我们利用（lambda表达式出现之前的）命令式风格Java 程序对流中的雇员按城市进行分组：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;Employee&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Employee e : employees) &#123;</span><br><span class="line">  <span class="built_in">String</span> city = e.getCity();</span><br><span class="line">  <span class="built_in">List</span>&lt;Employee&gt; empsInCity = result.<span class="keyword">get</span>(city);</span><br><span class="line">  <span class="keyword">if</span> (empsInCity == <span class="keyword">null</span>) &#123;</span><br><span class="line">    empsInCity = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    result.put(city, empsInCity);</span><br><span class="line">  &#125;</span><br><span class="line">  empsInCity.add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能很熟悉写这样的代码，你也看到了，一个如此简单的任务就需要这么多代码！</p>
<p>而在 Java 8 中，你可以使用 groupingBy 收集器，一条语句就能完成相同的功能，像这样：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;Employee&gt;&gt; employeesByCity =</span><br><span class="line">  employees.stream().collect(groupingBy(Employee<span class="type">::getCity</span>));</span><br></pre></td></tr></table></figure>
<p>结果如下面的 map 所示：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;New York=[Charles], Hong Kong=[Dorothy], London=[Alice, Bob]&#125;</span><br></pre></td></tr></table></figure>
<p>还可以计算每个城市中雇员的数量，只需传递一个计数收集器给 groupingBy 收集器。第二个收集器的作用是在流分类的同一个组中对每个元素进行递归操作。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Long&gt; numEmployeesByCity =</span><br><span class="line">  employees.stream().collect(groupingBy(Employee<span class="type">::getCity</span>, counting()));</span><br></pre></td></tr></table></figure>
<p>结果如下面的 map 所示：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;New <span class="attribute">York</span>=1, Hong <span class="attribute">Kong</span>=1, <span class="attribute">London</span>=2&#125;</span><br></pre></td></tr></table></figure>
<p>顺便提一下，该功能与下面的 SQL 语句是等同的：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city, count(*) <span class="keyword">from</span> Employee<span class="built_in"> group </span>by city</span><br></pre></td></tr></table></figure>
<p>另一个例子是计算每个城市的平均年龄，这可以联合使用 averagingInt 和 groupingBy 收集器：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Double&gt; avgSalesByCity =</span><br><span class="line">  employees.stream().collect(groupingBy(Employee<span class="type">::getCity</span>,</span><br><span class="line">                               averagingInt(Employee<span class="type">::getNumSales</span>)));</span><br></pre></td></tr></table></figure>
<p>结果如下 map 所示：</p>
 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;New <span class="attribute">York</span>=160.0, Hong <span class="attribute">Kong</span>=190.0, <span class="attribute">London</span>=175.0&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>分区是一种特殊的分组，结果 map 至少包含两个不同的分组——一个true，一个false。例如，如果想找出最优秀的员工，你可以将所有雇员分为两组，一组销售量大于 N，另一组小于 N，使用 partitioningBy 收集器：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;Employee&gt;&gt; partitioned =</span><br><span class="line">  employees.stream().collect(partitioningBy(e -&gt; e.getNumSales() &gt; <span class="number">150</span>));</span><br></pre></td></tr></table></figure>
<p>输出如下结果：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="literal">false</span>=[Bob], <span class="literal">true</span>=[Alice, Charles, Dorothy]&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以将 groupingBy 收集器传递给 partitioningBy 收集器来将联合使用分区和分组。例如，你可以统计每个分区中的每个城市的雇员人数：</p>
<p>这样会生成一个二级 Map:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Long&gt;&gt; result =</span><br><span class="line">  employees.stream().collect(partitioningBy(e -&gt; e.getNumSales() &gt; <span class="number">150</span>,</span><br><span class="line">                               groupingBy(Employee<span class="type">::getCity</span>, counting())));</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhouxiaowu.coding.me/2018/05/14/java死锁重现与排查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/java死锁重现与排查/" itemprop="url">java死锁重现与排查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T09:21:48+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/线上故障排查/" itemprop="url" rel="index">
                    <span itemprop="name">线上故障排查</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/14/java死锁重现与排查/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/05/14/java死锁重现与排查/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-构造死锁"><a href="#1-构造死锁" class="headerlink" title="1.构造死锁"></a>1.构造死锁</h1><p>通过模拟两个哲学吃饭，需要两把叉子。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by xiaowu.zhou@tongdun.cn on 2018/5/14.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class DeadLock extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哲学家吃饭需要的刀叉</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">Object</span> fork1 = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">Object</span> fork2 = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> tool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DeadLock(<span class="keyword">Object</span> object) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.tool = object;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tool == fork1)&#123;</span><br><span class="line">            <span class="keyword">this</span>.setName(<span class="string">"哲学家1"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tool == fork2)&#123;</span><br><span class="line">            <span class="keyword">this</span>.setName(<span class="string">"哲学家2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tool == fork1)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (fork1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"哲学家1开始准备，有了一把叉子1"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (fork2)&#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"哲学家1开始吃饭，有了两把叉子"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tool == fork2)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (fork2)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"哲学家2开始准备，有了一把叉子2"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (fork1)&#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"哲学家2开始吃饭，有了两把叉子"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DeadLock deadLock1 = <span class="keyword">new</span> DeadLock(fork1);</span><br><span class="line"></span><br><span class="line">        DeadLock deadLock2 = <span class="keyword">new</span> DeadLock(fork2);</span><br><span class="line"></span><br><span class="line">        deadLock1.start();</span><br><span class="line"></span><br><span class="line">        deadLock2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-排查问题"><a href="#2-排查问题" class="headerlink" title="2. 排查问题"></a>2. 排查问题</h1><p>死锁的线程不占用cpu，通过jstack可以排查</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack <span class="number">59356</span> &gt; dead_lock_stack.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>搜索<code>deadlock</code></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">2018-05-14 09:08:13</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM (25.144-b01 mixed mode):</span><br><span class="line"></span><br><span class="line"><span class="string">"Attach Listener"</span> #12 daemon <span class="attribute">prio</span>=9 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb3818c8000 <span class="attribute">nid</span>=0x1407 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"哲学家2"</span> #11 <span class="attribute">prio</span>=5 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb38185a000 <span class="attribute">nid</span>=0x5103 waiting <span class="keyword">for</span> monitor entry [0x000070000d069000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at DeadLock.<span class="builtin-name">run</span>(DeadLock.java:59)</span><br><span class="line">	- waiting <span class="keyword">to</span> lock &lt;0x0000000795782620&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x0000000795782630&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line"><span class="string">"哲学家1"</span> #10 <span class="attribute">prio</span>=5 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb382042800 <span class="attribute">nid</span>=0x4f03 waiting <span class="keyword">for</span> monitor entry [0x000070000cf66000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at DeadLock.<span class="builtin-name">run</span>(DeadLock.java:41)</span><br><span class="line">	- waiting <span class="keyword">to</span> lock &lt;0x0000000795782630&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x0000000795782620&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line"><span class="string">"Service Thread"</span> #9 daemon <span class="attribute">prio</span>=9 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb38206c800 <span class="attribute">nid</span>=0x4b03 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"C1 CompilerThread2"</span> #8 daemon <span class="attribute">prio</span>=9 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb38185f000 <span class="attribute">nid</span>=0x4903 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"C2 CompilerThread1"</span> #7 daemon <span class="attribute">prio</span>=9 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb382815800 <span class="attribute">nid</span>=0x4703 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"C2 CompilerThread0"</span> #6 daemon <span class="attribute">prio</span>=9 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb381859000 <span class="attribute">nid</span>=0x4503 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"Monitor Ctrl-Break"</span> #5 daemon <span class="attribute">prio</span>=5 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb3830b9000 <span class="attribute">nid</span>=0x4303 runnable [0x000070000c954000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)</span><br><span class="line">	- locked &lt;0x0000000795708738&gt; (a java.io.InputStreamReader)</span><br><span class="line">	at java.io.InputStreamReader.read(InputStreamReader.java:184)</span><br><span class="line">	at java.io.BufferedReader.fill(BufferedReader.java:161)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:324)</span><br><span class="line">	- locked &lt;0x0000000795708738&gt; (a java.io.InputStreamReader)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:389)</span><br><span class="line">	at com.intellij.rt.execution.application.AppMainV2<span class="variable">$1</span>.<span class="builtin-name">run</span>(AppMainV2.java:64)</span><br><span class="line"></span><br><span class="line"><span class="string">"Signal Dispatcher"</span> #4 daemon <span class="attribute">prio</span>=9 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb382030800 <span class="attribute">nid</span>=0x4103 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">"Finalizer"</span> #3 daemon <span class="attribute">prio</span>=8 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb38202b000 <span class="attribute">nid</span>=0x3103 <span class="keyword">in</span> Object.wait() [0x000070000c74e000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;0x0000000795588ec8&gt; (a java.lang.ref.ReferenceQueue<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.<span class="builtin-name">remove</span>(ReferenceQueue.java:143)</span><br><span class="line">	- locked &lt;0x0000000795588ec8&gt; (a java.lang.ref.ReferenceQueue<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.<span class="builtin-name">remove</span>(ReferenceQueue.java:164)</span><br><span class="line">	at java.lang.ref.Finalizer<span class="variable">$FinalizerThread</span>.<span class="builtin-name">run</span>(Finalizer.java:209)</span><br><span class="line"></span><br><span class="line"><span class="string">"Reference Handler"</span> #2 daemon <span class="attribute">prio</span>=10 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb382805000 <span class="attribute">nid</span>=0x2f03 <span class="keyword">in</span> Object.wait() [0x000070000c64b000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;0x0000000795586b68&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.Object.wait(Object.java:502)</span><br><span class="line">	at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">	- locked &lt;0x0000000795586b68&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.ref.Reference<span class="variable">$ReferenceHandler</span>.<span class="builtin-name">run</span>(Reference.java:153)</span><br><span class="line"></span><br><span class="line"><span class="string">"main"</span> #1 <span class="attribute">prio</span>=5 <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb382005800 <span class="attribute">nid</span>=0x1c03 runnable [0x000070000c039000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at DeadLock.main(DeadLock.java:81)</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Thread"</span> <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb382802800 <span class="attribute">nid</span>=0x2d03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#0 (ParallelGC)"</span> <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb38200e800 <span class="attribute">nid</span>=0x2503 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#1 (ParallelGC)"</span> <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb38200f800 <span class="attribute">nid</span>=0x2703 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#2 (ParallelGC)"</span> <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb382010000 <span class="attribute">nid</span>=0x2903 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#3 (ParallelGC)"</span> <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb382010800 <span class="attribute">nid</span>=0x2b03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Periodic Task Thread"</span> <span class="attribute">os_prio</span>=31 <span class="attribute">tid</span>=0x00007fb382085800 <span class="attribute">nid</span>=0x4d03 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 22</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"哲学家2"</span>:</span><br><span class="line">  waiting <span class="keyword">to</span> lock monitor 0x00007fb38202a5f8 (object 0x0000000795782620, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"哲学家1"</span></span><br><span class="line"><span class="string">"哲学家1"</span>:</span><br><span class="line">  waiting <span class="keyword">to</span> lock monitor 0x00007fb3818ca808 (object 0x0000000795782630, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"哲学家2"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"哲学家2"</span>:</span><br><span class="line">	at DeadLock.<span class="builtin-name">run</span>(DeadLock.java:59)</span><br><span class="line">	- waiting <span class="keyword">to</span> lock &lt;0x0000000795782620&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x0000000795782630&gt; (a java.lang.Object)</span><br><span class="line"><span class="string">"哲学家1"</span>:</span><br><span class="line">	at DeadLock.<span class="builtin-name">run</span>(DeadLock.java:41)</span><br><span class="line">	- waiting <span class="keyword">to</span> lock &lt;0x0000000795782630&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x0000000795782620&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>
<p>发现哲学家1，持有锁<code>0x0000000795782620</code>,等待锁<code>0x0000000795782630</code> ； 而哲学家2，则相反。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/xiaowu_avatar.jpg"
                alt="周小伍 Joey" />
            
              <p class="site-author-name" itemprop="name">周小伍 Joey</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">150</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">周小伍 Joey</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">276.8k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://joeyblog.disqus.com/count.js" async></script>
    

    

  




	





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
