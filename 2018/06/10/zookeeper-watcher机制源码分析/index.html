<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="zookeeper," />










<meta name="description" content="Watcher的基本流程ZooKeeper 的 Watcher 机制，总的来说可以分为三个过程：客户端注册 Watcher、服务器处理 Watcher 和客户端回调 Watcher 客户端注册watcher有3种方式，getData、exists、getChildren；以如下代码为例来分析整个触发机制的原理  12345678910ZooKeeper zookeeper=new ZooKeepe">
<meta name="keywords" content="zookeeper">
<meta property="og:type" content="article">
<meta property="og:title" content="zookeeper watcher机制源码分析">
<meta property="og:url" content="http://yoursite.com/2018/06/10/zookeeper-watcher机制源码分析/index.html">
<meta property="og:site_name" content="xiaowu&#39;s blog">
<meta property="og:description" content="Watcher的基本流程ZooKeeper 的 Watcher 机制，总的来说可以分为三个过程：客户端注册 Watcher、服务器处理 Watcher 和客户端回调 Watcher 客户端注册watcher有3种方式，getData、exists、getChildren；以如下代码为例来分析整个触发机制的原理  12345678910ZooKeeper zookeeper=new ZooKeepe">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-08-22T03:31:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zookeeper watcher机制源码分析">
<meta name="twitter:description" content="Watcher的基本流程ZooKeeper 的 Watcher 机制，总的来说可以分为三个过程：客户端注册 Watcher、服务器处理 Watcher 和客户端回调 Watcher 客户端注册watcher有3种方式，getData、exists、getChildren；以如下代码为例来分析整个触发机制的原理  12345678910ZooKeeper zookeeper=new ZooKeepe">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/10/zookeeper-watcher机制源码分析/"/>





  <title>zookeeper watcher机制源码分析 | xiaowu's blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3da41265a1a0042eebe5413c0d6c76f5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiaowu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/zookeeper-watcher机制源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">zookeeper watcher机制源码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-10T17:26:40+08:00">
                2018-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/10/zookeeper-watcher机制源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/10/zookeeper-watcher机制源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  38
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Watcher的基本流程"><a href="#Watcher的基本流程" class="headerlink" title="Watcher的基本流程"></a>Watcher的基本流程</h1><p>ZooKeeper 的 Watcher 机制，总的来说可以分为三个过程：客户端注册 Watcher、服务器处理 Watcher 和客户端回调 Watcher</p>
<p>客户端注册watcher有3种方式，getData、exists、getChildren；以如下代码为例来分析整个触发机制的原理</p>
 <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper zookeeper=<span class="keyword">new</span> ZooKeeper(“<span class="number">192.168</span><span class="number">.11</span><span class="number">.152</span>:<span class="number">2181</span>”,<span class="number">4000</span>,<span class="keyword">new</span> Watcher()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processor</span>(<span class="params">WatchedEvent <span class="keyword">event</span></span>)</span>&#123;</span><br><span class="line">		 System.<span class="keyword">out</span>.println(“<span class="keyword">event</span>.type”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">zookeeper.create(“/mic”,”<span class="number">0</span>”.getByte(),ZooDefs.Ids. OPEN_ACL_UNSAFE,CreateModel. PERSISTENT); <span class="comment">//创建节点</span></span><br><span class="line"></span><br><span class="line">zookeeper.exists(“/mic”,<span class="literal">true</span>); <span class="comment">//注册监听</span></span><br><span class="line">zookeeper.setData(“/mic”, “<span class="number">1</span>”.getByte(),<span class="number">-1</span>) ; <span class="comment">//修改节点的值触发监听</span></span><br></pre></td></tr></table></figure>
<h2 id="ZooKeeper-API的初始化过程"><a href="#ZooKeeper-API的初始化过程" class="headerlink" title="ZooKeeper API的初始化过程"></a>ZooKeeper API的初始化过程</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper zookeeper=<span class="keyword">new</span> ZooKeeper(“<span class="number">192.168</span><span class="number">.11</span><span class="number">.152</span>:<span class="number">2181</span>”,<span class="number">4000</span>,<span class="keyword">new</span> Watcher()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processor</span>(<span class="params">WatchedEvent <span class="keyword">event</span></span>)</span>&#123;</span><br><span class="line">		 System.<span class="keyword">out</span>.println(“<span class="keyword">event</span>.type”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure>
<p>在创建一个 ZooKeeper 客户端对象实例时，我们通过new Watcher()向构造方法中传入一个默认的 Watcher, 这个 Watcher 将作为整个 ZooKeeper会话期间的默认 Watcher，会一直被保存在客户端 ZKWatchManager 的 defaultWatcher 中;代码如下</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ZooKeeper(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher,</span><br><span class="line">         <span class="keyword">boolean</span> canBeReadOnly, HostProvider aHostProvider,</span><br><span class="line">         ZKClientConfig clientConfig) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     LOG.info(<span class="string">"Initiating client connection, connectString="</span> + connectString</span><br><span class="line">             + <span class="string">" sessionTimeout="</span> + sessionTimeout + <span class="string">" watcher="</span> + watcher);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (clientConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">         clientConfig = <span class="keyword">new</span> ZKClientConfig();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>.clientConfig = clientConfig;</span><br><span class="line">     watchManager = defaultWatchManager();</span><br><span class="line">     watchManager.defaultWatcher = watcher;  --在这里将watcher设置到ZKWatchManager</span><br><span class="line">     ConnectStringParser connectStringParser = <span class="keyword">new</span> ConnectStringParser(</span><br><span class="line">             connectString);</span><br><span class="line">     hostProvider = aHostProvider;</span><br><span class="line">     --初始化了ClientCnxn，并且调用cnxn.start()方法</span><br><span class="line">     cnxn = <span class="keyword">new</span> ClientCnxn(connectStringParser.getChrootPath(),</span><br><span class="line">             hostProvider, sessionTimeout, <span class="keyword">this</span>, watchManager,</span><br><span class="line">             getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line">     cnxn.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>ClientCnxn:是Zookeeper客户端和Zookeeper服务器端进行通信和事件通知处理的主要类，它内部包含两个类，</p>
<ol>
<li>SendThread  ：负责客户端和服务器端的数据通信, 也包括事件信息的传输</li>
<li>EventThread :  主要在客户端回调注册的Watchers进行通知处理</li>
</ol>
<h3 id="ClientCnxn初始化"><a href="#ClientCnxn初始化" class="headerlink" title="ClientCnxn初始化"></a>ClientCnxn初始化</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ClientCnxn(<span class="keyword">String</span> chrootPath, HostProvider hostProvider, <span class="keyword">int</span> sessionTimeout, ZooKeeper zooKeeper,</span><br><span class="line">           ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span><br><span class="line">           <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd, <span class="keyword">boolean</span> canBeReadOnly) &#123;</span><br><span class="line">       <span class="keyword">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">       <span class="keyword">this</span>.watcher = watcher;</span><br><span class="line">       <span class="keyword">this</span>.sessionId = sessionId;</span><br><span class="line">       <span class="keyword">this</span>.sessionPasswd = sessionPasswd;</span><br><span class="line">       <span class="keyword">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">       <span class="keyword">this</span>.hostProvider = hostProvider;</span><br><span class="line">       <span class="keyword">this</span>.chrootPath = chrootPath;</span><br><span class="line"></span><br><span class="line">       connectTimeout = sessionTimeout / hostProvider.<span class="built_in">size</span>();</span><br><span class="line">       readTimeout = sessionTimeout * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">       readOnly = canBeReadOnly;</span><br><span class="line"></span><br><span class="line">       sendThread = <span class="keyword">new</span> SendThread(clientCnxnSocket);  --初始化sendThread</span><br><span class="line">       eventThread = <span class="keyword">new</span> EventThread();                --初始化eventThread</span><br><span class="line">       <span class="keyword">this</span>.clientConfig=zooKeeper.getClientConfig();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> start() &#123; --启动两个线程</span><br><span class="line">       sendThread.start();</span><br><span class="line">       eventThread.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端通过exists注册监听"><a href="#客户端通过exists注册监听" class="headerlink" title="客户端通过exists注册监听"></a>客户端通过exists注册监听</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.exists(“/mic”,<span class="literal">true</span>); <span class="comment">//注册监听</span></span><br></pre></td></tr></table></figure>
<p>通过exists方法来注册监听，代码如下</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Stat exists(final <span class="keyword">String</span> path, Watcher watcher)</span><br><span class="line">        throws KeeperException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        final <span class="keyword">String</span> clientPath = path;</span><br><span class="line">        PathUtils.validatePath(clientPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the watch contains the un-chroot path</span></span><br><span class="line">        WatchRegistration wcb = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (watcher != <span class="literal">null</span>) &#123;</span><br><span class="line">            wcb = <span class="keyword">new</span> <span class="type">ExistsWatchRegistration</span>(watcher, clientPath); <span class="comment">//构建ExistWatchRegistration</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final <span class="keyword">String</span> serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 构造RequestHeader</span></span><br><span class="line">        RequestHeader h = <span class="keyword">new</span> <span class="type">RequestHeader</span>();</span><br><span class="line">        h.setType(ZooDefs.OpCode.exists);  <span class="comment">//设置操作类型为exists</span></span><br><span class="line">        ExistsRequest request = <span class="keyword">new</span> <span class="type">ExistsRequest</span>();  <span class="comment">// 构造ExistsRequest</span></span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setWatch(watcher != <span class="literal">null</span>);  <span class="comment">//是否注册监听</span></span><br><span class="line">        SetDataResponse response = <span class="keyword">new</span> <span class="type">SetDataResponse</span>();  <span class="comment">//设置服务端响应的接收类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将封装的RequestHeader、ExistsRequest、SetDataResponse、WatchRegistration添加到发送队列</span></span><br><span class="line">        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">        <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.getErr() == KeeperException.Code.NONODE.intValue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.<span class="keyword">get</span>(r.getErr()),</span><br><span class="line">                    clientPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回exists得到的结果（Stat信息）</span></span><br><span class="line">        <span class="keyword">return</span> response.getStat().getCzxid() == <span class="number">-1</span> ? <span class="literal">null</span> : <span class="type">response</span>.getStat();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="cnxn-submitRequest"><a href="#cnxn-submitRequest" class="headerlink" title="cnxn.submitRequest"></a>cnxn.submitRequest</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReplyHeader submitRequest(RequestHeader h, Record request,</span><br><span class="line">            Record response, WatchRegistration watchRegistration,</span><br><span class="line">            WatchDeregistration watchDeregistration)</span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ReplyHeader r = <span class="keyword">new</span> ReplyHeader();</span><br><span class="line">        <span class="comment">//将消息添加到队列,并构造一个Packet传输对象</span></span><br><span class="line">        Packet packet = queuePacket(h, r, request, response, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, watchRegistration, watchDeregistration);</span><br><span class="line">        <span class="keyword">synchronized</span> (packet) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!packet.finished) &#123; <span class="comment">//在数据包没有处理完成之前，一直阻塞</span></span><br><span class="line">                packet.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>将RequestHeader h, ReplyHeader r, Record request, Record response，封装成package， 添加到outgoingQueue队列中，再唤醒sendThread,通知有数据包过来。outgoingQueue是一个阻塞队列，outgoingQueue是待发送的队列。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingDeque&lt;Packet&gt; outgoingQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;Packet&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,</span><br><span class="line">        Record response, AsyncCallback cb, <span class="keyword">String</span> clientPath,</span><br><span class="line">        <span class="keyword">String</span> serverPath, <span class="keyword">Object</span> ctx, WatchRegistration watchRegistration,</span><br><span class="line">        WatchDeregistration watchDeregistration) &#123;</span><br><span class="line">    <span class="comment">//将相关传输对象转化成Packet</span></span><br><span class="line">    Packet packet = <span class="keyword">null</span>;</span><br><span class="line">    packet = <span class="keyword">new</span> Packet(h, r, request, response, watchRegistration);</span><br><span class="line">    packet.cb = cb;</span><br><span class="line">    packet.ctx = ctx;</span><br><span class="line">    packet.clientPath = clientPath;</span><br><span class="line">    packet.serverPath = serverPath;</span><br><span class="line">    packet.watchDeregistration = watchDeregistration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!state.isAlive() || closing) &#123;</span><br><span class="line">            conLossPacket(packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (h.getType() == OpCode.closeSession) &#123;</span><br><span class="line">                closing = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            outgoingQueue.<span class="built_in">add</span>(packet); <span class="comment">//添加到outgoingQueue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendThread.getClientCnxnSocket().packetAdded();<span class="comment">//此处是多路复用机制，唤醒Selector，告诉他有数据包添加过来了</span></span><br><span class="line">    <span class="keyword">return</span> packet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ZooKeeper 中，Packet 是一个最小的通信协议单元，即数据包。Pakcet 用于进行客户端与服务端之间的网络传输，任何需要传输的对象都需要包装成一个 Packet 对象。在 ClientCnxn 中 <strong>WatchRegistration</strong> 也会被封装到 Pakcet 中，然后由 SendThread 线程调用queuePacket方法把 Packet 放入发送队列中等待客户端发送，这又是一个异步过程，分布式系统采用异步通信是一个非常常见的手段。</p>
<h3 id="SendThread的发送过程"><a href="#SendThread的发送过程" class="headerlink" title="SendThread的发送过程"></a>SendThread的发送过程</h3><p>在初始化连接的时候，zookeeper初始化了两个线程并且启动了。接下来我们来分析SendThread的发送过程，因为是一个线程，所以启动的时候会调用SendThread.run方法。</p>
<p>run方法中，通过clientCnxnSocket，去拿队列的数据处理。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">clientCnxnSocket</span><span class="selector-class">.doTransport</span>(<span class="selector-tag">to</span>, <span class="selector-tag">pendingQueue</span>, <span class="selector-tag">ClientCnxn</span><span class="selector-class">.this</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">            clientCnxnSocket.introduce(<span class="keyword">this</span>, sessionId, outgoingQueue);</span><br><span class="line">            clientCnxnSocket.updateNow();</span><br><span class="line">            clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            <span class="built_in">int</span> to;</span><br><span class="line">            <span class="keyword">long</span> lastPingRwServer = Time.currentElapsedTime();</span><br><span class="line">            <span class="keyword">final</span> <span class="built_in">int</span> MAX_SEND_PING_INTERVAL = <span class="number">10000</span>; <span class="comment">//10 seconds</span></span><br><span class="line">            <span class="keyword">while</span> (state.isAlive()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!clientCnxnSocket.isConnected()) &#123;<span class="comment">// 如果没有连接：发起连接</span></span><br><span class="line">                        <span class="comment">// don't re-establish connection if we are closing</span></span><br><span class="line">                        <span class="keyword">if</span> (closing) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startConnect(); <span class="comment">//发起连接</span></span><br><span class="line">                        clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (state.isConnected()) &#123; <span class="comment">//如果是连接状态，则处理sasl的认证授权</span></span><br><span class="line">                        <span class="comment">// determine whether we need to send an AuthFailed event.</span></span><br><span class="line">                        <span class="keyword">if</span> (zooKeeperSaslClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="built_in">boolean</span> sendAuthEvent = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    zooKeeperSaslClient.initialize(ClientCnxn.<span class="keyword">this</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (SaslException e) &#123;</span><br><span class="line">                                   LOG.error(<span class="string">"SASL authentication with Zookeeper Quorum member failed: "</span> + e);</span><br><span class="line">                                    state = States.AUTH_FAILED;</span><br><span class="line">                                    sendAuthEvent = <span class="keyword">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            KeeperState authState = zooKeeperSaslClient.getKeeperState();</span><br><span class="line">                            <span class="keyword">if</span> (authState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (authState == KeeperState.AuthFailed) &#123;</span><br><span class="line">                                    <span class="comment">// An authentication error occurred during authentication with the Zookeeper Server.</span></span><br><span class="line">                                    state = States.AUTH_FAILED;</span><br><span class="line">                                    sendAuthEvent = <span class="keyword">true</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (authState == KeeperState.SaslAuthenticated) &#123;</span><br><span class="line">                                        sendAuthEvent = <span class="keyword">true</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (sendAuthEvent == <span class="keyword">true</span>) &#123;</span><br><span class="line">                                eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(</span><br><span class="line">                                      Watcher.Event.EventType.None,</span><br><span class="line">                                      authState,<span class="keyword">null</span>));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        to = readTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        to = connectTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//to,表示客户端距离timeout还剩多少时间，准备发起ping连接</span></span><br><span class="line">                    <span class="keyword">if</span> (to &lt;= <span class="number">0</span>) &#123;<span class="comment">//表示已经超时了。</span></span><br><span class="line">                        <span class="keyword">String</span> warnInfo;</span><br><span class="line">                        warnInfo = <span class="string">"Client session timed out, have not heard from server in "</span></span><br><span class="line">                            + clientCnxnSocket.getIdleRecv()</span><br><span class="line">                            + <span class="string">"ms"</span></span><br><span class="line">                            + <span class="string">" for sessionid 0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId);</span><br><span class="line">                        LOG.warn(warnInfo);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SessionTimeoutException(warnInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state.isConnected()) &#123;</span><br><span class="line">                        <span class="comment">//计算下一次ping请求的时间</span></span><br><span class="line">                        <span class="built_in">int</span> timeToNextPing = readTimeout / <span class="number">2</span> - clientCnxnSocket.getIdleSend() -</span><br><span class="line">                        		((clientCnxnSocket.getIdleSend() &gt; <span class="number">1000</span>) ? <span class="number">1000</span> : <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">//send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL</span></span><br><span class="line">                        <span class="keyword">if</span> (timeToNextPing &lt;= <span class="number">0</span> || clientCnxnSocket.getIdleSend() &gt; MAX_SEND_PING_INTERVAL) &#123;</span><br><span class="line">                            sendPing(); <span class="comment">//发送ping请求</span></span><br><span class="line">                            clientCnxnSocket.updateLastSend();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (timeToNextPing &lt; to) &#123;</span><br><span class="line">                                to = timeToNextPing;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If we are in read-only mode, seek for read/write server</span></span><br><span class="line">                    <span class="keyword">if</span> (state == States.CONNECTEDREADONLY) &#123;</span><br><span class="line">                        <span class="keyword">long</span> now = Time.currentElapsedTime();</span><br><span class="line">                        <span class="built_in">int</span> idlePingRwServer = (<span class="built_in">int</span>) (now - lastPingRwServer);</span><br><span class="line">                        <span class="keyword">if</span> (idlePingRwServer &gt;= pingRwTimeout) &#123;</span><br><span class="line">                            lastPingRwServer = now;</span><br><span class="line">                            idlePingRwServer = <span class="number">0</span>;</span><br><span class="line">                            pingRwTimeout =</span><br><span class="line">                                Math.<span class="built_in">min</span>(<span class="number">2</span>*pingRwTimeout, maxPingRwTimeout);</span><br><span class="line">                            pingRwServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                        to = Math.<span class="built_in">min</span>(to, pingRwTimeout - idlePingRwServer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    调用clientCnxnSocket，发起传输</span><br><span class="line">                    其中 pendingQueue是一个用来存放已经发送、等待回应的Packet队列，</span><br><span class="line">clientCnxnSocket默认使用ClientCnxnSocketNIO（ps：还记得在哪里初始化吗？在实例化zookeeper的时候）</span><br><span class="line">                    clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (closing) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                            <span class="comment">// closing so this is expected</span></span><br><span class="line">                            LOG.debug(<span class="string">"An exception was thrown while closing send thread for session 0x"</span></span><br><span class="line">                                    + Long.toHexString(getSessionId())</span><br><span class="line">                                    + <span class="string">" : "</span> + e.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// this is ugly, you have a better way speak up</span></span><br><span class="line">                        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SessionExpiredException) &#123;</span><br><span class="line">                            LOG.info(e.getMessage() + <span class="string">", closing socket connection"</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SessionTimeoutException) &#123;</span><br><span class="line">                            LOG.info(e.getMessage() + RETRY_CONN_MSG);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> EndOfStreamException) &#123;</span><br><span class="line">                            LOG.info(e.getMessage() + RETRY_CONN_MSG);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RWServerFoundException) &#123;</span><br><span class="line">                            LOG.info(e.getMessage());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            LOG.warn(</span><br><span class="line">                                    <span class="string">"Session 0x"</span></span><br><span class="line">                                            + Long.toHexString(getSessionId())</span><br><span class="line">                                            + <span class="string">" for server "</span></span><br><span class="line">                                            + clientCnxnSocket.getRemoteSocketAddress()</span><br><span class="line">                                            + <span class="string">", unexpected error"</span></span><br><span class="line">                                            + RETRY_CONN_MSG, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// At this point, there might still be new packets appended to outgoingQueue.</span></span><br><span class="line">                        <span class="comment">// they will be handled in next connection or cleared up if closed.</span></span><br><span class="line">                        cleanup();</span><br><span class="line">                        <span class="keyword">if</span> (state.isAlive()) &#123;</span><br><span class="line">                            eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(</span><br><span class="line">                                    Event.EventType.None,</span><br><span class="line">                                    Event.KeeperState.Disconnected,</span><br><span class="line">                                    <span class="keyword">null</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        clientCnxnSocket.updateNow();</span><br><span class="line">                        clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">                <span class="comment">// When it comes to this point, it guarantees that later queued</span></span><br><span class="line">                <span class="comment">// packet to outgoingQueue will be notified of death.</span></span><br><span class="line">                cleanup();</span><br><span class="line">            &#125;</span><br><span class="line">            clientCnxnSocket.close();</span><br><span class="line">            <span class="keyword">if</span> (state.isAlive()) &#123;</span><br><span class="line">                eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(Event.EventType.None,</span><br><span class="line">                        Event.KeeperState.Disconnected, <span class="keyword">null</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),</span><br><span class="line">                    <span class="string">"SendThread exited loop for session: 0x"</span></span><br><span class="line">                           + Long.toHexString(getSessionId()));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="client-和-server的网络交互"><a href="#client-和-server的网络交互" class="headerlink" title="client 和 server的网络交互"></a>client 和 server的网络交互</h3><p><code>doTransport</code>有两种实现，一种<code>java nio</code>，另一种是<code>netty</code></p>
<p>这里就是sendThread的run方法，发送数据的具体代码。pendingQueue表示处于已经发送过等待响应的packet队列。outgoingQueue为待发送的数据包队列。这里先从<code>outgoingQueue.poll</code>出一个package，准备发送。再调用<code>doWrite(pendingQueue, head, cnxn)</code>放入pendingQueue中，等待server的响应。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> doTransport(<span class="built_in">int</span> waitTimeOut, <span class="built_in">List</span>&lt;Packet&gt; pendingQueue, ClientCnxn cnxn) throws IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!firstConnect.<span class="keyword">await</span>(waitTimeOut, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Packet head = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (needSasl.<span class="keyword">get</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!waitSasl.tryAcquire(waitTimeOut, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//判断outgoingQueue是否存在待发送的数据包，不存在则直接返回</span></span><br><span class="line">                <span class="keyword">if</span> ((head = outgoingQueue.poll(waitTimeOut, TimeUnit.MILLISECONDS)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check if being waken up on closing.</span></span><br><span class="line">            <span class="keyword">if</span> (!sendThread.getZkState().isAlive()) &#123;</span><br><span class="line">                <span class="comment">// adding back the patck to notify of failure in conLossPacket().</span></span><br><span class="line">                addBack(head);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// channel disconnection happened</span></span><br><span class="line">            <span class="keyword">if</span> (disconnected.<span class="keyword">get</span>()) &#123; <span class="comment">//异常流程，channel关闭了，讲当前的packet添加到addBack中</span></span><br><span class="line">                addBack(head);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(<span class="string">"channel for sessionid 0x"</span></span><br><span class="line">                        + Long.toHexString(sessionId)</span><br><span class="line">                        + <span class="string">" is lost"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123; <span class="comment">//如果当前存在需要发送的数据包，则调用doWrite方法，pendingQueue表示处于已经发送过等待响应的packet队列</span></span><br><span class="line">                doWrite(pendingQueue, head, cnxn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            updateNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="DoWrite方法"><a href="#DoWrite方法" class="headerlink" title="DoWrite方法"></a>DoWrite方法</h4><p>将当前的packet添加到pendingQueue队列中</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span>(<span class="params">List&lt;Packet&gt; pendingQueue, Packet p, ClientCnxn cnxn</span>) </span>&#123;</span><br><span class="line">    updateNow();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != WakeupPacket.getInstance()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p.requestHeader != <span class="literal">null</span>) &amp;&amp; <span class="comment">//判断请求头以及判断当前请求类型不是ping或者auth操作</span></span><br><span class="line">                    (p.requestHeader.getType() != ZooDefs.OpCode.ping) &amp;&amp;</span><br><span class="line">                    (p.requestHeader.getType() != ZooDefs.OpCode.auth)) &#123;</span><br><span class="line">                p.requestHeader.setXid(cnxn.getXid());  <span class="comment">//设置xid，这个xid用来区分请求类型</span></span><br><span class="line">                synchronized (pendingQueue) &#123;</span><br><span class="line">                    pendingQueue.<span class="keyword">add</span>(p); <span class="comment">//将当前的packet添加到pendingQueue队列中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sendPkt(p); <span class="comment">//将数据包发送出去</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outgoingQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = outgoingQueue.<span class="keyword">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sendPkt"><a href="#sendPkt" class="headerlink" title="sendPkt"></a>sendPkt</h4><p>通过nio channel发送字节缓存到服务端</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">private</span> <span class="selector-tag">void</span> <span class="selector-tag">sendPkt</span>(Packet p) &#123;</span><br><span class="line">     <span class="comment">// Assuming the packet will be sent out successfully. Because if it fails,</span></span><br><span class="line">     <span class="comment">// the channel will close and clean up queues.</span></span><br><span class="line">     <span class="selector-tag">p</span><span class="selector-class">.createBB</span>(); <span class="comment">//序列化请求数据</span></span><br><span class="line">     <span class="selector-tag">updateLastSend</span>(); <span class="comment">//更新最后一次发送updateLastSend</span></span><br><span class="line">     <span class="selector-tag">sentCount</span>++; <span class="comment">//更新发送次数</span></span><br><span class="line">     <span class="selector-tag">channel</span><span class="selector-class">.write</span>(ChannelBuffers.wrappedBuffer(p.bb)); <span class="comment">//通过nio channel发送字节缓存到服务端</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="createBB"><a href="#createBB" class="headerlink" title="createBB"></a>createBB</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> void createBB() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">ByteArrayOutputStream </span><span class="keyword">baos </span>= new <span class="keyword">ByteArrayOutputStream();</span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">BinaryOutputArchive </span><span class="keyword">boa </span>= <span class="keyword">BinaryOutputArchive.getArchive(baos);</span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">boa.writeInt(-1, </span><span class="string">"len"</span>)<span class="comment">; // We'll fill this in later</span></span><br><span class="line">                <span class="meta">if</span> (requestHeader != null) &#123;</span><br><span class="line">                    requestHeader.serialize(<span class="keyword">boa, </span><span class="string">"header"</span>)<span class="comment">; //序列化header头(requestHeader)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">if</span> (request instanceof ConnectRequest) &#123;</span><br><span class="line">                    request.serialize(<span class="keyword">boa, </span><span class="string">"connect"</span>)<span class="comment">;</span></span><br><span class="line">                    // append <span class="string">"am-I-allowed-to-be-readonly"</span> flag</span><br><span class="line">                    <span class="keyword">boa.writeBool(readOnly, </span><span class="string">"readOnly"</span>)<span class="comment">;</span></span><br><span class="line">                &#125; <span class="meta">else</span> <span class="meta">if</span> (request != null) &#123;</span><br><span class="line">                    request.serialize(<span class="keyword">boa, </span><span class="string">"request"</span>)<span class="comment">; //序列化request(request)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">baos.close();</span></span><br><span class="line"><span class="keyword"> </span>               this.<span class="keyword">bb </span>= <span class="keyword">ByteBuffer.wrap(baos.toByteArray());</span></span><br><span class="line"><span class="keyword"> </span>               this.<span class="keyword">bb.putInt(this.bb.capacity() </span>- <span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">                this.<span class="keyword">bb.rewind();</span></span><br><span class="line"><span class="keyword"> </span>           &#125; catch (IOException e) &#123;</span><br><span class="line">                LOG.warn(<span class="string">"Ignoring unexpected exception"</span>, e)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>从createBB方法中，我们看到在底层实际的网络传输序列化中，zookeeper只会讲requestHeader和request两个属性进行序列化，即只有这两个会被序列化到底层字节数组中去进行网络传输，不会将watchRegistration相关的信息进行网络传输。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用户调用exists注册监听以后，会做几个事情</p>
<ol>
<li><p>讲请求数据封装为packet，添加到outgoingQueue</p>
</li>
<li><p>SendThread这个线程会执行数据发送操作，主要是将outgoingQueue队列中的数据发送到服务端</p>
</li>
<li><p>通过clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this); 其中ClientCnxnSocket只zookeeper客户端和服务端的连接通信的封装，有两个具体的实现类ClientCnxnSocketNetty和ClientCnxnSocketNIO;具体使用哪一个类来实现发送，是在初始化过程是在实例化Zookeeper的时候设置的，代码如下</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cnxn = <span class="keyword">new</span>   <span class="type">ClientCnxn</span>(connectStringParser.getChrootPath(),                   hostProvider, sessionTimeout,   <span class="built_in">this</span>, watchManager,                   getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClientCnxnSocket getClientCnxnSocket() throws IOException &#123;</span><br><span class="line">        <span class="keyword">String</span> clientCnxnSocketName = getClientConfig().getProperty(</span><br><span class="line">                ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);</span><br><span class="line">        <span class="keyword">if</span> (clientCnxnSocketName == <span class="literal">null</span>) &#123;</span><br><span class="line">            clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; clientCxnConstructor = Class.forName(clientCnxnSocketName).getDeclaredConstructor(ZKClientConfig.class);</span><br><span class="line">            ClientCnxnSocket clientCxnSocket = (ClientCnxnSocket) clientCxnConstructor.<span class="keyword">new</span><span class="type">Instance</span>(getClientConfig());</span><br><span class="line">            <span class="keyword">return</span> clientCxnSocket;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            IOException ioe = <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">"Couldn't instantiate "</span></span><br><span class="line">                    + clientCnxnSocketName);</span><br><span class="line">            ioe.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ioe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于第3步，最终会在ClientCnxnSocketNetty方法中执行sendPkt将请求的数据包发送到服务端</p>
</li>
</ol>
<h1 id="服务端接收请求处理流程"><a href="#服务端接收请求处理流程" class="headerlink" title="服务端接收请求处理流程"></a>服务端接收请求处理流程</h1><p>服务端有一个NettyServerCnxn类，用来处理客户端发送过来的请求。</p>
<p>通过<code>zks.processPacket(this, bb)</code>处理客户端传过来的数据包。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public void receiveMessage(ChannelBuffer message) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">while</span>(message.readable() &amp;&amp; !throttled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bb != <span class="built_in">null</span>) &#123; <span class="comment">//ByteBuffer不为空</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">LOG</span>.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(<span class="string">"message readable "</span> + message.readableBytes()</span><br><span class="line">                                + <span class="string">" bb len "</span> + bb.remaining() + <span class="string">" "</span> + bb);</span><br><span class="line">                        ByteBuffer dat = bb.duplicate();</span><br><span class="line">                        dat.flip();</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(Long.toHexString(sessionId)</span><br><span class="line">                                + <span class="string">" bb 0x"</span></span><br><span class="line">                                + ChannelBuffers.hexDump(</span><br><span class="line">                                        ChannelBuffers.copiedBuffer(dat)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//bb剩余空间大于message中可读字节大小</span></span><br><span class="line">                    <span class="keyword">if</span> (bb.remaining() &gt; message.readableBytes()) &#123;</span><br><span class="line">                        int newLimit = bb.position() + message.readableBytes();</span><br><span class="line">                        bb.limit(newLimit);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将message写入bb中</span></span><br><span class="line">                    message.readBytes(bb);</span><br><span class="line">                    bb.limit(bb.capacity());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">LOG</span>.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(<span class="string">"after readBytes message readable "</span></span><br><span class="line">                                + message.readableBytes()</span><br><span class="line">                                + <span class="string">" bb len "</span> + bb.remaining() + <span class="string">" "</span> + bb);</span><br><span class="line">                        ByteBuffer dat = bb.duplicate();</span><br><span class="line">                        dat.flip();</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(<span class="string">"after readbytes "</span></span><br><span class="line">                                + Long.toHexString(sessionId)</span><br><span class="line">                                + <span class="string">" bb 0x"</span></span><br><span class="line">                                + ChannelBuffers.hexDump(</span><br><span class="line">                                        ChannelBuffers.copiedBuffer(dat)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (bb.remaining() == <span class="number">0</span>) &#123; <span class="comment">// 已经读完message，表示内容已经全部接收</span></span><br><span class="line">                        packetReceived(); <span class="comment">// 统计接收信息</span></span><br><span class="line">                        bb.flip();</span><br><span class="line"></span><br><span class="line">                        ZooKeeperServer zks = this.zkServer;</span><br><span class="line">                        <span class="keyword">if</span> (zks == <span class="built_in">null</span> || !zks.isRunning()) &#123;<span class="comment">//Zookeeper服务器为空 ,说明服务端挂了</span></span><br><span class="line">                            throw <span class="keyword">new</span> IOException(<span class="string">"ZK down"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">                            <span class="comment">//处理客户端传过来的数据包</span></span><br><span class="line">                            zks.processPacket(this, bb);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (zks.shouldThrottle(outstandingCount.incrementAndGet())) &#123;</span><br><span class="line">                                disableRecvNoWait();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"got conn req request from "</span></span><br><span class="line">                                    + getRemoteSocketAddress());</span><br><span class="line">                            zks.processConnectRequest(this, bb);</span><br><span class="line">                            initialized = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        bb = <span class="built_in">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//bb为null的情况，大家自己去看，我就不细讲了</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">LOG</span>.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(<span class="string">"message readable "</span></span><br><span class="line">                                + message.readableBytes()</span><br><span class="line">                                + <span class="string">" bblenrem "</span> + bbLen.remaining());</span><br><span class="line">                        ByteBuffer dat = bbLen.duplicate();</span><br><span class="line">                        dat.flip();</span><br><span class="line">                        <span class="built_in">LOG</span>.<span class="keyword">trace</span>(Long.toHexString(sessionId)</span><br><span class="line">                                + <span class="string">" bbLen 0x"</span></span><br><span class="line">                                + ChannelBuffers.hexDump(</span><br><span class="line">                                        ChannelBuffers.copiedBuffer(dat)));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (message.readableBytes() &lt; bbLen.remaining()) &#123;</span><br><span class="line">                        bbLen.limit(bbLen.position() + message.readableBytes());</span><br><span class="line">                    &#125;</span><br><span class="line">                    message.readBytes(bbLen);</span><br><span class="line">                    bbLen.limit(bbLen.capacity());</span><br><span class="line">                    <span class="keyword">if</span> (bbLen.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">                        bbLen.flip();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">LOG</span>.isTraceEnabled()) &#123;</span><br><span class="line">                            <span class="built_in">LOG</span>.<span class="keyword">trace</span>(Long.toHexString(sessionId)</span><br><span class="line">                                    + <span class="string">" bbLen 0x"</span></span><br><span class="line">                                    + ChannelBuffers.hexDump(</span><br><span class="line">                                            ChannelBuffers.copiedBuffer(bbLen)));</span><br><span class="line">                        &#125;</span><br><span class="line">                        int len = bbLen.getInt();</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">LOG</span>.isTraceEnabled()) &#123;</span><br><span class="line">                            <span class="built_in">LOG</span>.<span class="keyword">trace</span>(Long.toHexString(sessionId)</span><br><span class="line">                                    + <span class="string">" bbLen len is "</span> + len);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        bbLen.<span class="keyword">clear</span>();</span><br><span class="line">                        <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (checkFourLetterWord(channel, message, len)) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (len &lt; <span class="number">0</span> || len &gt; BinaryInputArchive.maxBuffer) &#123;</span><br><span class="line">                            throw <span class="keyword">new</span> IOException(<span class="string">"Len error "</span> + len);</span><br><span class="line">                        &#125;</span><br><span class="line">                        bb = ByteBuffer.allocate(len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(IOException e) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>.warn(<span class="string">"Closing connection to "</span> + getRemoteSocketAddress(), e);</span><br><span class="line">            <span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="NettyServerCnxn"><a href="#NettyServerCnxn" class="headerlink" title="NettyServerCnxn"></a>NettyServerCnxn</h2><h2 id="ZookeeperServer-zks-processPacket-this-bb"><a href="#ZookeeperServer-zks-processPacket-this-bb" class="headerlink" title="ZookeeperServer-zks.processPacket(this, bb);"></a>ZookeeperServer-zks.processPacket(this, bb);</h2><p>处理客户端传送过来的数据包，封装请求对象，并发送。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request si = new Request(<span class="name">cnxn</span>, cnxn.getSessionId(), h.getXid(),</span><br><span class="line">                  h.getType(), incomingBuffer, cnxn.getAuthInfo())<span class="comment">;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">        <span class="comment">// We have the request, now process and setup for next</span></span><br><span class="line">        InputStream bais = <span class="keyword">new</span> ByteBufferInputStream(incomingBuffer);</span><br><span class="line">        BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);</span><br><span class="line">        RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">        h.deserialize(bia, <span class="string">"header"</span>); <span class="comment">//反序列化客户端header头信息</span></span><br><span class="line">        <span class="comment">// Through the magic of byte buffers, txn will not be</span></span><br><span class="line">        <span class="comment">// pointing</span></span><br><span class="line">        <span class="comment">// to the start of the txn</span></span><br><span class="line">        incomingBuffer = incomingBuffer.slice();</span><br><span class="line">        <span class="keyword">if</span> (h.getType() == OpCode.auth) &#123; <span class="comment">//判断当前操作类型，如果是auth操作，则执行下面的代码</span></span><br><span class="line">            <span class="built_in">LOG</span>.info(<span class="string">"got auth packet "</span> + cnxn.getRemoteSocketAddress());</span><br><span class="line">            AuthPacket authPacket = <span class="keyword">new</span> AuthPacket();</span><br><span class="line">            ByteBufferInputStream.byteBuffer2Record(incomingBuffer, authPacket);</span><br><span class="line">            <span class="keyword">String</span> scheme = authPacket.getScheme();</span><br><span class="line">            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);</span><br><span class="line">            <span class="built_in">Code</span> authReturn = KeeperException.<span class="built_in">Code</span>.AUTHFAILED;</span><br><span class="line">            <span class="keyword">if</span>(ap != <span class="built_in">null</span>) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    authReturn = ap.handleAuthentication(<span class="keyword">new</span> ServerAuthenticationProvider.ServerObjs(this, cnxn), authPacket.getAuth());</span><br><span class="line">                &#125; catch(RuntimeException e) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.warn(<span class="string">"Caught runtime exception from AuthenticationProvider: "</span> + scheme + <span class="string">" due to "</span> + e);</span><br><span class="line">                    authReturn = KeeperException.<span class="built_in">Code</span>.AUTHFAILED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (authReturn == KeeperException.<span class="built_in">Code</span>.OK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Authentication succeeded for scheme: "</span> + scheme);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">LOG</span>.info(<span class="string">"auth success "</span> + cnxn.getRemoteSocketAddress());</span><br><span class="line">                ReplyHeader rh = <span class="keyword">new</span> ReplyHeader(h.getXid(), <span class="number">0</span>,</span><br><span class="line">                        KeeperException.<span class="built_in">Code</span>.OK.intValue());</span><br><span class="line">                cnxn.sendResponse(rh, <span class="built_in">null</span>, <span class="built_in">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ap == <span class="built_in">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.warn(<span class="string">"No authentication provider for scheme: "</span></span><br><span class="line">                            + scheme + <span class="string">" has "</span></span><br><span class="line">                            + ProviderRegistry.listProviders());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.warn(<span class="string">"Authentication failed for scheme: "</span> + scheme);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// send a response...</span></span><br><span class="line">                ReplyHeader rh = <span class="keyword">new</span> ReplyHeader(h.getXid(), <span class="number">0</span>,</span><br><span class="line">                        KeeperException.<span class="built_in">Code</span>.AUTHFAILED.intValue());</span><br><span class="line">                cnxn.sendResponse(rh, <span class="built_in">null</span>, <span class="built_in">null</span>);</span><br><span class="line">                <span class="comment">// ... and close connection</span></span><br><span class="line">                cnxn.sendBuffer(ServerCnxnFactory.closeConn);</span><br><span class="line">                cnxn.disableRecv();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不是授权操作，再判断是否为sasl操作</span></span><br><span class="line">            <span class="keyword">if</span> (h.getType() == OpCode.sasl) &#123;</span><br><span class="line">                Record rsp = processSasl(incomingBuffer,cnxn);</span><br><span class="line">                ReplyHeader rh = <span class="keyword">new</span> ReplyHeader(h.getXid(), <span class="number">0</span>, KeeperException.<span class="built_in">Code</span>.OK.intValue());</span><br><span class="line">                cnxn.sendResponse(rh,rsp, <span class="string">"response"</span>); <span class="comment">// not sure about 3rd arg..what is it?</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//最终进入这个代码块进行处理</span></span><br><span class="line">                <span class="comment">//封装请求对象</span></span><br><span class="line">                Request si = <span class="keyword">new</span> Request(cnxn, cnxn.getSessionId(), h.getXid(),</span><br><span class="line">                  h.getType(), incomingBuffer, cnxn.getAuthInfo());</span><br><span class="line">                si.setOwner(ServerCnxn.me);</span><br><span class="line">                <span class="comment">// Always treat packet from the client as a possible</span></span><br><span class="line">                <span class="comment">// local request.</span></span><br><span class="line">                setLocalSessionFlag(si);</span><br><span class="line">                submitRequest(si); <span class="comment">//提交请求</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnxn.incrOutstandingRequests(h);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="submitRequest"><a href="#submitRequest" class="headerlink" title="submitRequest"></a>submitRequest</h2><p>负责在服务端提交当前请求</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">(Request si)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span>) &#123; <span class="comment">//processor处理器，request过来以后会经历一系列处理器的处理过程</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Since all requests are passed to the request</span></span><br><span class="line">                    <span class="comment">// processor it should wait for setting up the request</span></span><br><span class="line">                    <span class="comment">// processor chain. The state will be updated to RUNNING</span></span><br><span class="line">                    <span class="comment">// after the setup.</span></span><br><span class="line">                    <span class="keyword">while</span> (state == State.INITIAL) &#123;</span><br><span class="line">                        wait(<span class="number">1000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">"Unexpected interruption"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span> || state != State.RUNNING) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not started"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            touch(si.cnxn);</span><br><span class="line">            <span class="keyword">boolean</span> validpacket = Request.isValid(si.type); <span class="comment">//判断是否合法</span></span><br><span class="line">            <span class="keyword">if</span> (validpacket) &#123;</span><br><span class="line">                firstProcessor.processRequest(si);  调用firstProcessor发起请求，而这个firstProcess是一个接口，有多个实现类，具体的调用链是怎么样的？往下看吧</span><br><span class="line">                <span class="keyword">if</span> (si.cnxn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    incInProcess();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG.warn(<span class="string">"Received packet at server of unknown type "</span> + si.type);</span><br><span class="line">                <span class="keyword">new</span> UnimplementedRequestProcessor().processRequest(si);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MissingSessionException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                LOG.debug(<span class="string">"Dropping request: "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</span><br><span class="line">            LOG.<span class="keyword">error</span>(<span class="string">"Unable to process request:"</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="firstProcessor的请求链组成"><a href="#firstProcessor的请求链组成" class="headerlink" title="firstProcessor的请求链组成"></a>firstProcessor的请求链组成</h3><ol>
<li>firstProcessor的初始化是在ZookeeperServer的setupRequestProcessor中完成的，代码如下</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</span><br><span class="line">        RequestProcessor syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>, finalProcessor);</span><br><span class="line">        ((SyncRequestProcessor)syncProcessor).start();</span><br><span class="line">        firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, syncProcessor);<span class="comment">//需要注意的是，PrepRequestProcessor中传递的是一个syncProcessor</span></span><br><span class="line">        ((PrepRequestProcessor)firstProcessor).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看到firstProcessor的实例是一个PrepRequestProcessor，而这个构造方法中又传递了一个Processor构成了一个调用链。</p>
<p>RequestProcessor syncProcessor = new SyncRequestProcessor(this, finalProcessor);</p>
<p>而syncProcessor的构造方法传递的又是一个Processor，对应的是FinalRequestProcessor</p>
<ol>
<li>所以整个调用链是PrepRequestProcessor -&gt; SyncRequestProcessor -&gt;FinalRequestProcessor</li>
</ol>
<h2 id="PredRequestProcessor-processRequest-si"><a href="#PredRequestProcessor-processRequest-si" class="headerlink" title="PredRequestProcessor.processRequest(si);"></a>PredRequestProcessor.processRequest(si);</h2><p>通过上面了解到调用链关系以后，我们继续再看firstProcessor.processRequest(si)； 会调用到PrepRequestProcessor</p>
<p>唉，很奇怪，processRequest只是把request添加到submittedRequests中，根据前面的经验，很自然的想到这里又是一个异步操作。而subittedRequests又是一个阻塞队列</p>
<p><code>LinkedBlockingQueue&lt;Request&gt; submittedRequests = new LinkedBlockingQueue&lt;Request&gt;();</code></p>
<p>而PrepRequestProcessor这个类又继承了线程类，因此我们直接找到当前类中的<code>run</code>方法如下</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Request request = submittedRequests.take(); <span class="comment">//ok，从队列中拿到请求进行处理</span></span><br><span class="line">                <span class="keyword">long</span> traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">                <span class="keyword">if</span> (request.type == OpCode.ping) &#123;</span><br><span class="line">                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                    ZooTrace.logRequest(LOG, traceMask, <span class="string">'P'</span>, request, <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Request.requestOfDeath == request) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pRequest(request); <span class="comment">//调用pRequest进行预处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> XidRolloverException) &#123;</span><br><span class="line">                LOG.info(e.getCause().getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            handleException(<span class="keyword">this</span>.getName(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            handleException(<span class="keyword">this</span>.getName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">"PrepRequestProcessor exited loop!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="pRequest"><a href="#pRequest" class="headerlink" title="pRequest"></a>pRequest</h3><p>预处理这块的代码太长，就不好贴了。前面的N行代码都是根据当前的OP类型进行判断和做相应的处理，在这个方法中的最后一行中，我们会看到如下代码</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextProcessor.processRequest(request)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>很显然，nextProcessor对应的应该是SyncRequestProcessor</p>
<h2 id="SyncRequestProcessor-processRequest"><a href="#SyncRequestProcessor-processRequest" class="headerlink" title="SyncRequestProcessor. processRequest"></a>SyncRequestProcessor. processRequest</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span>(<span class="params">Request request</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// request.addRQRec("&gt;sync");</span></span><br><span class="line">        queuedRequests.<span class="keyword">add</span>(request);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 这个方法的代码也是一样，基于异步化的操作，把请求添加到queuedRequets中，那么我们继续在当前类找到run方法</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> logCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we do this in an attempt to ensure that not all of the servers</span></span><br><span class="line">            <span class="comment">// in the ensemble take a snapshot at the same time</span></span><br><span class="line">            <span class="built_in">int</span> randRoll = r.nextInt(snapCount/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Request si = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//从阻塞队列中获取请求</span></span><br><span class="line">                <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</span><br><span class="line">                    si = queuedRequests.take();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    si = queuedRequests.poll();</span><br><span class="line">                    <span class="keyword">if</span> (si == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        flush(toFlush);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (si == requestOfDeath) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// track the number of records written to the log</span></span><br><span class="line">                    <span class="comment">//下面这块代码，粗略看来是触发快照操作，启动一个处理快照的线程</span></span><br><span class="line">                    <span class="keyword">if</span> (zks.getZKDatabase().<span class="built_in">append</span>(si)) &#123;</span><br><span class="line">                        logCount++;</span><br><span class="line">                        <span class="keyword">if</span> (logCount &gt; (snapCount / <span class="number">2</span> + randRoll)) &#123;</span><br><span class="line">                            randRoll = r.nextInt(snapCount/<span class="number">2</span>);</span><br><span class="line">                            <span class="comment">// roll the log</span></span><br><span class="line">                            zks.getZKDatabase().rollLog();</span><br><span class="line">                            <span class="comment">// take a snapshot</span></span><br><span class="line">                            <span class="keyword">if</span> (snapInProcess != <span class="keyword">null</span> &amp;&amp; snapInProcess.isAlive()) &#123;</span><br><span class="line">                                LOG.warn(<span class="string">"Too busy to snap, skipping"</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                snapInProcess = <span class="keyword">new</span> ZooKeeperThread(<span class="string">"Snapshot Thread"</span>) &#123;</span><br><span class="line">                                        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                                zks.takeSnapshot();</span><br><span class="line">                                            &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                                                LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;;</span><br><span class="line">                                snapInProcess.start();</span><br><span class="line">                            &#125;</span><br><span class="line">                            logCount = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// optimization for read heavy workloads</span></span><br><span class="line">                        <span class="comment">// iff this is a read, and there are no pending</span></span><br><span class="line">                        <span class="comment">// flushes (writes), then just pass this to the next</span></span><br><span class="line">                        <span class="comment">// processor</span></span><br><span class="line">                        <span class="keyword">if</span> (nextProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            nextProcessor.processRequest(si); <span class="comment">//继续调用下一个处理器来处理请求</span></span><br><span class="line">                            <span class="keyword">if</span> (nextProcessor <span class="keyword">instanceof</span> Flushable) &#123;</span><br><span class="line">                                ((Flushable)nextProcessor).flush();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    toFlush.<span class="built_in">add</span>(si);</span><br><span class="line">                    <span class="keyword">if</span> (toFlush.<span class="built_in">size</span>() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                        flush(toFlush);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleException(<span class="keyword">this</span>.getName(), t);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">"SyncRequestProcessor exited!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="FinalRequestProcessor-processRequest"><a href="#FinalRequestProcessor-processRequest" class="headerlink" title="FinalRequestProcessor. processRequest"></a>FinalRequestProcessor. processRequest</h2><p>这个方法就是我们在课堂上分析到的方法了，FinalRequestProcessor.processRequest方法并根据Request对象中的操作更新内存中Session信息或者znode数据。</p>
<p>这块代码有小300多行，就不全部贴出来了，我们直接定位到关键代码，根据客户端的OP类型找到如下的代码</p>
 <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">case</span> OpCode.exists: <span class="type"></span>&#123;</span><br><span class="line">                lastOp = <span class="string">"EXIS"</span>;</span><br><span class="line">                <span class="comment">// TODO we need to figure out the security requirement for this!</span></span><br><span class="line">                ExistsRequest existsRequest = <span class="keyword">new</span> <span class="type">ExistsRequest</span>();</span><br><span class="line">                <span class="comment">//反序列化  (将ByteBuffer反序列化成为ExitsRequest.这个就是我们在客户端发起请求的时候传递过来的Request对象</span></span><br><span class="line">                ByteBufferInputStream.byteBuffer2Record(request.request,</span><br><span class="line">                        existsRequest);</span><br><span class="line">                <span class="keyword">String</span> path = existsRequest.getPath(); <span class="comment">//得到请求的路径</span></span><br><span class="line">                <span class="keyword">if</span> (path.indexOf(<span class="string">'\0'</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KeeperException</span>.BadArgumentsException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//终于找到一个很关键的代码，判断请求的getWatch是否存在，如果存在，则传递cnxn（servercnxn）</span></span><br><span class="line"><span class="comment">//对于exists请求，需要监听data变化事件，添加watcher</span></span><br><span class="line">                Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : <span class="type">null</span>);</span><br><span class="line">                rsp = <span class="keyword">new</span> <span class="type">ExistsResponse</span>(stat); <span class="comment">//在服务端内存数据库中根据路径得到结果进行组装，设置为ExistsResponse</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h2 id="statNode这个方法做了什么？"><a href="#statNode这个方法做了什么？" class="headerlink" title="statNode这个方法做了什么？"></a>statNode这个方法做了什么？</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stat statNode(String path, ServerCnxn serverCnxn) <span class="keyword">throws</span> KeeperException.NoNodeException &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> dataTree.<span class="title">statNode</span><span class="params">(path, serverCnxn)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一路向下，在下面这个方法中，讲ServerCnxn向上转型为Watcher了。 因为ServerCnxn实现了Watcher接口</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stat statNode(<span class="keyword">String</span> path, Watcher watcher)</span><br><span class="line">            throws KeeperException.NoNodeException &#123;</span><br><span class="line">        Stat stat = <span class="keyword">new</span> <span class="type">Stat</span>();</span><br><span class="line">        DataNode n = nodes.<span class="keyword">get</span>(path); <span class="comment">//获得节点数据</span></span><br><span class="line">        <span class="keyword">if</span> (watcher != <span class="literal">null</span>) &#123; <span class="comment">//如果watcher不为空，则讲当前的watcher和path进行绑定</span></span><br><span class="line">            dataWatches.addWatch(path, watcher);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KeeperException</span>.NoNodeException();</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (n) &#123;</span><br><span class="line">            n.copyStat(stat);</span><br><span class="line">            <span class="keyword">return</span> stat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="WatchManager-addWatch-path-watcher"><a href="#WatchManager-addWatch-path-watcher" class="headerlink" title="WatchManager.addWatch(path, watcher);"></a>WatchManager.addWatch(path, watcher);</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">synchronized <span class="literal">void</span> addWatch(<span class="built_in">String</span> path, Watcher watcher) &#123;</span><br><span class="line">        HashSet&lt;Watcher&gt; <span class="built_in">list</span> = watchTable.get(path);  <span class="comment">//判断watcherTable中是否存在当前路径对应的watcher</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="built_in">null</span>) &#123; <span class="comment">//不存在则主动添加</span></span><br><span class="line">            <span class="comment">// don't waste memory if there are few watches on a node</span></span><br><span class="line">            <span class="comment">// rehash when the 4th entry is added, doubling size thereafter</span></span><br><span class="line">            <span class="comment">// seems like a good compromise</span></span><br><span class="line">            <span class="built_in">list</span> = <span class="literal">new</span> HashSet&lt;Watcher&gt;(<span class="number">4</span>); <span class="comment">// 新生成watcher集合</span></span><br><span class="line">            watchTable.put(path, <span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>.add(watcher); <span class="comment">//添加到watcher表</span></span><br><span class="line"></span><br><span class="line">        HashSet&lt;<span class="built_in">String</span>&gt; paths = watch2Paths.get(watcher);</span><br><span class="line">        <span class="keyword">if</span> (paths == <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="comment">// cnxns typically have many watches, so use default cap here</span></span><br><span class="line">            paths = <span class="literal">new</span> HashSet&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">            watch2Paths.put(watcher, paths); <span class="comment">// 设置watcher到节点路径的映射</span></span><br><span class="line">        &#125;</span><br><span class="line">        paths.add(path);  <span class="comment">// 将路径添加至paths集合</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其大致流程如下</p>
<p>　　① 通过传入的path（节点路径）从watchTable获取相应的watcher集合，进入②</p>
<p>　　② 判断①中的watcher是否为空，若为空，则进入③，否则，进入④</p>
<p>　　③ 新生成watcher集合，并将路径path和此集合添加至watchTable中，进入④</p>
<p>　　④ 将传入的watcher添加至watcher集合，即完成了path和watcher添加至watchTable的步骤，进入⑤</p>
<p>　　⑤ 通过传入的watcher从watch2Paths中获取相应的path集合，进入⑥</p>
<p>　　⑥ 判断path集合是否为空，若为空，则进入⑦，否则，进入⑧</p>
<p>　　⑦ 新生成path集合，并将watcher和paths添加至watch2Paths中，进入⑧</p>
<p>　　⑧ 将传入的path（节点路径）添加至path集合，即完成了path和watcher添加至watch2Paths的步骤</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>调用关系链如下</p>
<p>NettyServerCnxn(processPackage) -&gt; ZookeeperServer(processRequest) -&gt; PredRequestProcessor(processRequest) -&gt; SyncRequestProcessor(processRequest) -&gt; FinalRequestProcessor(processRequest) -&gt; ZKDataBase (statNode)-&gt; DataTree(statNode) -&gt;  WatchManager(addWatch)</p>
<h1 id="客户端接收服务端处理完成的响应"><a href="#客户端接收服务端处理完成的响应" class="headerlink" title="客户端接收服务端处理完成的响应"></a>客户端接收服务端处理完成的响应</h1><h2 id="ClientCnxnSocketNetty-messageReceived"><a href="#ClientCnxnSocketNetty-messageReceived" class="headerlink" title="ClientCnxnSocketNetty.messageReceived"></a>ClientCnxnSocketNetty.messageReceived</h2><p>服务端处理完成以后，会通过NettyServerCnxn.sendResponse发送返回的响应信息，</p>
<p>客户端会在ClientCnxnSocketNetty.messageReceived接收服务端的返回</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void messageReceived(ChannelHandlerContext ctx,</span><br><span class="line">                                    MessageEvent e) throws Exception &#123;</span><br><span class="line">            updateNow()<span class="comment">;</span></span><br><span class="line">            ChannelBuffer <span class="keyword">buf </span>= (ChannelBuffer) e.getMessage()<span class="comment">;</span></span><br><span class="line">            while (<span class="keyword">buf.readable()) </span>&#123;</span><br><span class="line">                if (incomingBuffer.remaining() &gt; <span class="keyword">buf.readableBytes()) </span>&#123;</span><br><span class="line">                    int newLimit = incomingBuffer.position()</span><br><span class="line">                            + <span class="keyword">buf.readableBytes();</span></span><br><span class="line"><span class="keyword"> </span>                   incomingBuffer.limit(newLimit)<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">buf.readBytes(incomingBuffer);</span></span><br><span class="line"><span class="keyword"> </span>               incomingBuffer.limit(incomingBuffer.capacity())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">                if (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">                    incomingBuffer.flip()<span class="comment">;</span></span><br><span class="line">                    if (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">                        recvCount++<span class="comment">;</span></span><br><span class="line">                        readLength()<span class="comment">;</span></span><br><span class="line">                    &#125; else if (!initialized) &#123;</span><br><span class="line">                        readConnectResult()<span class="comment">;</span></span><br><span class="line">                        lenBuffer.clear()<span class="comment">;</span></span><br><span class="line">                        incomingBuffer = lenBuffer<span class="comment">;</span></span><br><span class="line">                        initialized = true<span class="comment">;</span></span><br><span class="line">                        updateLastHeard()<span class="comment">;</span></span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        sendThread.readResponse(incomingBuffer)<span class="comment">; //收到消息以后触发SendThread.readResponse方法</span></span><br><span class="line">                        lenBuffer.clear()<span class="comment">;</span></span><br><span class="line">                        incomingBuffer = lenBuffer<span class="comment">;</span></span><br><span class="line">                        updateLastHeard()<span class="comment">;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            wakeupCnxn()<span class="comment">;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="SendThread-readResponse"><a href="#SendThread-readResponse" class="headerlink" title="SendThread. readResponse"></a>SendThread. readResponse</h2><p>这个方法里面主要的流程如下</p>
<p>首先读取header，如果其xid == -2，表明是一个ping的response，return</p>
<p>如果xid是 -4 ，表明是一个AuthPacket的response return</p>
<p>如果xid是 -1，表明是一个notification,此时要继续读取并构造一个enent，通过EventThread.queueEvent发送，return</p>
<p>其它情况下：</p>
<p>从pendingQueue拿出一个Packet，校验后更新packet信息</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">void readResponse(ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">            ByteBufferInputStream bbis = <span class="keyword">new</span> ByteBufferInputStream(</span><br><span class="line">                    incomingBuffer);</span><br><span class="line">            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">            ReplyHeader replyHdr = <span class="keyword">new</span> ReplyHeader();</span><br><span class="line"></span><br><span class="line">            replyHdr.deserialize(bbia, <span class="string">"header"</span>); <span class="comment">//反序列化header</span></span><br><span class="line">            <span class="keyword">if</span> (replyHdr.getXid() == <span class="number">-2</span>) &#123; <span class="comment">//?</span></span><br><span class="line">                <span class="comment">// -2 is the xid for pings</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Got ping response for sessionid: 0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId)</span><br><span class="line">                            + <span class="string">" after "</span></span><br><span class="line">                            + ((<span class="keyword">System</span>.nanoTime() - lastPingSentNs) / <span class="number">1000000</span>)</span><br><span class="line">                            + <span class="string">"ms"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (replyHdr.getXid() == <span class="number">-4</span>) &#123;</span><br><span class="line">                <span class="comment">// -4 is the xid for AuthPacket</span></span><br><span class="line">                <span class="keyword">if</span>(replyHdr.getErr() == KeeperException.<span class="built_in">Code</span>.AUTHFAILED.intValue()) &#123;</span><br><span class="line">                    state = States.AUTH_FAILED;</span><br><span class="line">                    eventThread.queueEvent( <span class="keyword">new</span> WatchedEvent(Watcher.Event.EventType.None,</span><br><span class="line">                            Watcher.Event.KeeperState.AuthFailed, <span class="built_in">null</span>) );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Got auth sessionid:0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (replyHdr.getXid() == <span class="number">-1</span>) &#123; <span class="comment">//表示当前的消息类型为一个notification(意味着是服务端的一个响应事件)</span></span><br><span class="line">                <span class="comment">// -1 means notification</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Got notification sessionid:0x"</span></span><br><span class="line">                        + Long.toHexString(sessionId));</span><br><span class="line">                &#125;</span><br><span class="line">                WatcherEvent event = <span class="keyword">new</span> WatcherEvent();<span class="comment">//?</span></span><br><span class="line">                event.deserialize(bbia, <span class="string">"response"</span>);  <span class="comment">//反序列化响应信息</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// convert from a server path to a client path</span></span><br><span class="line">                <span class="keyword">if</span> (chrootPath != <span class="built_in">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">String</span> serverPath = event.<span class="built_in">getPath</span>();</span><br><span class="line">                    <span class="keyword">if</span>(serverPath.compareTo(chrootPath)==<span class="number">0</span>)</span><br><span class="line">                        event.setPath(<span class="string">"/"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                        event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                    	<span class="built_in">LOG</span>.warn(<span class="string">"Got server path "</span> + event.<span class="built_in">getPath</span>()</span><br><span class="line">                    			+ <span class="string">" which is too short for chroot path "</span></span><br><span class="line">                    			+ chrootPath);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                WatchedEvent we = <span class="keyword">new</span> WatchedEvent(event);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Got "</span> + we + <span class="string">" for sessionid 0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                eventThread.queueEvent( we );</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If SASL authentication is currently in progress, construct and</span></span><br><span class="line">            <span class="comment">// send a response packet immediately, rather than queuing a</span></span><br><span class="line">            <span class="comment">// response as with other packets.</span></span><br><span class="line">            <span class="keyword">if</span> (tunnelAuthInProgress()) &#123;</span><br><span class="line">                GetSASLRequest request = <span class="keyword">new</span> GetSASLRequest();</span><br><span class="line">                request.deserialize(bbia,<span class="string">"token"</span>);</span><br><span class="line">                zooKeeperSaslClient.respondToServer(request.getToken(),</span><br><span class="line">                  ClientCnxn.this);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Packet packet;</span><br><span class="line">            synchronized (pendingQueue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pendingQueue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    throw <span class="keyword">new</span> IOException(<span class="string">"Nothing in the queue, but got "</span></span><br><span class="line">                            + replyHdr.getXid());</span><br><span class="line">                &#125;</span><br><span class="line">                packet = pendingQueue.remove(); <span class="comment">//因为当前这个数据包已经收到了响应，所以讲它从pendingQueued中移除</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Since requests are processed in order, we better get a response</span></span><br><span class="line"><span class="comment">             * to the first request!</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            try &#123;<span class="comment">//校验数据包信息，校验成功后讲数据包信息进行更新（替换为服务端的信息）</span></span><br><span class="line">                <span class="keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</span><br><span class="line">                    packet.replyHeader.setErr(</span><br><span class="line">                            KeeperException.<span class="built_in">Code</span>.CONNECTIONLOSS.intValue());</span><br><span class="line">                    throw <span class="keyword">new</span> IOException(<span class="string">"Xid out of order. Got Xid "</span></span><br><span class="line">                            + replyHdr.getXid() + <span class="string">" with err "</span> +</span><br><span class="line">                            + replyHdr.getErr() +</span><br><span class="line">                            <span class="string">" expected Xid "</span></span><br><span class="line">                            + packet.requestHeader.getXid()</span><br><span class="line">                            + <span class="string">" for a packet with details: "</span></span><br><span class="line">                            + packet );</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                packet.replyHeader.setXid(replyHdr.getXid());</span><br><span class="line">                packet.replyHeader.setErr(replyHdr.getErr());</span><br><span class="line">                packet.replyHeader.setZxid(replyHdr.getZxid());</span><br><span class="line">                <span class="keyword">if</span> (replyHdr.getZxid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    lastZxid = replyHdr.getZxid();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (packet.response != <span class="built_in">null</span> &amp;&amp; replyHdr.getErr() == <span class="number">0</span>) &#123;</span><br><span class="line">                    packet.response.deserialize(bbia, <span class="string">"response"</span>); <span class="comment">//获得服务端的响应，反序列化以后设置到packet.response属性中。所以我们可以在exists方法的最后一行通过packet.response拿到改请求的返回结果</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">LOG</span>.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">LOG</span>.<span class="keyword">debug</span>(<span class="string">"Reading reply sessionid:0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId) + <span class="string">", packet:: "</span> + packet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                finishPacket(packet); <span class="comment">//最后调用finishPacket方法完成处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="finishPacket方法"><a href="#finishPacket方法" class="headerlink" title="finishPacket方法"></a>finishPacket方法</h2><p>主要功能是把从 Packet 中取出对应的 Watcher 并注册到 ZKWatchManager 中去</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> finishPacket(Packet p) &#123;</span><br><span class="line">        <span class="built_in">int</span> err = p.replyHeader.getErr();</span><br><span class="line">        <span class="keyword">if</span> (p.watchRegistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.watchRegistration.register(err);   <span class="comment">//将事件注册到zkwatchemanager中</span></span><br><span class="line">watchRegistration，熟悉吗？在组装请求的时候，我们初始化了这个对象</span><br><span class="line">把watchRegistration 子类里面的 Watcher 实例放到 ZKWatchManager 的 existsWatches 中存储起来。</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将所有移除的监视事件添加到事件队列, 这样客户端能收到 “data/child 事件被移除”的事件类型</span></span><br><span class="line">        <span class="keyword">if</span> (p.watchDeregistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="built_in">Map</span>&lt;EventType, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; materializedWatchers = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                materializedWatchers = p.watchDeregistration.unregister(err);</span><br><span class="line">                <span class="keyword">for</span> (Entry&lt;EventType, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; entry : materializedWatchers.entrySet()) &#123;</span><br><span class="line">                    <span class="built_in">Set</span>&lt;Watcher&gt; watchers = entry.getValue();</span><br><span class="line">                    <span class="keyword">if</span> (watchers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        queueEvent(p.watchDeregistration.getClientPath(), err,</span><br><span class="line">                                watchers, entry.getKey());</span><br><span class="line">                        <span class="comment">// ignore connectionloss when removing from local</span></span><br><span class="line">                        <span class="comment">// session</span></span><br><span class="line">                        p.replyHeader.setErr(Code.OK.intValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException.NoWatcherException nwe) &#123;</span><br><span class="line">                p.replyHeader.setErr(nwe.code().intValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException ke) &#123;</span><br><span class="line">                p.replyHeader.setErr(ke.code().intValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cb就是AsnycCallback，如果为null，表明是同步调用的接口，不需要异步回掉，因此，直接notifyAll即可。</span></span><br><span class="line">        <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            synchronized (p) &#123;</span><br><span class="line">                p.finished = <span class="keyword">true</span>;</span><br><span class="line">                p.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.finished = <span class="keyword">true</span>;</span><br><span class="line">            eventThread.queuePacket(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="watchRegistration"><a href="#watchRegistration" class="headerlink" title="watchRegistration"></a>watchRegistration</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> register(<span class="built_in">int</span> rc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldAddWatch(rc)) &#123;</span><br><span class="line">                <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; watches = getWatches(rc); <span class="comment">// //通过子类的实现取得ZKWatchManager 中的 existsWatches</span></span><br><span class="line">                synchronized(watches) &#123;</span><br><span class="line">                    <span class="built_in">Set</span>&lt;Watcher&gt; watchers = watches.<span class="keyword">get</span>(clientPath);</span><br><span class="line">                    <span class="keyword">if</span> (watchers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        watchers = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line">                        watches.put(clientPath, watchers);</span><br><span class="line">                    &#125;</span><br><span class="line">                    watchers.add(watcher); <span class="comment">//将 Watcher 对象放到 ZKWatchManager 中的 existsWatches里面</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p> 下面这段代码是客户端存储watcher的几个map集合，分别对应三种注册监听事件</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatchManager</span> <span class="keyword">implements</span> <span class="title">ClientWatchManager</span> </span>&#123;</span><br><span class="line">        private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; dataWatches =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt;();</span><br><span class="line">        private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; existWatches =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt;();</span><br><span class="line">        private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt; childWatches =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Set</span>&lt;Watcher&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>总的来说，当使用ZooKeeper 构造方法或者使用 getData、exists 和 getChildren 三个接口来向 ZooKeeper 服务器注册 Watcher 的时候，首先将此消息传递给服务端，传递成功后，服务端会通知客户端，然后客户端将该路径和Watcher对应关系存储起来备用。</p>
<h3 id="EventThread-queuePacket"><a href="#EventThread-queuePacket" class="headerlink" title="EventThread.queuePacket()"></a>EventThread.queuePacket()</h3><p>finishPacket方法最终会调用eventThread.queuePacket， 讲当前的数据包添加到等待事件通知的队列中</p>
 <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">queuePacket</span><span class="params">(Packet packet)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (wasKilled) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (waitingEvents) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRunning) waitingEvents.add(packet);</span><br><span class="line">                <span class="function"><span class="keyword">else</span> <span class="title">processEvent</span><span class="params">(packet)</span></span>;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             waitingEvents.add(packet);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h1 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h1><p>前面这么长的说明，只是为了清洗的说明事件的注册流程，最终的触发，还得需要通过事务型操作来完成</p>
<p>在我们最开始的案例中，通过如下代码去完成了事件的触发</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.setData(“/mic”, “<span class="number">1</span>”.getByte(),<span class="number">-1</span>) ; <span class="comment">//修改节点的值触发监听</span></span><br></pre></td></tr></table></figure>
<p>前面的客户端和服务端对接的流程就不再重复讲解了，交互流程是一样的，唯一的差别在于事件触发了</p>
<h2 id="服务端的事件响应DataTree-setData"><a href="#服务端的事件响应DataTree-setData" class="headerlink" title="服务端的事件响应DataTree.setData()"></a>服务端的事件响应DataTree.setData()</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stat setData(<span class="keyword">String</span> path, <span class="built_in">byte</span> data[], <span class="built_in">int</span> version, <span class="keyword">long</span> zxid,</span><br><span class="line">            <span class="keyword">long</span> time) <span class="keyword">throws</span> KeeperException.NoNodeException &#123;</span><br><span class="line">        Stat s = <span class="keyword">new</span> Stat();</span><br><span class="line">        DataNode n = nodes.<span class="built_in">get</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">byte</span> lastdata[] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (n) &#123;</span><br><span class="line">            lastdata = n.data;</span><br><span class="line">            n.data = data;</span><br><span class="line">            n.stat.setMtime(time);</span><br><span class="line">            n.stat.setMzxid(zxid);</span><br><span class="line">            n.stat.setVersion(version);</span><br><span class="line">            n.copyStat(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// now update if the path is in a quota subtree.</span></span><br><span class="line">        <span class="keyword">String</span> lastPrefix = getMaxPrefixWithQuota(path);</span><br><span class="line">        <span class="keyword">if</span>(lastPrefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.updateBytes(lastPrefix, (data == <span class="keyword">null</span> ? <span class="number">0</span> : data.length)</span><br><span class="line">              - (lastdata == <span class="keyword">null</span> ? <span class="number">0</span> : lastdata.length));</span><br><span class="line">        &#125;</span><br><span class="line">        dataWatches.triggerWatch(path, EventType.NodeDataChanged); <span class="comment">//触发对应节点的NodeDataChanged事件</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="WatcherManager-triggerWatch"><a href="#WatcherManager-triggerWatch" class="headerlink" title="WatcherManager. triggerWatch"></a>WatcherManager. triggerWatch</h3> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>&lt;Watcher&gt; triggerWatch(<span class="built_in">String</span> path, EventType type, <span class="built_in">Set</span>&lt;Watcher&gt; supress) &#123;</span><br><span class="line">        WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type, KeeperState.SyncConnected, path); <span class="comment">//  根据事件类型、连接状态、节点路径创建WatchedEvent</span></span><br><span class="line">        HashSet&lt;Watcher&gt; watchers;</span><br><span class="line">        synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">            watchers = watchTable.remove(path); <span class="comment">// 从watcher表中移除path，并返回其对应的watcher集合</span></span><br><span class="line">            <span class="keyword">if</span> (watchers == <span class="keyword">null</span> || watchers.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                    ZooTrace.logTraceMessage(LOG,</span><br><span class="line">                            ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                            <span class="string">"No watchers for "</span> + path);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Watcher w : watchers) &#123; <span class="comment">// 遍历watcher集合</span></span><br><span class="line">                HashSet&lt;<span class="built_in">String</span>&gt; paths = watch2Paths.<span class="keyword">get</span>(w); <span class="comment">// 根据watcher从watcher表中取出路径集合</span></span><br><span class="line">                <span class="keyword">if</span> (paths != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    paths.remove(path); <span class="comment">//移除路径</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Watcher w : watchers) &#123; <span class="comment">// 遍历watcher集合</span></span><br><span class="line">            <span class="keyword">if</span> (supress != <span class="keyword">null</span> &amp;&amp; supress.contains(w)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            w.process(e); <span class="comment">//OK，重点又来了，w.process是做什么呢？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> watchers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="w-process-e"><a href="#w-process-e" class="headerlink" title="w.process(e);"></a>w.process(e);</h3><p>还记得我们在服务端绑定事件的时候，watcher绑定是是什么？是ServerCnxn， 所以w.process(e)，其实调用的应该是ServerCnxn的process方法。而servercnxn又是一个抽象方法，有两个实现类，分别是：NIOServerCnxn和NettyServerCnxn。那接下来我们扒开NettyServerCnxn这个类的process方法看看究竟</p>
 <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span>(<span class="params">WatchedEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">        ReplyHeader h = <span class="keyword">new</span> ReplyHeader(<span class="number">-1</span>, <span class="number">-1</span>L, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                                     <span class="string">"Deliver event "</span> + <span class="keyword">event</span> + <span class="string">" to 0x"</span></span><br><span class="line">                                     + Long.toHexString(<span class="keyword">this</span>.sessionId)</span><br><span class="line">                                     + <span class="string">" through "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert WatchedEvent to a type that can be sent over the wire</span></span><br><span class="line">        WatcherEvent e = <span class="keyword">event</span>.getWrapper();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendResponse(h, e, <span class="string">"notification"</span>);  <span class="comment">//look， 这个地方发送了一个事件，事件对象为WatcherEvent。完美</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                LOG.debug(<span class="string">"Problem sending to "</span> + getRemoteSocketAddress(), e1);</span><br><span class="line">            &#125;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那接下里，客户端会收到这个response，触发SendThread.readResponse方法</p>
<h2 id="客户端处理事件响应"><a href="#客户端处理事件响应" class="headerlink" title="客户端处理事件响应"></a>客户端处理事件响应</h2><h3 id="SendThread-readResponse-1"><a href="#SendThread-readResponse-1" class="headerlink" title="SendThread.readResponse"></a>SendThread.readResponse</h3><p>这块代码上面已经贴过了，所以我们只挑选当前流程的代码进行讲解，按照前面我们将到过的，notifacation通知消息的xid为-1，意味着~直接找到-1的判断进行分析<br>在下面代码标红处.</p>
<h3 id="eventThread-queueEvent"><a href="#eventThread-queueEvent" class="headerlink" title="eventThread.queueEvent"></a>eventThread.queueEvent</h3><p>  SendThread 接收到服务端的通知事件后，会通过调用 EventThread 类的 queueEvent 方法将事件传给 EventThread 线程，queueEvent 方法根据该通知事件，从 ZKWatchManager 中取出所有相关的 Watcher，如果获取到相应的Watcher，就会让Watcher移除失效。</p>
<h3 id="Meterialize方法"><a href="#Meterialize方法" class="headerlink" title="Meterialize方法"></a>Meterialize方法</h3><p>通过dataWatches或者existWatches或者childWatches的remove取出对应的watch，表明客户端watch也是注册一次就移除<br>同时需要根据keeperState、eventType和path返回应该被通知的Watcher集合</p>
<h3 id="waitingEvents-add"><a href="#waitingEvents-add" class="headerlink" title="waitingEvents.add"></a>waitingEvents.add</h3><p>最后一步，接近真相了<br>waitingEvents是EventThread这个线程中的阻塞队列，很明显，又是在我们第一步操作的时候实例化的一个线程。<br>从名字可以指导，waitingEvents 是一个待处理 Watcher 的队列，EventThread 的 run() 方法会不断从队列中取数据，交由 processEvent 方法处理：</p>
<h3 id="ProcessEvent"><a href="#ProcessEvent" class="headerlink" title="ProcessEvent"></a>ProcessEvent</h3><p>由于这块的代码太长，我只把核心的代码贴出来，这里就是处理事件触发的核心代</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/zookeeper/" rel="tag"># zookeeper</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/09/zookeeper学习笔记_05_原生API的使用/" rel="next" title="zookeeper原生API使用">
                <i class="fa fa-chevron-left"></i> zookeeper原生API使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/12/telnet命令详解/" rel="prev" title="telnet命令详解">
                telnet命令详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/xiaowu_avatar.jpg"
                alt="周小伍 Joey" />
            
              <p class="site-author-name" itemprop="name">周小伍 Joey</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">150</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Watcher的基本流程"><span class="nav-number">1.</span> <span class="nav-text">Watcher的基本流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper-API的初始化过程"><span class="nav-number">1.1.</span> <span class="nav-text">ZooKeeper API的初始化过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ClientCnxn初始化"><span class="nav-number">1.1.1.</span> <span class="nav-text">ClientCnxn初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端通过exists注册监听"><span class="nav-number">1.2.</span> <span class="nav-text">客户端通过exists注册监听</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cnxn-submitRequest"><span class="nav-number">1.2.1.</span> <span class="nav-text">cnxn.submitRequest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SendThread的发送过程"><span class="nav-number">1.2.2.</span> <span class="nav-text">SendThread的发送过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client-和-server的网络交互"><span class="nav-number">1.2.3.</span> <span class="nav-text">client 和 server的网络交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DoWrite方法"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">DoWrite方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sendPkt"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">sendPkt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createBB"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">createBB</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务端接收请求处理流程"><span class="nav-number">2.</span> <span class="nav-text">服务端接收请求处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NettyServerCnxn"><span class="nav-number">2.1.</span> <span class="nav-text">NettyServerCnxn</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZookeeperServer-zks-processPacket-this-bb"><span class="nav-number">2.2.</span> <span class="nav-text">ZookeeperServer-zks.processPacket(this, bb);</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#submitRequest"><span class="nav-number">2.3.</span> <span class="nav-text">submitRequest</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#firstProcessor的请求链组成"><span class="nav-number">2.3.1.</span> <span class="nav-text">firstProcessor的请求链组成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PredRequestProcessor-processRequest-si"><span class="nav-number">2.4.</span> <span class="nav-text">PredRequestProcessor.processRequest(si);</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pRequest"><span class="nav-number">2.4.1.</span> <span class="nav-text">pRequest</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SyncRequestProcessor-processRequest"><span class="nav-number">2.5.</span> <span class="nav-text">SyncRequestProcessor. processRequest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FinalRequestProcessor-processRequest"><span class="nav-number">2.6.</span> <span class="nav-text">FinalRequestProcessor. processRequest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#statNode这个方法做了什么？"><span class="nav-number">2.7.</span> <span class="nav-text">statNode这个方法做了什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WatchManager-addWatch-path-watcher"><span class="nav-number">2.7.1.</span> <span class="nav-text">WatchManager.addWatch(path, watcher);</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">2.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#客户端接收服务端处理完成的响应"><span class="nav-number">3.</span> <span class="nav-text">客户端接收服务端处理完成的响应</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ClientCnxnSocketNetty-messageReceived"><span class="nav-number">3.1.</span> <span class="nav-text">ClientCnxnSocketNetty.messageReceived</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SendThread-readResponse"><span class="nav-number">3.2.</span> <span class="nav-text">SendThread. readResponse</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finishPacket方法"><span class="nav-number">3.3.</span> <span class="nav-text">finishPacket方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#watchRegistration"><span class="nav-number">3.3.1.</span> <span class="nav-text">watchRegistration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventThread-queuePacket"><span class="nav-number">3.3.2.</span> <span class="nav-text">EventThread.queuePacket()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件触发"><span class="nav-number">4.</span> <span class="nav-text">事件触发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#服务端的事件响应DataTree-setData"><span class="nav-number">4.1.</span> <span class="nav-text">服务端的事件响应DataTree.setData()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WatcherManager-triggerWatch"><span class="nav-number">4.1.1.</span> <span class="nav-text">WatcherManager. triggerWatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#w-process-e"><span class="nav-number">4.1.2.</span> <span class="nav-text">w.process(e);</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端处理事件响应"><span class="nav-number">4.2.</span> <span class="nav-text">客户端处理事件响应</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SendThread-readResponse-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">SendThread.readResponse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eventThread-queueEvent"><span class="nav-number">4.2.2.</span> <span class="nav-text">eventThread.queueEvent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Meterialize方法"><span class="nav-number">4.2.3.</span> <span class="nav-text">Meterialize方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#waitingEvents-add"><span class="nav-number">4.2.4.</span> <span class="nav-text">waitingEvents.add</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessEvent"><span class="nav-number">4.2.5.</span> <span class="nav-text">ProcessEvent</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">周小伍 Joey</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">270.1k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://joeyblog.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2018/06/10/zookeeper-watcher机制源码分析/';
          this.page.identifier = '2018/06/10/zookeeper-watcher机制源码分析/';
          this.page.title = 'zookeeper watcher机制源码分析';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://joeyblog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  










  





  

  

  

  

  

  

</body>
</html>
