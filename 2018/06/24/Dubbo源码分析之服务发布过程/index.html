<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="服务端发布流程 Spring 对外留出的扩展dubbo 是基于 spring 配置来实现服务的发布的，一定是基于 spring 的扩展来写了一套自己的标签。在 dubbo 配置文件中看到的&amp;lt;dubbo:service&amp;gt; ，就是属于自定义扩展标签要实现自定义扩展，有三个步骤(在 spring 中定义了两个接口，用来实现 扩展)   NamespaceHandler: 注册一堆 BeanD">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo源码分析之服务发布过程">
<meta property="og:url" content="http://yoursite.com/2018/06/24/Dubbo源码分析之服务发布过程/index.html">
<meta property="og:site_name" content="xiaowu&#39;s blog">
<meta property="og:description" content="服务端发布流程 Spring 对外留出的扩展dubbo 是基于 spring 配置来实现服务的发布的，一定是基于 spring 的扩展来写了一套自己的标签。在 dubbo 配置文件中看到的&amp;lt;dubbo:service&amp;gt; ，就是属于自定义扩展标签要实现自定义扩展，有三个步骤(在 spring 中定义了两个接口，用来实现 扩展)   NamespaceHandler: 注册一堆 BeanD">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oz3qait0p.bkt.clouddn.com/Proxy%20getProxy%20debug.png">
<meta property="og:updated_time" content="2018-06-30T14:02:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dubbo源码分析之服务发布过程">
<meta name="twitter:description" content="服务端发布流程 Spring 对外留出的扩展dubbo 是基于 spring 配置来实现服务的发布的，一定是基于 spring 的扩展来写了一套自己的标签。在 dubbo 配置文件中看到的&amp;lt;dubbo:service&amp;gt; ，就是属于自定义扩展标签要实现自定义扩展，有三个步骤(在 spring 中定义了两个接口，用来实现 扩展)   NamespaceHandler: 注册一堆 BeanD">
<meta name="twitter:image" content="http://oz3qait0p.bkt.clouddn.com/Proxy%20getProxy%20debug.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/24/Dubbo源码分析之服务发布过程/"/>





  <title>Dubbo源码分析之服务发布过程 | xiaowu's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiaowu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/24/Dubbo源码分析之服务发布过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周小伍 Joey">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xiaowu_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaowu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Dubbo源码分析之服务发布过程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-24T10:37:47+08:00">
                2018-06-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/24/Dubbo源码分析之服务发布过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/24/Dubbo源码分析之服务发布过程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="服务端发布流程"><a href="#服务端发布流程" class="headerlink" title="服务端发布流程"></a>服务端发布流程</h1><ul>
<li>Spring 对外留出的扩展<br>dubbo 是基于 spring 配置来实现服务的发布的，一定是基于 spring 的扩展来写了一套自己的标签。在 dubbo 配置文件中看到的<code>&lt;dubbo:service&gt;</code> ，就是属于自定义扩展标签<br>要实现自定义扩展，有三个步骤(在 spring 中定义了两个接口，用来实现 扩展)</li>
</ul>
<ol>
<li>NamespaceHandler: 注册一堆 BeanDefinitionParser，利用他们来进<br>行解析</li>
<li>BeanDefinitionParser:用于解析每个element的内容</li>
<li>Spring 默认会加载 jar 包下的 META-INF/spring.handlers 文件寻找对<br>应的 NamespaceHandler。</li>
</ol>
<p>这个里面主要做了一件事，把不同的配置分别转化成 spring 容器中的 bean<br> 对象<br>application 对应 ApplicationConfig<br>registry 对应 RegistryConfig<br>monitor 对应 MonitorConfig<br>provider 对应 ProviderConfig<br>consumer 对应 ConsumerConfig</p>
<p>为了在 spring 启动的时候，也相应的启动 provider 发布服务注册服务的 过程，而同时为了让客户端在启动的时候自动订阅发现服务，加入了两个 bean<br><code>ServiceBean</code>、<code>ReferenceBean</code>。<br>分别继承了 ServiceConfig 和 ReferenceConfig<br>同 时 还 分 别 实 现 了 InitializingBean 、 DisposableBean, ApplicationContextAware, ApplicationListener, BeanNameAware InitializingBean 接口为 bean 提供了初始化方法的方式，它只包括 afterPropertiesSet 方法，凡是继承该接口的类，在初始化 bean 的时候会 执行该方法。<br>DisposableBean bean 被销毁的时候，spring 容器会自动执行 destory 方 法，比如释放资源<br>ApplicationContextAware 实现了这个接口的 bean，当 spring 容器初始 化的时候，会自动的将 ApplicationContext 注入进来<br>ApplicationListener ApplicationEvent 事件监听，spring 容器启动后会发一个事件通知<br>BeanNameAware 获得自身初始化时，本身的 bean 的 id 属性</p>
<p>那么基本的实现思路可以整理出来了</p>
<ol>
<li>利用 spring 的解析收集 xml 中的配置信息，然后把这些配置信息存储<br>到 serviceConfig 中</li>
<li>调用ServiceConfig的export方法来进行服务的发布和注册</li>
</ol>
<p>服务的发布过程<br>serviceBean 是服务发布的切入点，通过 afterPropertiesSet 方法，调用 export()方法进行发布。<br>export 为父类 ServiceConfig 中的方法，所以跳转到 SeviceConfig 类中的 export 方法</p>
<h2 id="delay作用"><a href="#delay作用" class="headerlink" title="delay作用"></a>delay作用</h2><ol>
<li>export 是 synchronized 修饰的方法。也就是说暴露的过程是原子操作，<br>正常情况下不会出现锁竞争的问题，毕竟初始化过程大多数情况下都是 单一线程操作，这里联想到了 spring 的初始化流程，也进行了加锁操 作，这里也给我们平时设计一个不错的启示:初始化流程的性能调优优先级应该比较低，但是安全的优先级应该放的比较高!</li>
<li>继续看doExport()方法。同样是一堆初始化代</li>
</ol>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="keyword">export</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">export</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">export</span> = provider.getExport();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delay == <span class="literal">null</span>) &#123;</span><br><span class="line">            delay = provider.getDelay();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">export</span> != <span class="literal">null</span> &amp;&amp; ! <span class="keyword">export</span>.booleanValue()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (delay != <span class="literal">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(delay);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                doExport();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        thread.setName(<span class="string">"DelayExportServiceThread"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doExport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看 doExport()，最终会调用到 doExportUrls()中:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;URL&gt; registryURLs = loadRegistries(<span class="literal">true</span>);<span class="comment">//是不是获得注册中心的配置</span></span><br><span class="line">    <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123; <span class="comment">//是不是支持多协议发布</span></span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这 个 protocols 长 这 个 样 子 <dubbo:protocol name="dubbo" port="20888" id="dubbo"> protocols 也是根据配置装配出来的。接下 来让我们进入 doExportUrlsFor1Protocol 方法看看 dubbo 具体是怎么样 将服务暴露出去</dubbo:protocol></p>
<h2 id="doExportUrlsFor1Protocol"><a href="#doExportUrlsFor1Protocol" class="headerlink" title="doExportUrlsFor1Protocol"></a>doExportUrlsFor1Protocol</h2><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露本地服务)</span></span><br><span class="line"><span class="comment">//注册服务</span></span><br><span class="line"><span class="keyword">if</span> (! Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope) )&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + <span class="built_in">url</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (registryURLs != <span class="literal">null</span> &amp;&amp; registryURLs.size() &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; <span class="built_in">url</span>.getParameter(<span class="string">"register"</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (URL <span class="attribute">registryURL</span> : registryURLs) &#123;<span class="comment">//</span></span><br><span class="line">            <span class="built_in">url</span> = <span class="built_in">url</span>.addParameterIfAbsent(<span class="string">"dynamic"</span>, registryURL.getParameter(<span class="string">"dynamic"</span>));</span><br><span class="line">            URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">            <span class="keyword">if</span> (monitorUrl != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">url</span> = <span class="built_in">url</span>.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + <span class="built_in">url</span> + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//通过proxyFactory来获取Invoker对象</span></span><br><span class="line">            Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class)interfaceClass,registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, <span class="built_in">url</span>.toFullString()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注册服务</span></span><br><span class="line">            Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line">            <span class="comment">//将exporter添加到list中</span></span><br><span class="line">            exporters.add(exporter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="title">else</span> &#123;</span><br><span class="line">        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, <span class="built_in">url</span>);</span><br><span class="line">        Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line">        exporters.add(exporter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> doExportUrlsFor1Protocol 方 法，先创建两个 URL，分别如下 dubbo://192.168.xx.63:20888/com.gupaoedu.IGHello; registry://192.168.xx ;<br>是不是觉得这个 URL 很眼熟，没错在注册中心看到的 services 的 providers 信息就是这个<br>在上面这段代码中可以看到 Dubbo 的比较核心的抽象:Invoke。<code>Invoker</code> 是一个代理类，从 <code>ProxyFactory</code> 中生成。</p>
<p>这个地方可以做一个小结</p>
<ol>
<li>Invoker - 执行具体的远程调用</li>
<li>Protocol – 服务地址的发布和订阅</li>
<li>Exporter – 暴露服务或取消暴露</li>
</ol>
<p>protocol.export(invoker)<br>protocol 这个地方，其实并不是直接调用 DubboProtocol 协议的 export, 大家跟我看看 protocol 这个属性是在哪里实例化的?以及实例化的代码 是什么?<br>这个 Protocol 得到的应该是一个 <code>Protocol$Adaptive</code>一个自适应 的适配器。这个时候，通过 protocol.export(invoker),实际上调用的应该是<code>Protocol$Adaptive</code> 这个动态类的 export 方法。 <code>Protocol$Adaptive</code>前面的ExtensionLoader有讲过，默认是dubbo。</p>
<p>上面这段代码做两个事情</p>
<ol>
<li>从 url 中获得 protocol 的协议地址，如果 protocol 为空，表示已 dubbo协议发布服务，否则根据配置的协议类型来发布服务。</li>
<li>调 用<br>ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName);<br>ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName);</li>
</ol>
<p>这段代码做了什么事情呢?前面这段代码我们已经理解了，通过工厂模式 获得一个 ExtensionLoader 实例，我们来分析下下 getExtension 这个方法。<br>getExtension<br>这个方法的主要作用是用来获取 ExtensionLoader 实例代表的扩展的指定 实现，已扩展实现的名字作为参数。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   /**</span><br><span class="line">    * 返回指定名字的扩展。如果指定名字的扩展不存在，则抛异常 &#123;@link IllegalStateException&#125;.</span><br><span class="line">    *</span><br><span class="line">    * @param name</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">public T getExtension(String name) &#123;</span><br><span class="line"><span class="built_in">	if </span>(name == null || name.length() == 0)</span><br><span class="line">	   <span class="built_in"> throw </span>new IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line"><span class="built_in">	if </span>(<span class="string">"true"</span>.equals(name)) &#123;</span><br><span class="line">	   <span class="built_in"> return </span>getDefaultExtension();</span><br><span class="line">	&#125;</span><br><span class="line">	////判断是否已经缓存过该扩展点</span><br><span class="line">	Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line"><span class="built_in">	if </span>(holder == null) &#123;</span><br><span class="line">	    cachedInstances.putIfAbsent(name,<span class="built_in"> new </span>Holder&lt;Object&gt;());</span><br><span class="line">	    holder = cachedInstances.get(name);</span><br><span class="line">	&#125;</span><br><span class="line">	Object<span class="built_in"> instance </span>= holder.get();</span><br><span class="line"><span class="built_in">	if </span>(instance == null) &#123;</span><br><span class="line">	    synchronized (holder) &#123;</span><br><span class="line">           <span class="built_in"> instance </span>= holder.get();</span><br><span class="line">           <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">            ////createExtension ，创建扩展点</span><br><span class="line">               <span class="built_in"> instance </span>= createExtension(name);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">	return </span>(T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="createExtension"><a href="#createExtension" class="headerlink" title="createExtension"></a>createExtension</h2><ol>
<li>根据 name 获取对应的 class</li>
<li>根据class创建一个实例</li>
<li>对获取的实例进行依赖注入</li>
<li>对实例进行包装，分别调用带 Protocol 参数的构造函数创建实例，然<br>后进行依赖注入。<br>a) 在 dubbo-rpc-api 的 resources 路 径 下 ， 找 到<br>com.alibaba.dubbo.rcp.Protocol 文件中有存在 filter/listener<br>b) 遍历 <code>cachedWrapperClass</code> 对 <code>DubboProtocol</code> 进行包装，会通过<br><code>ProtocolFilterWrapper</code>、<code>ProtocolListenerWrapper</code> 包装</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);<span class="comment">//"dubbo"  clazz=DubboProtocol</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; wrapperClasses.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">            <span class="comment">//// 对实例进行包装，分别调用带 Protocol 参数的构 造函数创建实例，然后进行依赖注入。</span></span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance(name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">                type + <span class="string">")  could not be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getExtensionClasses"><a href="#getExtensionClasses" class="headerlink" title="getExtensionClasses"></a>getExtensionClasses</h2><p>这个方法之前在讲自适应扩展点的时候讲过了，其实就是加载扩展点实现 类了。然后调用 loadExtensionClasses，去对应文件下去加载指定的扩展 点<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载扩展点的实现类</span></span><br><span class="line">private <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Class&lt;?&gt;&gt; classes = cachedClasses.<span class="keyword">get</span>();</span><br><span class="line">       <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">           synchronized (cachedClasses) &#123;</span><br><span class="line">               classes = cachedClasses.<span class="keyword">get</span>();</span><br><span class="line">               <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   classes = loadExtensionClasses();</span><br><span class="line">                   cachedClasses.<span class="keyword">set</span>(classes);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ResigtryProtocol"><a href="#ResigtryProtocol" class="headerlink" title="ResigtryProtocol"></a>ResigtryProtocol</h1><p>ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extN ame); 当 extName 为 registry 的时候，我们不需要再次去阅读这块代码 了，直接可以在扩展点中找到相应的实现扩展点[/dubbo-registry- api/src/main/resources/META- INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol] 配置如下<br>所以，我们可以定位到 <code>RegistryProtocol</code>这个类中的<code>export</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//export invoker ， 本地发布服务（启动netty）</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">    <span class="comment">//registry provider</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">    registry.register(registedProviderUrl);</span><br><span class="line">    <span class="comment">// 订阅override数据</span></span><br><span class="line">    <span class="comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span></span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">//保证每次export都返回一个新的exporter实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Exporter&lt;T&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">              exporter.unexport();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               registry.unregister(registedProviderUrl);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               overrideListeners.remove(overrideSubscribeUrl);</span><br><span class="line">               registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地先启动监听服务 </p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; ExporterChangeableWrapper&lt;T&gt;  doLocalExport(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)&#123;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">key</span> = getCacheKey(originInvoker);</span><br><span class="line">    ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (bounds) &#123;</span><br><span class="line">            exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">            <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class="line">                exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;)protocol.export(invokerDelegete), originInvoker);</span><br><span class="line">                bounds.put(<span class="built_in">key</span>, exporter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ExporterChangeableWrapper&lt;T&gt;) exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，protocol代码是怎么赋值的呢？我们看看代码，熟悉吗？是一个依赖注入的扩展点。不熟悉的话，我们再回想一下，在加载扩展点的时候，</p>
<p>有一个injectExtension方法，针对已经加载的扩展点中的扩展点属性进行依赖注入。（牛逼的代码）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProtocol</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们知道protocol是一个自适应扩展点，Protocol$Adaptive，然后调用这个自适应扩展点中的export方法，这个时候传入的协议地址应该是</p>
<p>dubbo://127.0.0.1/xxxx… 因此在<code>Protocol$Adaptive.export</code>方法中，<code>ExtensionLoader.getExtension(Protocol.class).getExtension(extName)</code>。应该就是<code>ProtocolFilterWrapper(ProtocolListenerWrapper(DubboProtocol)))</code>，在<code>ExtensionLoader</code>中会扫描是否有<code>wrappedClass</code>，就是存在构造函数，参数是父类接口。</p>
<p>这里并不是获得一个单纯的DubboProtocol扩展点，而是会通过Wrapper对Protocol进行装饰，装饰器分别为: ProtocolFilterWrapper/ ProtocolListenerWrapper; 至于MockProtocol为什么不在装饰器里面呢？大家再回想一下我们在看ExtensionLoader.loadFile这段代码的时候，有一个判断，装饰器必须要具备一个带有Protocol的构造方法，如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">ProtocolFilterWrapper</span>(<span class="type">Protocol</span> <span class="class"><span class="keyword">protocol</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="class"><span class="keyword">protocol</span> == <span class="title">null</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> new <span class="type">IllegalArgumentException</span>(<span class="string">"protocol == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    this.<span class="keyword">protocol</span> = <span class="class"><span class="keyword">protocol</span>;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="分析ProtocolFilterWrapper和ProtocolListenerWrapper"><a href="#分析ProtocolFilterWrapper和ProtocolListenerWrapper" class="headerlink" title="分析ProtocolFilterWrapper和ProtocolListenerWrapper"></a>分析ProtocolFilterWrapper和ProtocolListenerWrapper</h2><h3 id="ProtocolFilterWrapper"><a href="#ProtocolFilterWrapper" class="headerlink" title="ProtocolFilterWrapper"></a>ProtocolFilterWrapper</h3><p>这个类非常重要，dubbo机制里面日志记录、超时等等功能都是在这一部分实现的</p>
<p>这个类有3个特点，</p>
<p>第一它有一个参数为Protocol protocol的构造函数；</p>
<p>第二，它实现了Protocol接口；</p>
<p>第三，它使用<strong>责任链模式</strong>，对export和refer函数进行了封装。分别使用<code>SERVICE_FILTER_KEY</code>和<code>REFERENCE_FILTER_KEY</code>调用<code>buildInvokerChain</code>方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> protocol.<span class="title">getDefaultPort</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> protocol.<span class="title">export</span><span class="params">(invoker)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> protocol.<span class="title">refer</span><span class="params">(type, url)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        protocol.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//buildInvokerChain函数：它读取所有的filter类，利用这些类封装invoker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Invoker&lt;T&gt; buildInvokerChain(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group) &#123;</span><br><span class="line">        Invoker&lt;T&gt; last = invoker;</span><br><span class="line">        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">        <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line">                <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">                last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> Class&lt;T&gt; getInterface() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">return</span> invoker.<span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> <span class="function">URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">return</span> invoker.<span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">return</span> invoker.<span class="title">isAvailable</span><span class="params">()</span></span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> <span class="function">Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">return</span> filter.<span class="title">invoke</span><span class="params">(next, invocation)</span></span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        invoker.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="function"><span class="keyword">return</span> invoker.<span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看如下文件： /dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter</p>
<p>其实就是对Invoker，通过如下的Filter组装成一个责任链</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.EchoFilter</span></span><br><span class="line">generic=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.GenericFilter</span></span><br><span class="line">genericimpl=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.GenericImplFilter</span></span><br><span class="line">token=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.TokenFilter</span></span><br><span class="line">accesslog=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.AccessLogFilter</span></span><br><span class="line">activelimit=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.ActiveLimitFilter</span></span><br><span class="line">classloader=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.ClassLoaderFilter</span></span><br><span class="line">context=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.ContextFilter</span></span><br><span class="line">consumercontext=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.ConsumerContextFilter</span></span><br><span class="line">exception=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.ExceptionFilter</span></span><br><span class="line">executelimit=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.ExecuteLimitFilter</span></span><br><span class="line">deprecated=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.DeprecatedFilter</span></span><br><span class="line">compatible=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.CompatibleFilter</span></span><br><span class="line">timeout=com<span class="selector-class">.alibaba</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.filter</span><span class="selector-class">.TimeoutFilter</span></span><br></pre></td></tr></table></figure>
<p>这其中涉及到很多功能，包括权限验证、异常、超时等等，当然可以预计计算调用时间等等应该也是在这其中的某个类实现的；</p>
<p>这里我们可以看到export和refer过程都会被filter过滤</p>
<h3 id="ProtocolListenerWrapper"><a href="#ProtocolListenerWrapper" class="headerlink" title="ProtocolListenerWrapper"></a>ProtocolListenerWrapper</h3><p>在这里我们可以看到export和refer分别对应了不同的Wrapper；export是对应的ListenerExporterWrapper。这块暂时先不去分析，因为这个地方并没有提供实现类。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker), </span><br><span class="line">            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.<span class="keyword">class</span>)</span><br><span class="line">                    .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; <span class="class"><span class="keyword">type</span>, <span class="title">URL</span> <span class="title">url</span>) <span class="title">throws</span> <span class="title">RpcException</span> &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.refer(<span class="class"><span class="keyword">type</span>, <span class="title">url</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListenerInvokerWrapper&lt;T&gt;(protocol.refer(<span class="class"><span class="keyword">type</span>, <span class="title">url</span>), </span></span><br><span class="line">            Collections.unmodifiableList(</span><br><span class="line">                    ExtensionLoader.getExtensionLoader(InvokerListener.<span class="keyword">class</span>)</span><br><span class="line">                    .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DubboProtocol-export"><a href="#DubboProtocol-export" class="headerlink" title="DubboProtocol.export"></a>DubboProtocol.export</h2><p>通过上面的代码分析完以后，最终我们能够定位到DubboProtocol.export方法。我们看一下dubboProtocol的export方法：openServer(url）</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; <span class="keyword">export</span>(Invoker&lt;T&gt; invoker) throws <span class="title">RpcException</span> &#123;</span><br><span class="line">    URL <span class="built_in">url</span> = invoker.getUrl();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// export service.</span></span><br><span class="line">    <span class="built_in">String</span> key = serviceKey(<span class="built_in">url</span>);</span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//export an stub service for dispaching event</span></span><br><span class="line">    <span class="built_in">Boolean</span> isStubSupportEvent = <span class="built_in">url</span>.getParameter(Constants.STUB_EVENT_KEY,Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">    <span class="built_in">Boolean</span> isCallbackservice = <span class="built_in">url</span>.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice)&#123;</span><br><span class="line">        <span class="built_in">String</span> stubServiceMethods = <span class="built_in">url</span>.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods == <span class="literal">null</span> || stubServiceMethods.length() == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled())&#123;</span><br><span class="line">                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> +<span class="built_in">url</span>.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                        <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="title">else</span> &#123;</span><br><span class="line">            stubServiceMethodsMap.put(<span class="built_in">url</span>.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暴露服务</span></span><br><span class="line">    openServer(<span class="built_in">url</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="openServer"><a href="#openServer" class="headerlink" title="openServer"></a>openServer</h3><p>开启服务</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> openServer(URL url) &#123;</span><br><span class="line">    <span class="comment">// find server.</span></span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">key</span> = url.getAddress();<span class="comment">//192.168.11.156：20880</span></span><br><span class="line">    <span class="comment">//client 也可以暴露一个只有server可以调用的服务。</span></span><br><span class="line">    <span class="built_in">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY,<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">       ExchangeServer server = serverMap.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">       <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;<span class="comment">//没有的话就是创建服务</span></span><br><span class="line">          serverMap.put(<span class="built_in">key</span>, createServer(url));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//server支持reset,配合override功能使用</span></span><br><span class="line">          server.reset(url);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="createServer"><a href="#createServer" class="headerlink" title="createServer"></a>createServer</h3><p>创建服务,开启心跳检测，默认使用netty。组装url</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private ExchangeServer createServer(URL <span class="built_in">url</span>) &#123;</span><br><span class="line">    <span class="comment">//默认开启server关闭时发送readonly事件</span></span><br><span class="line">    <span class="built_in">url</span> = <span class="built_in">url</span>.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, <span class="built_in">Boolean</span>.TRUE.toString());</span><br><span class="line">    <span class="comment">//默认开启heartbeat</span></span><br><span class="line">    <span class="built_in">url</span> = <span class="built_in">url</span>.addParameterIfAbsent(Constants.HEARTBEAT_KEY, <span class="built_in">String</span>.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line">    <span class="built_in">String</span> str = <span class="built_in">url</span>.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; ! ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported server type: "</span> + str + <span class="string">", url: "</span> + <span class="built_in">url</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">url</span> = <span class="built_in">url</span>.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() ? <span class="attribute">COMPATIBLE_CODEC_NAME</span> : DubboCodec.NAME);</span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    <span class="title">try</span> &#123;</span><br><span class="line">        server = Exchangers.bind(<span class="built_in">url</span>, requestHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server(url: "</span> + <span class="built_in">url</span> + <span class="string">") "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    str = <span class="built_in">url</span>.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">        <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exchangers-bind"><a href="#Exchangers-bind" class="headerlink" title="Exchangers.bind"></a>Exchangers.<em>bind</em></h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler <span class="keyword">handler</span>)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">handler</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">    <span class="keyword">return</span> getExchanger(url).bind(url, <span class="keyword">handler</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过ExtensionLoader获得指定的扩展点，type默认为header </p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger getExchanger(URL url) &#123;</span><br><span class="line">  <span class="comment">//url中获得exchanger, 默认为header</span></span><br><span class="line">    String <span class="class"><span class="keyword">type</span> </span>= url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class="line">    <span class="keyword">return</span> getExchanger(<span class="class"><span class="keyword">type</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger getExchanger(String <span class="class"><span class="keyword">type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Exchanger.<span class="keyword">class</span>).getExtension(<span class="class"><span class="keyword">type</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HeaderExchanger-bind"><a href="#HeaderExchanger-bind" class="headerlink" title="HeaderExchanger.bind"></a>HeaderExchanger.bind</h3><p>调用headerExchanger的bind方法</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler <span class="keyword">handler</span>)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(<span class="keyword">handler</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过transporter.bind来进行绑定。 </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handlers == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelHandler <span class="keyword">handler</span>;</span><br><span class="line">    <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">handler</span> = handlers[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">handler</span> = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getTransporter().bind(url, <span class="keyword">handler</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NettyTransport-bind"><a href="#NettyTransport-bind" class="headerlink" title="NettyTransport.bind"></a>NettyTransport.bind</h3><p>通过NettyTranport创建基于Netty的server服务</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> Server </span>bind(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">    return new NettyServer(url, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new-HeaderExchangeServer"><a href="#new-HeaderExchangeServer" class="headerlink" title="new HeaderExchangeServer"></a>new HeaderExchangeServer</h3><p>在调用HeaderExchanger.bind方法的时候，是先new一个HeaderExchangeServer. 这个server是干嘛呢？ 是对当前这个连接去建立心跳机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeServer</span> <span class="keyword">implements</span> <span class="title">ExchangeServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduled = Executors.</span><br><span class="line">   newScheduledThreadPool(<span class="number">1</span>,<span class="keyword">new</span> NamedThreadFactory(</span><br><span class="line">   <span class="string">"dubbo-remoting-server-heartbeat"</span>, <span class="keyword">true</span>));</span><br><span class="line">  <span class="comment">// 心跳定时器</span></span><br><span class="line">  <span class="keyword">private</span> ScheduledFuture&lt;?&gt; heatbeatTimer;</span><br><span class="line">  <span class="comment">// 心跳超时，毫秒。缺省0，不会执行心跳。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Server server;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeServer</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..属性赋值</span></span><br><span class="line">    <span class="comment">//心跳</span></span><br><span class="line">    startHeatbeatTimer();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeatbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//关闭心跳定时</span></span><br><span class="line">      stopHeartbeatTimer();</span><br><span class="line">      <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//每隔heartbeat时间执行一次</span></span><br><span class="line">          heatbeatTimer = scheduled.scheduleWithFixedDelay(</span><br><span class="line">                  <span class="keyword">new</span> HeartBeatTask( <span class="keyword">new</span> HeartBeatTask.ChannelProvider() &#123;</span><br><span class="line">                      <span class="comment">//获取channels</span></span><br><span class="line">                      <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                          <span class="keyword">return</span> Collections.unmodifiableCollection(</span><br><span class="line">                                  HeaderExchangeServer.<span class="keyword">this</span>.getChannels() );</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;, heartbeat, heartbeatTimeout),</span><br><span class="line">                  heartbeat, heartbeat,TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//关闭心跳定时</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopHeartbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              ScheduledFuture&lt;?&gt; timer = heatbeatTimer;</span><br><span class="line">              <span class="keyword">if</span> (timer != <span class="keyword">null</span> &amp;&amp; ! timer.isCancelled()) &#123;</span><br><span class="line">                  timer.cancel(<span class="keyword">true</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              logger.warn(t.getMessage(), t);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              heatbeatTimer =<span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h1 id="服务注册的过程"><a href="#服务注册的过程" class="headerlink" title="服务注册的过程"></a>服务注册的过程</h1><p>前面，我们已经知道，基于spring这个解析入口，到发布服务的过程，接着基于DubboProtocol去发布，最终调用Netty的api创建了一个NettyServer。</p>
<p>那么继续沿着RegistryProtocol.export这个方法，来看看注册服务的代码</p>
<h2 id="RegistryProtocol-export"><a href="#RegistryProtocol-export" class="headerlink" title="RegistryProtocol.export"></a>RegistryProtocol.export</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//export invoker通过DubboProtocal发布本地服务</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">    <span class="comment">//registry provider 这个方法是invoker的地址获取registry实例</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">    registry.register(registedProviderUrl);</span><br><span class="line">    <span class="comment">// 订阅override数据</span></span><br><span class="line">    <span class="comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span></span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">//保证每次export都返回一个新的exporter实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Exporter&lt;T&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                exporter.unexport();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                registry.unregister(registedProviderUrl);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                overrideListeners.remove(overrideSubscribeUrl);</span><br><span class="line">                registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getRegistry"><a href="#getRegistry" class="headerlink" title="getRegistry"></a>getRegistry</h2><p>这个方法是invoker的地址获取registry实例</p>
<p>registry://192.168.11.156：2181的协议地址 , registryUrl就会变成了zookeeper://192.168.11.156   </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据invoker的地址获取registry实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> originInvoker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function">Registry <span class="title">getRegistry</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span></span>&#123;</span><br><span class="line">    URL registryUrl = originInvoker.getUrl(); <span class="comment">//获得registry://192.168.11.156：2181的协议地址</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(registryUrl.getProtocol())) &#123;</span><br><span class="line"><span class="comment">//得到zookeeper的协议地址</span></span><br><span class="line">        String protocol = registryUrl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_DIRECTORY);</span><br><span class="line">        <span class="comment">//registryUrl就会变成了zookeeper://192.168.11.156</span></span><br><span class="line">registryUrl = registryUrl.setProtocol(protocol).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//registryFactory是什么？</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> registryFactory.<span class="title">getRegistry</span><span class="params">(registryUrl)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="registryFactory-getRegistry"><a href="#registryFactory-getRegistry" class="headerlink" title="registryFactory.getRegistry"></a>registryFactory.getRegistry</h3><p>这段代码很明显了，通过前面这段代码的分析，其实就是把registry的协议头改成服务提供者配置的协议地址，也就是我们配置的</p>
<p><strong><dubbo:registry address="”zookeeper://192.168.11.156:2181”/"></dubbo:registry></strong></p>
<p>然后registryFactory.getRegistry的目的，就是通过协议地址匹配到对应的注册中心。那registryFactory是一个什么样的对象呢？，我们找一下这个代码的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RegistryFactory registryFactory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegistryFactory</span><span class="params">(RegistryFactory registryFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.registryFactory = registryFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码有点眼熟，再来看看<code>RegistryFactory</code>这个类的定义，我猜想一定是一个扩展点，不信，咱们看</p>
<p>并且，大家还要注意这里面的一个方法上，有一个@Adaptive的注解，说明什么？ 这个是一个自适应扩展点。按照我们之前看过代码，自适应扩展点加在方法</p>
<p>层面上，表示会动态生成一个自适应的适配器。所以这个自适应适配器应该是<code>RegistryFactory$Adaptive</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(<span class="meta-string">"dubbo"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Adaptive(&#123;<span class="meta-string">"protocol"</span>&#125;)</span></span><br><span class="line">    Registry getRegistry(URL url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">dubbo</span>.<span class="title">registry</span>.<span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> com.alibaba.dubbo.registry.Registry getRegistry(com.alibaba.dubbo.<span class="keyword">common</span>.URL arg0) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        com.alibaba.dubbo.<span class="keyword">common</span>.URL url = arg0;</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.registry.RegistryFactory) "</span> +</span><br><span class="line">                    <span class="string">"name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        com.alibaba.dubbo.registry.RegistryFactory extension =</span><br><span class="line">                (com.alibaba.dubbo.registry.RegistryFactory)</span><br><span class="line">                        ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.registry.RegistryFactory.class).</span><br><span class="line">                                getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getRegistry(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZookeeperRegistryFactory"><a href="#ZookeeperRegistryFactory" class="headerlink" title="ZookeeperRegistryFactory"></a>ZookeeperRegistryFactory</h3><p>这个方法中并没有getRegistry方法，而是在父类AbstractRegistryFactory</p>
<ol>
<li><p>从缓存REGISTRIES中，根据key获得对应的Registry</p>
</li>
<li><p>如果不存在，则创建Registry</p>
</li>
</ol>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Registry getRegistry(URL url) &#123;</span><br><span class="line">   url = url.setPath(RegistryService.class.getName())</span><br><span class="line">         .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">         .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);</span><br><span class="line">   <span class="keyword">String</span> <span class="built_in">key</span> = url.toServiceString();</span><br><span class="line">    <span class="comment">// 锁定注册中心获取过程，保证注册中心单一实例</span></span><br><span class="line">    LOCK.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Registry registry = REGISTRIES.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> registry;</span><br><span class="line">        &#125;</span><br><span class="line">        registry = createRegistry(url);</span><br><span class="line">        <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create registry "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        REGISTRIES.put(<span class="built_in">key</span>, registry);</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="createRegistry"><a href="#createRegistry" class="headerlink" title="createRegistry"></a>createRegistry</h3><p>创建一个注册中心，这个是一个抽象方法，具体的实现在对应的子类实例中实现的，在<code>ZookeeperRegistryFactory</code>中</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span>(<span class="params">URL url</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//通过zkClient，获得一个zookeeper的连接实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span>(<span class="params">URL url, ZookeeperTransporter zookeeperTransporter</span>) </span>&#123;</span><br><span class="line">    super(url);</span><br><span class="line">    <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    String <span class="keyword">group</span> = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">group</span>.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">        <span class="keyword">group</span> = Constants.PATH_SEPARATOR + <span class="keyword">group</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">group</span>; <span class="comment">//设置根节点</span></span><br><span class="line">    zkClient = zookeeperTransporter.connect(url);<span class="comment">//建立连接</span></span><br><span class="line">    zkClient.addStateListener(<span class="keyword">new</span> StateListener() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span>(<span class="params"><span class="keyword">int</span> state</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (state == RECONNECTED) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">     			 recover();</span><br><span class="line">  		   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      		logger.error(e.getMessage(), e);</span><br><span class="line">        	&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码分析到这里，我们对于getRegistry得出了一个结论，根据当前注册中心的配置信息，获得一个匹配的注册中心，也就是ZookeeperRegistry </p>
<h2 id="registry-register-registedProviderUrl"><a href="#registry-register-registedProviderUrl" class="headerlink" title="registry.register(registedProviderUrl);"></a>registry.register(registedProviderUrl);</h2><p>ZookeeperRegistry extends FailbackRegistry</p>
<p>继续往下分析，会调用<code>registry.register</code>去将<code>dubbo://</code>的协议地址注册到zookeeper上</p>
<p>这个方法会调用<code>FailbackRegistry</code>类中的register. 为什么呢？因为ZookeeperRegistry这个类中并没有register这个方法，但是他的父类FailbackRegistry中存在register方法，而这个类又重写了AbstractRegistry类中的register方法。所以我们可以直接定位<code>FailbackRegistry</code>这个类中的register方法中</p>
<h3 id="FailbackRegistry-register"><a href="#FailbackRegistry-register" class="headerlink" title="FailbackRegistry.register"></a>FailbackRegistry.register</h3><ol>
<li><p>FailbackRegistry，从名字上来看，是一个失败重试机制</p>
</li>
<li><p>调用父类的register方法，讲当前url添加到缓存集合中</p>
</li>
<li><p>调用doRegister方法，这个方法很明显，是一个抽象方法，会由ZookeeperRegistry子类实现。</p>
</li>
</ol>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> register(URL <span class="built_in">url</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.register(<span class="built_in">url</span>);</span><br><span class="line">    failedRegistered.remove(<span class="built_in">url</span>);</span><br><span class="line">    failedUnregistered.remove(<span class="built_in">url</span>);</span><br><span class="line">    <span class="title">try</span> &#123;</span><br><span class="line">        <span class="comment">// 向服务器端发送注册请求</span></span><br><span class="line">        doRegister(<span class="built_in">url</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Throwable t = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果开启了启动时检测，则直接抛出异常</span></span><br><span class="line">        boolean check = getUrl().getParameter(Constants.CHECK_KEY, <span class="literal">true</span>)</span><br><span class="line">                &amp;&amp; <span class="built_in">url</span>.getParameter(Constants.CHECK_KEY, <span class="literal">true</span>)</span><br><span class="line">                &amp;&amp; ! Constants.CONSUMER_PROTOCOL.equals(<span class="built_in">url</span>.getProtocol());</span><br><span class="line">        boolean skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">        <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">            <span class="keyword">if</span>(skipFailback) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to register "</span> + <span class="built_in">url</span> + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125; <span class="title">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">"Failed to register "</span> + <span class="built_in">url</span> + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将失败的注册请求记录到失败列表，定时重试</span></span><br><span class="line">        failedRegistered.add(<span class="built_in">url</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">void</span> doRegister(URL <span class="built_in">url</span>) &#123;</span><br><span class="line">    <span class="title">try</span> &#123;</span><br><span class="line">       zkClient.create(toUrlPath(<span class="built_in">url</span>), <span class="built_in">url</span>.getParameter(Constants.DYNAMIC_KEY, <span class="literal">true</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register "</span> + <span class="built_in">url</span> + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RegistryProtocol.export 这个方法中后续的代码就不用再分析了。就是去对服务提供端去注册一个zookeeper监听，当监听发生变化的时候，服务端做相应的处理。 </p>
<h1 id="消费端启动初始化过程"><a href="#消费端启动初始化过程" class="headerlink" title="消费端启动初始化过程"></a>消费端启动初始化过程</h1><p>消费端的代码解析是从下面这段代码开始的</p>
<dubbo:reference id="xxxService" interface="xxx.xxx.Service">

<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceBean<span class="function"><span class="params">(afterPropertiesSet)</span> -&gt;</span>getObject<span class="function"><span class="params">()</span> -&gt;</span>get<span class="function"><span class="params">()</span>-&gt;</span>init<span class="function"><span class="params">()</span>-&gt;</span>createProxy  最终会获得一个代理对象。</span><br></pre></td></tr></table></figure>
<h2 id="createProxy第375行"><a href="#createProxy第375行" class="headerlink" title="createProxy第375行"></a>createProxy第375行</h2><p>前面很多代码都是初始化的动作，需要仔细分析的代码代码从createProxy第375行开始</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>); <span class="comment">//从注册中心上获得相应的协议url地址</span></span><br><span class="line"><span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">           URL monitorUrl = loadMonitor(u); </span><br><span class="line">           <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="built_in">map</span>.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">           &#125;</span><br><span class="line">           urls.<span class="built_in">add</span>(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(<span class="built_in">map</span>)));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such any registry to reference "</span> + interfaceName  + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", please config &lt;dubbo:registry address=\"...\" /&gt; to your spring config."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">if</span> (urls.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">    invoker = refprotocol.refer(interfaceClass, urls.<span class="built_in">get</span>(<span class="number">0</span>)); <span class="comment">//获得invoker代理对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">    URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">        invokers.<span class="built_in">add</span>(refprotocol.refer(interfaceClass, url));</span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">            registryURL = url; <span class="comment">// 用了最后一个registry url</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// 有 注册中心协议的URL</span></span><br><span class="line">        <span class="comment">// 对有注册中心的Cluster 只用 AvailableCluster</span></span><br><span class="line">        URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME); </span><br><span class="line">        invoker = cluster.<span class="built_in">join</span>(<span class="keyword">new</span> StaticDirectory(u, invokers));</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123; <span class="comment">// 不是 注册中心的URL</span></span><br><span class="line">        invoker = cluster.<span class="built_in">join</span>(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="refprotocol-refer"><a href="#refprotocol-refer" class="headerlink" title="refprotocol.refer"></a>refprotocol.refer</h2><p>​        <code>invokers.add(refprotocol.refer(interfaceClass, url));</code></p>
<p>调用protocol的refer方法，得到invoker， 传递进来的参数url，协议地址为registry://。</p>
<p>refprotocol这个对象，定义的代码如下，是一个自适应扩展点，得到的是<code>Protocol$Adaptive</code></p>
<p>ReferenceConfig中refprotocol的定义如下</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.<span class="keyword">class</span>).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>
<p>所以最终调用RegistryProtocol.refer代码</p>
<h2 id="RegistryProtocol-refer"><a href="#RegistryProtocol-refer" class="headerlink" title="RegistryProtocol.refer"></a>RegistryProtocol.refer</h2><p>这个方法里面的代码，基本上都能看懂<br>1.根据根据url获得注册中心，这个registry是zookeeperRegistry<br>2.调用doRefer，按方法，传递了几个参数， 其中有一个culster参数，这个需要注意下</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; <span class="keyword">type</span>, URL url) throws RpcException &#123;</span><br><span class="line"></span><br><span class="line">       url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line"></span><br><span class="line">       Registry registry = registryFactory.getRegistry(url);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (RegistryService.class.<span class="keyword">equals</span>(<span class="keyword">type</span>)) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, <span class="keyword">type</span>, url);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// group="a,b" or group="*"</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));</span><br><span class="line"></span><br><span class="line">       <span class="built_in">String</span> <span class="keyword">group</span> = qs.get(Constants.GROUP_KEY);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">group</span> != <span class="built_in">null</span> &amp;&amp; <span class="keyword">group</span>.length() &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ( ( Constants.COMMA_SPLIT_PATTERN.split( <span class="keyword">group</span> ) ).length &gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                   || <span class="string">"*"</span>.<span class="keyword">equals</span>( <span class="keyword">group</span> ) ) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> doRefer( getMergeableCluster(), registry, <span class="keyword">type</span>, url );</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> doRefer(cluster, registry, <span class="keyword">type</span>, url);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><p>doRefer方法中有一个参数是cluster,我们找到它的定义代码如下，。又是一个自动注入的扩展点。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">Cluster</span> <span class="keyword">cluster</span>;</span><br><span class="line"></span><br><span class="line">public void setCluster(<span class="keyword">Cluster</span> <span class="keyword">cluster</span>) &#123;</span><br><span class="line">    this.<span class="keyword">cluster</span> = <span class="keyword">cluster</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从下面的代码可以看出，这个不仅仅是一个扩展点，而且方法层面上，还有一个@Adaptive，表示会动态生成一个自适应适配器Cluster$Adaptive</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(FailoverCluster.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cluster-Adaptive"><a href="#Cluster-Adaptive" class="headerlink" title="Cluster$Adaptive"></a>Cluster$Adaptive</h3><p>通过debug的方式，，获取到Cluster$Adaptive这个适配器，代码如下。我们知道cluster这个对象的实例以后，继续看doRefer方法；<br>注意：这里的Cluster$Adaptive也并不单纯，大家还记得在讲扩展点的时候有一个扩展点装饰器吗？如果这个扩展点存在一个构造函数，并且构造函数就是扩展接口本身，那么这个扩展点就会这个wrapper装饰，而Cluster被装饰的是：MockClusterWrapper</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cluster</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">cluster</span>.<span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Invoker <span class="title">join</span><span class="params">(Directory arg0)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"com.alibaba.dubbo.rpc.cluster.Directory argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"com.alibaba.dubbo.rpc.cluster.Directory argument getUrl() == null"</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        String extName = url.getParameter(<span class="string">"cluster"</span>, <span class="string">"failover"</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.rpc.cluster.Cluster) name from url("</span> + url.toString() + <span class="string">") use keys([cluster])"</span>);</span><br><span class="line">        com.alibaba.dubbo.rpc.cluster.Cluster extension = (com.alibaba.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.cluster.Cluster.class).getExtension(extName);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> extension.<span class="title">join</span><span class="params">(arg0)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RegistryProtocol-doRefer"><a href="#RegistryProtocol-doRefer" class="headerlink" title="RegistryProtocol.doRefer"></a>RegistryProtocol.doRefer</h2><p>这段代码中，有一个RegistryDirectory,可能看不懂，我们暂时先忽略，等会单独讲.（基于注册中心动态发现服务提供者）</p>
<ol>
<li>将consumer://协议地址注册到注册中心</li>
<li>registryDirectory的subscribe方法，订阅zookeeper地址的变化</li>
<li>调用cluster.join()方法</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">private</span> &lt;<span class="type">T</span>&gt; <span class="type">Invoker</span>&lt;<span class="type">T</span>&gt; doRefer(<span class="type">Cluster</span> cluster, <span class="type">Registry</span> registry, <span class="type">Class</span>&lt;<span class="type">T</span>&gt; <span class="class"><span class="keyword">type</span>, <span class="type">URL</span> url) &#123;</span></span><br><span class="line"><span class="class">    <span class="type">RegistryDirectory</span>&lt;<span class="type">T</span>&gt; <span class="title">directory</span> = <span class="title">new</span> <span class="type">RegistryDirectory</span>&lt;<span class="type">T</span>&gt;(<span class="title">type</span>, <span class="title">url</span>);</span></span><br><span class="line"><span class="class">    <span class="title">directory</span>.<span class="title">setRegistry</span>(<span class="title">registry</span>);</span></span><br><span class="line"><span class="class">    <span class="title">directory</span>.<span class="title">setProtocol</span>(<span class="title">protocol</span>);</span></span><br><span class="line"><span class="class">    <span class="type">URL</span> <span class="title">subscribeUrl</span> = <span class="title">new</span> <span class="type">URL</span>(<span class="type">Constants</span>.<span class="type">CONSUMER_PROTOCOL</span>, <span class="type">NetUtils</span>.<span class="title">getLocalHost</span>(), 0, <span class="title">type</span>.<span class="title">getName</span>(), <span class="title">directory</span>.<span class="title">getUrl</span>().<span class="title">getParameters</span>());</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">if</span> (! <span class="type">Constants</span>.<span class="type">ANY_VALUE</span>.<span class="title">equals</span>(<span class="title">url</span>.<span class="title">getServiceInterface</span>())</span></span><br><span class="line"><span class="class">            &amp;&amp; <span class="title">url</span>.<span class="title">getParameter</span>(<span class="type">Constants</span>.<span class="type">REGISTER_KEY</span>, <span class="title">true</span>)) &#123;</span></span><br><span class="line"><span class="class">// 将<span class="title">consumer</span>://协议地址注册到注册中心        <span class="title">registry</span>.<span class="title">register</span>(<span class="title">subscribeUrl</span>.<span class="title">addParameters</span>(<span class="type">Constants</span>.<span class="type">CATEGORY_KEY</span>, <span class="type">Constants</span>.<span class="type">CONSUMERS_CATEGORY</span>,</span></span><br><span class="line"><span class="class">                <span class="type">Constants</span>.<span class="type">CHECK_KEY</span>, <span class="type">String</span>.<span class="title">valueOf</span>(<span class="title">false</span>)));</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line">    //通过registryDirectory的subscribe，</span><br><span class="line">    directory.subscribe(subscribeUrl.addParameter(<span class="type">Constants</span>.<span class="type">CATEGORY_KEY</span>, </span><br><span class="line">            <span class="type">Constants</span>.<span class="type">PROVIDERS_CATEGORY</span> </span><br><span class="line">            + <span class="string">","</span> + <span class="type">Constants</span>.<span class="type">CONFIGURATORS_CATEGORY</span> </span><br><span class="line">            + <span class="string">","</span> + <span class="type">Constants</span>.<span class="type">ROUTERS_CATEGORY</span>));</span><br><span class="line">            </span><br><span class="line">    return cluster.join(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cluster-join"><a href="#cluster-join" class="headerlink" title="cluster.join"></a>cluster.join</h3><p>由前面的Cluster$Adaptive这个类中的join方法的分析，得知cluster.join会调用<code>MockClusterWrapper.join</code>方法， 然后再调用<code>FailoverCluster.join</code>方法。</p>
<h4 id="MockClusterWrapper-join"><a href="#MockClusterWrapper-join" class="headerlink" title="MockClusterWrapper.join"></a>MockClusterWrapper.join</h4><p>这个意思很明显了。也就是我们上节课讲过的mock容错机制，如果出现异常情况，会调用MockClusterInvoker，否则，调用FailoverClusterInvoker.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockClusterWrapper</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Cluster cluster;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MockClusterWrapper</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MockClusterInvoker&lt;T&gt;(directory,</span><br><span class="line">            <span class="keyword">this</span>.cluster.join(directory));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>refprotocol.ref，这个方法，会返回一个MockClusterInvoker(FailoverClusterInvoker)。这里面一定还有疑问，我们先把主线走完，再回过头看看什么是cluster、什么是directory</p>
<h2 id="proxyFactory-getProxy-invoker"><a href="#proxyFactory-getProxy-invoker" class="headerlink" title="proxyFactory.getProxy(invoker);"></a>proxyFactory.getProxy(invoker);</h2><p>再回到ReferenceConfig这个类，在createProxy方法的最后一行，调用proxyFactory.getProxy(invoker). 把前面生成的invoker对象作为参数，再通过proxyFactory工厂去获得一个代理对象。接下来我们分析下这段代码做了什么。</p>
<blockquote>
<p>其实前面在分析服务发布的时候，基本分析过了，所以再看这段代码，应该会很熟悉</p>
<p>ProxyFactory， 会生成一个动态的自适应适配器。ProxyFactory$Adaptive，然后调用这个适配器中的getProxy方法，代码如下</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReferenceConfig</span><br><span class="line"><span class="comment">// 创建服务代理</span></span><br><span class="line">        <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br></pre></td></tr></table></figure>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.Object getProxy(Invoker arg0) throws RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"com.alibaba.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null"</span>);com.alibaba.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">String</span> extName = url.getParameter(<span class="string">"proxy"</span>, <span class="string">"javassist"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url("</span> + url.toString() + <span class="string">") use keys([proxy])"</span>);</span><br><span class="line">        com.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> extension.getProxy(arg0);</span><br></pre></td></tr></table></figure>
<p>很显然，又是通过javassist实现的一个动态代理，我们来看看JavassistProxyFactory.getProxy</p>
<h3 id="JavassistProxyFactory-getProxy"><a href="#JavassistProxyFactory-getProxy" class="headerlink" title="JavassistProxyFactory.getProxy"></a>JavassistProxyFactory.getProxy</h3><p>通过javasssist动态字节码生成动态代理类，</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).<span class="keyword">new</span><span class="type">Instance</span>(<span class="keyword">new</span> <span class="type">InvokerInvocationHandler</span>(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Proxy-getProxy-interfaces"><a href="#Proxy-getProxy-interfaces" class="headerlink" title="Proxy.getProxy(interfaces)"></a>Proxy.getProxy(interfaces)</h3><p>在Proxy.getProxy这个类的如下代码中添加断点，在debug下可以看到动态字节码如下</p>
<p><img src="http://oz3qait0p.bkt.clouddn.com/Proxy%20getProxy%20debug.png" alt="http://oz3qait0p.bkt.clouddn.com/Proxy%20getProxy%20debug.png"></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="keyword">String</span> sayHello(java.lang.<span class="keyword">String</span> arg0)&#123;</span><br><span class="line">  <span class="keyword">Object</span>[] args = <span class="keyword">new</span> <span class="keyword">Object</span>[<span class="number">1</span>]; </span><br><span class="line">  args[<span class="number">0</span>] = ($w)$<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">Object</span> ret = handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], args); </span><br><span class="line"><span class="keyword">return</span> (java.lang.<span class="keyword">String</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的handler，就是在JavassistProxyFactory.getProxy中。传递的new InvokerInvocationHandler(invoker)</p>
<h1 id="什么时候建立和服务端的连接"><a href="#什么时候建立和服务端的连接" class="headerlink" title="什么时候建立和服务端的连接"></a>什么时候建立和服务端的连接</h1><p>前面我们通过代码分析到了，消费端的初始化过程，但是似乎没有看到客户端和服务端建立NIO连接。实际上，建立连接的过程在消费端初始化的时候就建立好的，只是前面我们没有分析，代码在<code>RegistryProtocol.doRefer</code>方法内的<code>directory.subscribe</code>方法中。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">private</span> &lt;<span class="type">T</span>&gt; <span class="type">Invoker</span>&lt;<span class="type">T</span>&gt; doRefer(<span class="type">Cluster</span> cluster, <span class="type">Registry</span> registry, <span class="type">Class</span>&lt;<span class="type">T</span>&gt; <span class="class"><span class="keyword">type</span>, <span class="type">URL</span> url) &#123;</span></span><br><span class="line"><span class="class">    <span class="type">RegistryDirectory</span>&lt;<span class="type">T</span>&gt; <span class="title">directory</span> = <span class="title">new</span> <span class="type">RegistryDirectory</span>&lt;<span class="type">T</span>&gt;(<span class="title">type</span>, <span class="title">url</span>);</span></span><br><span class="line"><span class="class">    <span class="title">directory</span>.<span class="title">setRegistry</span>(<span class="title">registry</span>);</span></span><br><span class="line"><span class="class">    <span class="title">directory</span>.<span class="title">setProtocol</span>(<span class="title">protocol</span>);</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    // <span class="title">consumer</span>://192.***</span></span><br><span class="line"><span class="class">    <span class="type">URL</span> <span class="title">subscribeUrl</span> = <span class="title">new</span> <span class="type">URL</span>(<span class="type">Constants</span>.<span class="type">CONSUMER_PROTOCOL</span>, <span class="type">NetUtils</span>.<span class="title">getLocalHost</span>(), 0, <span class="title">type</span>.<span class="title">getName</span>(), <span class="title">directory</span>.<span class="title">getUrl</span>().<span class="title">getParameters</span>());</span></span><br><span class="line"><span class="class">    <span class="title">if</span> (! <span class="type">Constants</span>.<span class="type">ANY_VALUE</span>.<span class="title">equals</span>(<span class="title">url</span>.<span class="title">getServiceInterface</span>())</span></span><br><span class="line"><span class="class">            &amp;&amp; <span class="title">url</span>.<span class="title">getParameter</span>(<span class="type">Constants</span>.<span class="type">REGISTER_KEY</span>, <span class="title">true</span>)) &#123;</span></span><br><span class="line"><span class="class">        // <span class="title">consumer</span>://192.***注册到<span class="title">zk</span>注册中心</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">    <span class="title">registry</span>.<span class="title">register</span>(<span class="title">subscribeUrl</span>.<span class="title">addParameters</span>(<span class="type">Constants</span>.<span class="type">CATEGORY_KEY</span>, <span class="type">Constants</span>.<span class="type">CONSUMERS_CATEGORY</span>,</span></span><br><span class="line"><span class="class">                <span class="type">Constants</span>.<span class="type">CHECK_KEY</span>, <span class="type">String</span>.<span class="title">valueOf</span>(<span class="title">false</span>)));</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line">    </span><br><span class="line">    //registryDirectory订阅provider、configurator、router的目录的变化</span><br><span class="line">    directory.subscribe(subscribeUrl.addParameter(<span class="type">Constants</span>.<span class="type">CATEGORY_KEY</span>, </span><br><span class="line">            <span class="type">Constants</span>.<span class="type">PROVIDERS_CATEGORY</span> </span><br><span class="line">            + <span class="string">","</span> + <span class="type">Constants</span>.<span class="type">CONFIGURATORS_CATEGORY</span> </span><br><span class="line">            + <span class="string">","</span> + <span class="type">Constants</span>.<span class="type">ROUTERS_CATEGORY</span>));</span><br><span class="line">            </span><br><span class="line">    return cluster.join(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="directory-subscribe"><a href="#directory-subscribe" class="headerlink" title="directory.subscribe"></a>directory.subscribe</h2><p>RegistryProtocol的refer方法<code>Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url)</code>，传入的参数url为<code>zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=dubbo-client-demo</code></p>
<p>而registryFactory是RegistryFactory$Adaptive，所以根据url的protocol，实际调用的是ZookeeperRegistryFactory的getRegistry方法，最终得到ZookeeperRegsitry实例。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RegistryProtocol</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; <span class="keyword">type</span>, URL url) throws RpcException &#123;</span><br><span class="line">        url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//ZookeeperRegistyFactory得到ZookeeperRegistry</span></span><br><span class="line">        Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">        <span class="keyword">if</span> (RegistryService.class.<span class="keyword">equals</span>(<span class="keyword">type</span>)) &#123;</span><br><span class="line">        	<span class="keyword">return</span> proxyFactory.getInvoker((T) registry, <span class="keyword">type</span>, url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// group="a,b" or group="*"</span></span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));</span><br><span class="line">        <span class="built_in">String</span> <span class="keyword">group</span> = qs.get(Constants.GROUP_KEY);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">group</span> != <span class="built_in">null</span> &amp;&amp; <span class="keyword">group</span>.length() &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ( Constants.COMMA_SPLIT_PATTERN.split( <span class="keyword">group</span> ) ).length &gt; <span class="number">1</span></span><br><span class="line">                    || <span class="string">"*"</span>.<span class="keyword">equals</span>( <span class="keyword">group</span> ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> doRefer( getMergeableCluster(), registry, <span class="keyword">type</span>, url );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doRefer(cluster, registry, <span class="keyword">type</span>, url);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在RegistryProtocol的doRefer方法中，directory.setResgitry中参数为zookeeperRegistry。</p>
<p><strong>因为ZookeeperRegistry extends FailbackRegistry，FailbackRegistry extends AbstractRegistry</strong></p>
<p>所以registryDirectory的调用链为： RegistryDirectory.subscribe -&gt;FailbackRegistry. subscribe-&gt;- AbstractRegistry.subscribe&gt;zookeeperRegistry.doSubscribe</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RegistryDirectory</span></span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> subscribe(URL <span class="built_in">url</span>) &#123;</span><br><span class="line">    setConsumerUrl(<span class="built_in">url</span>);</span><br><span class="line">    registry.subscribe(<span class="built_in">url</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FailbackRegistry-subscribe"><a href="#FailbackRegistry-subscribe" class="headerlink" title="FailbackRegistry. subscribe"></a>FailbackRegistry. subscribe</h2><p>调用FailbackRegistry.subscribe 进行订阅，这里有一个特殊处理，如果订阅失败，则会添加到定时任务中进行重试</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.subscribe(url, listener);</span><br><span class="line">    removeFailedSubscribed(url, listener);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 向服务器端发送订阅请求</span></span><br><span class="line">        doSubscribe(url, listener);</span><br></pre></td></tr></table></figure>
<h2 id="zookeeperRegistry-doSubscribe"><a href="#zookeeperRegistry-doSubscribe" class="headerlink" title="zookeeperRegistry. doSubscribe"></a>zookeeperRegistry. doSubscribe</h2><p>调用zookeeperRegistry执行真正的订阅操作，这段代码太长，我就不贴出来了，这里面主要做两个操作</p>
<ol>
<li><p>对providers/routers/configurator三个节点进行创建和监听</p>
</li>
<li><p>调用notify(url,listener,urls) 将已经可用的列表进行通知</p>
</li>
</ol>
<h2 id="AbstractRegistry-notify"><a href="#AbstractRegistry-notify" class="headerlink" title="AbstractRegistry.notify"></a>AbstractRegistry.notify</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">void</span> notify(URL url, NotifyListener listener, <span class="built_in">List</span>&lt;URL&gt; urls) &#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((urls == <span class="keyword">null</span> || urls.size() == <span class="number">0</span>) </span><br><span class="line">            &amp;&amp; ! Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Ignore empty notify urls for subscribe url "</span> + url);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Notify urls for subscribe url "</span> + url + <span class="string">", urls: "</span> + urls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;URL&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">           <span class="built_in">String</span> category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">           <span class="built_in">List</span>&lt;URL&gt; categoryList = result.<span class="keyword">get</span>(category);</span><br><span class="line">           <span class="keyword">if</span> (categoryList == <span class="keyword">null</span>) &#123;</span><br><span class="line">              categoryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">              result.put(category, categoryList);</span><br><span class="line">           &#125;</span><br><span class="line">           categoryList.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;URL&gt;&gt; categoryNotified = notified.<span class="keyword">get</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (categoryNotified == <span class="keyword">null</span>) &#123;</span><br><span class="line">        notified.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;URL&gt;&gt;());</span><br><span class="line">        categoryNotified = notified.<span class="keyword">get</span>(url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">        <span class="built_in">String</span> category = entry.getKey();</span><br><span class="line">        <span class="built_in">List</span>&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">        categoryNotified.put(category, categoryList);</span><br><span class="line">        saveProperties(url);</span><br><span class="line">        listener.notify(categoryList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>消费端初始化这块就完了</p>
</dubbo:reference>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/24/Dubbo源码分析之ExtensionLoader动态扩展/" rel="next" title="Dubbo源码分析之ExtensionLoader动态扩展">
                <i class="fa fa-chevron-left"></i> Dubbo源码分析之ExtensionLoader动态扩展
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/25/SpringBoot源码分析之条件注解的底层实现/" rel="prev" title="SpringBoot源码分析之条件注解的底层实现">
                SpringBoot源码分析之条件注解的底层实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/xiaowu_avatar.jpg"
                alt="周小伍 Joey" />
            
              <p class="site-author-name" itemprop="name">周小伍 Joey</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">175</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#服务端发布流程"><span class="nav-number">1.</span> <span class="nav-text">服务端发布流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#delay作用"><span class="nav-number">1.1.</span> <span class="nav-text">delay作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#doExportUrlsFor1Protocol"><span class="nav-number">1.2.</span> <span class="nav-text">doExportUrlsFor1Protocol</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#createExtension"><span class="nav-number">1.3.</span> <span class="nav-text">createExtension</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getExtensionClasses"><span class="nav-number">1.4.</span> <span class="nav-text">getExtensionClasses</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ResigtryProtocol"><span class="nav-number">2.</span> <span class="nav-text">ResigtryProtocol</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分析ProtocolFilterWrapper和ProtocolListenerWrapper"><span class="nav-number">2.1.</span> <span class="nav-text">分析ProtocolFilterWrapper和ProtocolListenerWrapper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ProtocolFilterWrapper"><span class="nav-number">2.1.1.</span> <span class="nav-text">ProtocolFilterWrapper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProtocolListenerWrapper"><span class="nav-number">2.1.2.</span> <span class="nav-text">ProtocolListenerWrapper</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DubboProtocol-export"><span class="nav-number">2.2.</span> <span class="nav-text">DubboProtocol.export</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#openServer"><span class="nav-number">2.2.1.</span> <span class="nav-text">openServer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#createServer"><span class="nav-number">2.2.2.</span> <span class="nav-text">createServer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchangers-bind"><span class="nav-number">2.2.3.</span> <span class="nav-text">Exchangers.bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HeaderExchanger-bind"><span class="nav-number">2.2.4.</span> <span class="nav-text">HeaderExchanger.bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NettyTransport-bind"><span class="nav-number">2.2.5.</span> <span class="nav-text">NettyTransport.bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-HeaderExchangeServer"><span class="nav-number">2.2.6.</span> <span class="nav-text">new HeaderExchangeServer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务注册的过程"><span class="nav-number">3.</span> <span class="nav-text">服务注册的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RegistryProtocol-export"><span class="nav-number">3.1.</span> <span class="nav-text">RegistryProtocol.export</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getRegistry"><span class="nav-number">3.2.</span> <span class="nav-text">getRegistry</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#registryFactory-getRegistry"><span class="nav-number">3.2.1.</span> <span class="nav-text">registryFactory.getRegistry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZookeeperRegistryFactory"><span class="nav-number">3.2.2.</span> <span class="nav-text">ZookeeperRegistryFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#createRegistry"><span class="nav-number">3.2.3.</span> <span class="nav-text">createRegistry</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#registry-register-registedProviderUrl"><span class="nav-number">3.3.</span> <span class="nav-text">registry.register(registedProviderUrl);</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FailbackRegistry-register"><span class="nav-number">3.3.1.</span> <span class="nav-text">FailbackRegistry.register</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消费端启动初始化过程"><span class="nav-number">4.</span> <span class="nav-text">消费端启动初始化过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#createProxy第375行"><span class="nav-number">4.1.</span> <span class="nav-text">createProxy第375行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#refprotocol-refer"><span class="nav-number">4.2.</span> <span class="nav-text">refprotocol.refer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RegistryProtocol-refer"><span class="nav-number">4.3.</span> <span class="nav-text">RegistryProtocol.refer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster"><span class="nav-number">4.3.1.</span> <span class="nav-text">cluster</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cluster-Adaptive"><span class="nav-number">4.3.2.</span> <span class="nav-text">Cluster$Adaptive</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RegistryProtocol-doRefer"><span class="nav-number">4.4.</span> <span class="nav-text">RegistryProtocol.doRefer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster-join"><span class="nav-number">4.4.1.</span> <span class="nav-text">cluster.join</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MockClusterWrapper-join"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">MockClusterWrapper.join</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">4.5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#proxyFactory-getProxy-invoker"><span class="nav-number">4.6.</span> <span class="nav-text">proxyFactory.getProxy(invoker);</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavassistProxyFactory-getProxy"><span class="nav-number">4.6.1.</span> <span class="nav-text">JavassistProxyFactory.getProxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-getProxy-interfaces"><span class="nav-number">4.6.2.</span> <span class="nav-text">Proxy.getProxy(interfaces)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么时候建立和服务端的连接"><span class="nav-number">5.</span> <span class="nav-text">什么时候建立和服务端的连接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#directory-subscribe"><span class="nav-number">5.1.</span> <span class="nav-text">directory.subscribe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FailbackRegistry-subscribe"><span class="nav-number">5.2.</span> <span class="nav-text">FailbackRegistry. subscribe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zookeeperRegistry-doSubscribe"><span class="nav-number">5.3.</span> <span class="nav-text">zookeeperRegistry. doSubscribe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractRegistry-notify"><span class="nav-number">5.4.</span> <span class="nav-text">AbstractRegistry.notify</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">周小伍 Joey</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://joeyblog.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2018/06/24/Dubbo源码分析之服务发布过程/';
          this.page.identifier = '2018/06/24/Dubbo源码分析之服务发布过程/';
          this.page.title = 'Dubbo源码分析之服务发布过程';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://joeyblog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  










  





  

  

  

  

  

  

</body>
</html>
